Homomorphic Cryptography and Privacy
Chloé Hébant

To cite this version:
Chloé Hébant. Homomorphic Cryptography and Privacy. Cryptography and Security [cs.CR]. Université PSL, 2021. English. �tel-03439366�

HAL Id: tel-03439366
https://hal.archives-ouvertes.fr/tel-03439366
Submitted on 22 Nov 2021

HAL is a multi-disciplinary open access
archive for the deposit and dissemination of scientific research documents, whether they are published or not. The documents may come from
teaching and research institutions in France or
abroad, or from public or private research centers.

L’archive ouverte pluridisciplinaire HAL, est
destinée au dépôt et à la diffusion de documents
scientifiques de niveau recherche, publiés ou non,
émanant des établissements d’enseignement et de
recherche français ou étrangers, des laboratoires
publics ou privés.



Préparée à l’École Normale Supérieure de Paris

Homomorphic Cryptography and Privacy

Soutenue par

Composition du jury :

Chloé Hébant

Dario Catalano

Le 20 Mai 2021

University of Catania

Rapporteur

Benoît Libert
École Normale Supérieure de Lyon

École doctorale no 386

Caroline Fontaine

Sciences Mathématiques de
Paris Centre

École Normale Supérieure de ParisSaclay

Rapporteur

Présidente du jury

Olivier Sanders
Orange Labs, Rennes

Examinateur

David Pointcheval
École Normale Supérieure de Paris

Directeur de thèse

Spécialité

Informatique

Duong Hieu Phan
Telecom Paris
Institut Polytechnique de Paris

CoDirecteur de thèse





Résumé
Avec l’utilisation massive du stockage dématérialisé, l’homomorphisme est devenu l’une des
propriétés les plus largement employées en cryptologie. Dans cette thèse, nous allons étudier
comment l’utiliser dans des protocoles multi-utilisateurs concrets qui nécessitent non seulement
de la confidentialité, mais aussi de l’anonymat, de l’authentification ou encore de la vérifiabilité.
Pour cela, nous utilisons des schémas homomorphes de chiffrement, de signature numérique et
de preuves à divulgation nulle de connaissances, mais, à chaque fois, nous devrons limiter leurs
capacités de malléabilité pour atteindre le niveau de sécurité préalablement défini.
Tout d’abord, l’aspect confidentiel est abordé au travers de l’étude de calculs sur des bases
de données externalisées. Être capable d’appliquer des fonctions sur des données chiffrées sans
avoir à les télécharger pour les déchiffrer entièrement est permet de profiter de la puissance de
calcul du serveur qui est généralement supérieure à celle du client. Cela peut être également
indispensable lorsqu’une société sans droit d’accès à une base de données de clients souhaite
obtenir le résultat d’un calcul. La quantité d’information apprise ne doit pas être supérieure à
celle contenue dans le résultat du calcul. Nous proposons pour cela un schéma de chiffrement
décentralisé qui permet d’évaluer des fonctions quadratiques sur les données externalisées tout
en ayant un contrôle des opérations grâce à un groupe d’inspecteurs.
Cependant, la confidentialité des données n’est pas toujours la propriété la plus recherchée
pour un système car elle ne protège pas l’identité de l’expéditeur. Pour le vote électronique,
chaque bulletin chiffré doit être associé à un électeur afin de vérifier que celui-ci était autorisé
à voter, mais après la phase de vote, l’anonymat doit être assuré. Pour cela une solution est
de mélanger plusieurs fois l’urne de sorte que, au moment du dépouillement, qui correspond au
déchiffrement, aucun lien entre le vote et l’électeur ne puisse être fait. C’est le fonctionnement
d’un réseau de serveurs-mélangeurs dont nous proposons une nouvelle construction basée sur des
signatures linéairement homomorphes avec un coût de vérification de l’urne finale indépendant
du nombre de mélanges. Ce protocole est donc d’autant plus efficace que le nombre de mélanges
augmente et représente un progrès par rapport aux constructions déjà connues.
Dans certains cas, avoir un anonymat parfait permettrait l’utilisation malveillante d’un système et la cryptologie doit aussi tenir compte de ces abus potentiels. La troisième contribution
de cette thèse consiste en la proposition du premier protocole d’accréditation anonyme multiautorités traçable : un utilisateur demande une accréditation auprès d’une autorité émettrice et
peut l’utiliser pour accéder à un système tout en restant anonyme. En cas d’abus, une autorité
juge peut lever l’anonymat et retrouver un utilisateur malveillant grâce au traçage. De plus, ce
protocole, tout en étant aussi efficace que les précédents pour une seule autorité émettrice, permet d’agréger des accréditations d’autorités émettrices distinctes pour avoir une accréditation
de taille optimale .

Mots clés : Cryptographie à Clé Publique, Protocoles Homomorphes, Anonymat, Vote
Electronique, Calculs Multipartites



ii



Abstract
With the massive use of dematerialized storage, homomorphism has become one of the most
widely used properties in cryptology. In this thesis we will study how to use it in concrete
multi-users protocols requiring not only confidentiality but also anonymity, authentication or
verifiability. Homomorphic encryption schemes, homomorphic digital signatures and homomorphic zero-knowledge proofs will be used together, but each time restricted to achieve the desired
level of security.
First, the confidential aspect is studied for computations on large outsourced databases.
Being able to apply functions on encrypted data without having to download and decrypt
it entirely may be essential and allows to take advantage of the computational power of the
server. This can also be interesting when a third-party company without right-access to the
database wants to obtain the result of a computation. However, some guarantees on the learned
information need to be taken. To this end, we present a decentralized encryption scheme that
allows controlled evaluation of quadratic functions on outsourced data thanks to a group of
controllers.
However, sometimes confidentiality of the data is not the most desired property for a system
as it does not protect the sender. For electronic voting, each encrypted ballot must be associated
with its voter to verify that he is allowed to vote. After the voting phase, anonymity is achieved
by shuffling so that, during the count, which corresponds to the decryption, no link between
votes and voters can be made. We propose a new construction of mix-network based on linearly
homomorphic signatures which allows for the first time a verification which is cost-independent
of the number of mix-servers. This scalable mix-net improves the efficiency compared to already
known constructions, especially with an increasing number of shuffles.
Nevertheless, with perfect anonymity comes the threat of malicious use of the system. Cryptology must consider these possible abuses and we propose the first multi-authority anonymous
credential protocol with traceability property: a user asks a credential issuer for a credential
and uses it to access a system while remaining anonymous. In case of abuse, an authority can
revoke anonymity and trace a malicious user. The scheme is as efficient as the previously known
credential schemes while achieving the multi-credential issuer functionality.

Keywords: Public-Key Cryptography, Homomorphic Protocols, Anonymity, E-voting, Multiparty Computation



iv



Acknowledgments
Lorsque l’on écrit ces lignes, c’est qu’une aventure d’environ 3 ans se termine. On a beau
s’imaginer défendre dès le début de la thèse, lorsque l’on arrive au bout de l’écriture du manuscrit,
une certaine nostalgie est inévitable. J’ai eu la chance de rencontrer de merveilleuses personnes qui ont su me partager avec finesse leurs connaissances, j’ai eu la chance de travailler dans
un cadre bienveillant et chaleureux et finalement j’ai eu la chance de voyager avant que cette
pandémie ne nous frappe. Je tiens donc à remercier du fond du coeur tous ceux que j’ai rencontrés, ceux avec qui j’ai travaillé ou simplement ceux avec qui j’ai pu échanger. Si vous lisez
cette thèse et que je n’ai pas explicitement cité votre nom, veuillez m’en excuser ! Je suis sûre
que vous méritez, vous aussi, des remerciements ne serait-ce que pour avoir lu cette section.
Pour commencer, j’aimerais remercier mes deux directeurs de thèse sans qui tout cela ne
serait jamais arrivé et pour qui j’ai énormément de reconnaissance. Tout à commencé grâce
à Duong Hieu Phan en 2016 par un projet de master suivi par un stage au Vietnam. Cette
première expérience de recherche a été pour moi fantastique, tant humainement que professionnellement. Mon deuxième stage m’a ensuite amené à Paris et m’a permis de rencontrer David
Pointcheval. L’expérience fut positive puisqu’elle s’est transformée en thèse. Je vous remercie
pour les nombreux conseils, le partage de vos connaissances et le temps que vous m’avez consacré
tout au long de mon parcours, votre réactivité pour répondre à mes questions et la clarté de vos
réponses. J’espère sincèrement pouvoir continuer à travailler avec vous.
I sincerely thank Benoît Libert and Dario Catalano for being the rapporteurs of my manuscript.
It is clearly not the easiest part and I hope you enjoyed the reading. Je remercie également Caroline Fontaine et Olivier Sanders pour avoir accepter de prendre part à mon jury.
Je remercie également tous les membres de l’équipe crypto de l’ENS qui sont déjà partis,
qui vont bientôt partir et ceux que je n’ai pas pu d’avantage rencontrer à cause de la pandémie
(par ordre alphabétique, mon tact légendaire m’empêchant de trier par préférence). Merci
donc à Aisling a true tech-woman model, Aurélien pour tes cours d’escalade, Anca pour être
la maman de César dont j’ai temporairement eu la garde, Antoine pour nous avoir entrainés
à survivre à des pandémies lors de soirées jeux . . . avant la pandémie, Azam, Balthazar pour
avoir tenté de ressusciter un cactus mort, Baptiste, Bogdan pour m’avoir montré qu’il était
possible de manger très lentement, Brice, Céline pour avoir co-organisé le Working Group avec
moi, Damien pour avoir partagé ton frigo, Damuhn, Edouard pour tes conseils en restaurant
de burgers, Florian, Geoffroy, Georg, Hoeteck, Hugo, Huy, Jérémy pour nous avoir fait peur en
disparaissant temporairement lors d’un voyage à l’étranger, Julia, Léo, Léonard, Louiza pour
nos longues conversations téléphoniques, Mélissa pour avoir partagé les logements en dur ou
en toile lors des voyages, Michael, Michel pour avoir organisé un immense team building pile à
mon arrivée avec l’organisation d’Eurocrypt, Michele, Michele pour être mon fournisseur officiel
de conseils en cas d’urgence pour de l’informatique pratique, Paola, Pierre-Alain pour avoir
légué un cactus mort à Balthazar, Phong, Pierrick pour être mon fournisseur officiel de plantes
d’aquarium, Pooya pour nos discussions de randonnées, Razvan, Romain pour tes extraits de
vie qui ont animé de nombreuses fois le labo, Théo, Thierry.
Je tiens également à exprimer toute ma reconnaissance à l’équipe administrative du DI,
notamment à Sophie Jaudon, Valérie Mongiat, Linda Boulevart et Lise-Marie Bivard et au SPI,



vi
Ludovic Ricardou et Jacques Beigbeder.
Je souhaite également remercier le service des cartes de l’ENS qui devait beaucoup m’apprécier
pour me faire venir aussi souvent en désactivant mon badge, les différentes générations de machines à café, les nombreuses plantes et les aquariums qui égayaient le labo à une certaine époque,
les cours d’escalade du mardi ou du jeudi midi, les soirées jeux de sociétés ou de Wii. Je souhaite
de tout coeur aux doctorants actuels et futurs de vivre cette expérience de labo pour laquelle
j’ai des souvenirs mémorables.
J’aimerais aussi sincèrement remercier Yannick pour m’avoir accueillie virtuellement, pandémie
oblige, dans son équipe pour un « stage de fin de thèse » ainsi que son équipe chaleureuse. In
particular, I would like to sincerely thank Steve for being a great supervisor and Tim for all
your answers to my practical questions. Je souhaite aussi remercier Mathieu et son équipe pour
m’avoir accueillie dans les virtual but cultural and social events dans la « bonne » time-zone.
Je souhaite aussi remercier les amis de plus longue date qui ont suivi de près ou de loin mon
cheminement jusqu’à cette thèse (par année de rencontre) : Elodie, le Soutien Mental (elles se
reconnaitront), Ghislain et Alexia, Florent, Nicolas, Neals, Charline et Thanh.
Pour finir, cette thèse n’aurait pas pu avoir lieu sans le soutien inconditionnel de ma famille.
Ils supportent mon hypersensibilité au quotidien et ça ne doit pas être évident. En particulier,
je remercie énormément ma soeur, mes parents et bien évidemment Yoan.
Yoan, j’ai essayé mais je n’arrive pas résumer en quelques mots tout ce que tu m’apportes
sans en avoir les larmes aux yeux. Je vais donc être brève mais chargée de sentiments: je T’aime.



Contents
Résumé

i

Abstract

iii

Acknowledgments

v

1 Introduction
1.1 Classical Cryptography . . . . . . . . . . . .
1.1.1 Confidentiality . . . . . . . . . . . . .
1.1.2 Authentication . . . . . . . . . . . . .
1.1.3 Provable Security . . . . . . . . . . . .
1.2 Advanced Security Goals . . . . . . . . . . . .
1.2.1 Decentralization . . . . . . . . . . . .
1.2.2 Anonymity . . . . . . . . . . . . . . .
1.2.3 Traceability . . . . . . . . . . . . . . .
1.3 Homomorphism . . . . . . . . . . . . . . . . .
1.3.1 Homomorphic Encryptions . . . . . .
1.3.2 Homomorphic Signatures . . . . . . .
1.3.3 Security with Homomorphism . . . . .
1.3.4 Homomorphic Zero-Knowledge Proofs
1.4 Contributions . . . . . . . . . . . . . . . . . .
1.5 Organization of the Manuscript . . . . . . . .

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

1
1
2
2
3
3
4
4
5
5
6
6
7
7
7
9

2 Preliminaries
2.1 Notations and Usefull Notions . . .
2.2 Provable Security . . . . . . . . . .
2.3 Computational Assumptions . . . .
2.4 Cryptographic Primitives . . . . .
2.4.1 (Homomorphic) Encryption
2.4.2 (Homomorphic) Signature .
2.4.3 (Homomorphic) Proof . . .

.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.

11
11
13
14
15
15
18
21

3 Decentralized Evaluation of Quadratic Polynomials on Encrypted Data
3.1 Freeman’s Approach . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.1.1 Notations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.1.2 Freeman’s Scheme with Projections . . . . . . . . . . . . . . . . . . . .
3.1.3 Homomorphic Properties . . . . . . . . . . . . . . . . . . . . . . . . .
3.1.4 Security Properties . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.1.5 Re-Encryption . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.1.6 Verifiability . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.1.7 Distributed Decryption . . . . . . . . . . . . . . . . . . . . . . . . . .
3.2 Optimized Version . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.

25
26
26
27
28
30
32
33
37
37

.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.



viii

3.3

3.2.1 Instantiation . . . . . . . . . . . . . . .
3.2.2 Security Properties . . . . . . . . . . . .
3.2.3 Decentralized Homomorphic Encryption
3.2.4 Efficiency . . . . . . . . . . . . . . . . .
Applications . . . . . . . . . . . . . . . . . . . .
3.3.1 Encryption for Boolean Formulae . . . .
3.3.2 Group Testing on Encrypted Data . . .
3.3.3 Consistency Model on Encrypted Data .

4 Linearly-Homomorphic Signatures
4.1 Definition, Properties and Security .
4.2 Our One-Time LH-Sign Scheme . . .
4.3 FSH LH-Sign Scheme . . . . . . . . .
4.4 Square Diffie-Hellman . . . . . . . .
4.5 SqDH LH-Sign Scheme . . . . . . . .
4.5.1 A First Generic Conversion .
4.5.2 A Second Generic Conversion

.
.
.
.
.
.
.

5 MixNet
5.1 Our Scheme: General Description . . .
5.2 Our Scheme: Full Description . . . . .
5.3 Scalability . . . . . . . . . . . . . . . .
5.3.1 Constant-Size Proof . . . . . .
5.3.2 Efficiency . . . . . . . . . . . .
5.4 Security Analysis . . . . . . . . . . . .
5.4.1 Proof of Soundness . . . . . . .
5.4.2 Proof of Privacy: Unlinkability
5.4.3 Proof of Correctness . . . . . .
5.5 Applications . . . . . . . . . . . . . . .
5.5.1 Electronic Voting . . . . . . . .
5.5.2 Message Routing . . . . . . . .

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

37
39
40
43
43
44
44
45

.
.
.
.
.
.
.

47
47
50
51
53
56
56
57
61
62
64
66
67
67
68
68
71
76
78
78
79

.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.

6 Anonymous Credentials
6.1 Overview of our New Primitives . . . . . . . . . . . . . . . . . . . . . . . . . .
6.1.1 Tag-based Signatures . . . . . . . . . . . . . . . . . . . . . . . . . . . .
6.1.2 Signatures with Randomizable Tags . . . . . . . . . . . . . . . . . . .
6.1.3 Aggregate Signatures . . . . . . . . . . . . . . . . . . . . . . . . . . . .
6.2 Aggregate Signatures with Randomizable Tags . . . . . . . . . . . . . . . . .
6.2.1 Anonymous Ephemeral Identities . . . . . . . . . . . . . . . . . . . . .
6.2.2 Aggregate Signatures with Randomizable Tags . . . . . . . . . . . . .
6.2.3 One-Time ART-Sign Scheme with Square Diffie-Hellman Tags (SqDH)
6.2.4 Bounded ART-Sign Scheme with Square Diffie-Hellman Tags (SqDH) .
6.3 Multi-Authority Anonymous Crendentials . . . . . . . . . . . . . . . . . . . .
6.3.1 Definition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
6.3.2 Security Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
6.3.3 Anonymous Credential from EphemerId and ART-Sign Scheme . . . . .
6.4 SqDH-based Anonymous Credentials . . . . . . . . . . . . . . . . . . . . . . .
6.4.1 The Basic SqDH-based Anonymous Credential Scheme . . . . . . . . .
6.4.2 A Compact SqDH-based Anonymous Credential Scheme . . . . . . . .
6.5 Traceable Anonymous Credentials . . . . . . . . . . . . . . . . . . . . . . . .
6.5.1 Traceable Anonymous Credentials . . . . . . . . . . . . . . . . . . . .
6.5.2 Traceable SqDH-based Anonymous Credentials . . . . . . . . . . . . .

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

81
. 82
. 82
. 83
. 84
. 84
. 85
. 85
. 87
. 90
. 92
. 92
. 92
. 94
. 96
. 97
. 98
. 99
. 99
. 100



ix

6.6

6.5.3 Groth-Sahai Proof for Square Diffie-Hellman Tracing . . . . . . . . . . . . 100
Related Work . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 100

7 Conclusion

103

A Joint Generation of Square Diffie-Hellman Tuples

105

B Another Bounded SqDH-Based ART-Sign

107



x



Chapter

1

Introduction

Chapter content
1.1

1.2

1.3

Classical Cryptography . . . . . . . . . . . . . . . . . . . . . . . . . . .

1

1.1.1

Confidentiality . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

2

1.1.2

Authentication . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

2

1.1.3

Provable Security . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

3

Advanced Security Goals . . . . . . . . . . . . . . . . . . . . . . . . . .

3

1.2.1

Decentralization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

4

1.2.2

Anonymity . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

4

1.2.3

Traceability . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

5

Homomorphism . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

5

1.3.1

Homomorphic Encryptions . . . . . . . . . . . . . . . . . . . . . . . . .

6

1.3.2

Homomorphic Signatures . . . . . . . . . . . . . . . . . . . . . . . . . .

6

1.3.3

Security with Homomorphism . . . . . . . . . . . . . . . . . . . . . . . .

7

1.3.4

Homomorphic Zero-Knowledge Proofs . . . . . . . . . . . . . . . . . . .

7

1.4

Contributions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

7

1.5

Organization of the Manuscript . . . . . . . . . . . . . . . . . . . . . .

9

Covid-19. The pandemic spreads across the world and teleworking is currently the norm. We
log in every morning to check our mailbox, we connect to the VPN to work on the intranet, we
save all the files on the cloud and finally, we meet colleagues and family on virtual meetings. We
are more than ever dependent on the Internet and all its features. Even children are attending
classes from home and people living in dead zones suffer the most from this situation. The
Internet is essential and the need to improve privacy is huge in all our uses of electronic devices.
How can we guarantee privacy whereas being connected is more and more essential?
One solution is to study and propose scenarios integrating privacy by design. This thesis explores this field and makes its contribution to cloud computation, electronic voting and
anonymous authentication.

1.1

Classical Cryptography

Cryptography is a very large field but first, let us start with some historical notions that will be
useful for the full understanding of this thesis.



2

1.1.1

1 - Introduction

Confidentiality

Historically, the aim of cryptology was to protect confidentiality of communications. The first
propositions to hide a message were to encrypt it by transforming it in a secret manner in order
to make it incomprehensible. The hidden message can then travel safely to the receiver who
applies at his turn secret transformations to recover the original message. A non-encrypted, and
thus understandable, message is called in clear.
However, Kerckhoff’s principles (1883) [Ker83] state that the security must not rely on secret
transformations but instead, must rely on public transformations (so that the mechanism can
fall in the hands of the adversary) with the use of a key that shall remain secret (must not go
in the hands of the adversary).
To that end, an encryption scheme is defined as the set of three algorithms. The algorithm
EKeygen describes the construction of the key, the algorithm Encrypt details the steps to encrypt.
It outputs a hidden message called ciphertext. Finally, the algorithm Decrypt allows to recover
the original message.
In fact, encryption schemes are divided in two categories depending if the same key is used to
both encrypt and decrypt (symmetric encryption) or if the scheme provides two keys (asymmetric
encryption): a public one to encrypt so that anyone can encrypt a message with it and a secret
one to decrypt so that only the owner of the key can recover the message. This thesis exclusively
focuses on the latter case, also called public-key cryptography as it allows a particular user to
receive messages from several users while being the only one possessing the tool to decrypt them
and thus, being the only one responsible for his security.
Especially, an encryption schemes is said secure if an attacker can not deduce one bit of
information on a clear from its corresponding ciphertext.
The most famous public-key cryptosystem still in use was developed by Rivest, Shamir and
Adleman [RSA78] in 1978. To generate the keys, one needs to choose a large number n product
of two primes p and q and two numbers e and d such that e · d = 1 mod φ(n). The public key is
(n = pq, e) while the secret key is the decomposition (p, q) of n with the private element d. To
encrypt a message m ∈ Z∗p , one computes the ciphertext c = me mod n. Whereas to decrypt,
one recovers the message with cd = (me )d = m1 mod n.

1.1.2

Authentication

How can Bob be sure he is receiving a message from Alice and not from Eve pretending to
be Alice? In our digital world, one needs to be careful about phishing and other attempts of
false impersonations. A way to avoid that is to add an authentication process and to check
the supposed identity of the user. While confidentiality is mainly achieved with encryption,
authentication is mainly achieved thanks to digital signatures.
Similarly to an encryption scheme, a digital signature scheme is made up of three algorithms.
The algorithm SKeygen generates the signing key (must be kept secret) and the verification key
(public). The algorithm Sign creates a signature from a message and the signing key while the
algorithm Verif verifies a signature given a message and a verification key. If this last algorithm
outputs 1, the signature is said valid. We will use these algorithms a lot all along this manuscript,
most of the time enhanced with special properties.
To illustrate, the RSA signature is composed of the algorithm SKeygen using the same
numbers n, p, q, e, d such that n = pq and ed = 1 mod φ(n) as for the RSA algorithm EKeygen
but this time, the signing key is (p, q, d) and the verification key is (n, e). To sign a message
m, one needs to compute σ = H(m)d mod n with H a full domain hash function. Thus, if
we compute σ e , we can verify the signature σ was correct by recovering or not the message as
σ e = (H(m)d )e = H(m)1 mod n.
Classically, a signature scheme is said secure if an attacker cannot forge a new valid signature
even if he previously saw valid ones.



1.2 - Advanced Security Goals

1.1.3

3

Provable Security

The first definition and proof of security dates back to Shannon [Sha49] in 1949. In his article,
he defines the notion of perfect secrecy in the sense of information theory and gives the example
of the One-Time Pad scheme which is perfectly secure. However, this scheme is not convenient
as the size of the key needs to be at least equal to the size of the message.
To avoid this limitation, security proofs are no longer necessarily made in the sense of information theory but are most often reductions of mathematical problems for which the complexity
is widely accepted.
For example, the RSA encryption scheme is based on the factoring problem: given a very
large number product of two prime numbers n = pq, the goal is to find the two prime factors p
and q. The decomposition being part of the secret key of the encryption scheme, breaking the
problem directly breaks the security of RSA.
In this manuscript, we will use two other mathematical problems often used in cryptography
defined on a group G generated by g. The Discrete Logarithm (DL) problem is, given an element
X of G, to find the exponent x such that X = g x . The other is the Computational Diffie-Hellman
(CDH) problem [DH76] (1976): given two elements X = g x and Y = g y of G, the goal is to
compute Z = g xy . For these two problems, the bigger is the number of elements in G, the more
difficult is the problem. The security of cryptographic schemes is thus usually defined with a
security parameter configuring the size of the group. Then, we make the assumption that the
problem is difficult and if attacks are improved or found, it is possible to adapt the level of
security with the security parameter.
A variant of the CDH problem is the Decisional Diffie-Hellman (DDH) problem: given three
elements X = g x , Y = g y and Z of a cyclic group, the goal is this time to decide if Z = g xy or
not. It is at the core of the El Gamal cryptosystem [ElG84] (1984), the second main public-key
encryption scheme that we will use a lot all along this manuscript.

1.2

Advanced Security Goals

The cryptographic world where Alice and Bob are discussing secretly together is not relevant
anymore. We live in a connected world where some scenarios imply to deal with thousands of
users while still achieving some kind of security. There are users and servers, different access
rights for each of them and sometimes there are various authorities at the same time having
different abilities. As the number of persons involved increases and the technologies are improving, more specific definitions of security notions are necessary. In this section, we broach the
advanced and modern thematic to improve the privacy of users by a better control of his data
or guarantees on sensitive systems.
A Multi-User World. Working in a multi-user setting means having to consider different
roles for each user. An honest user follows the protocol, an honest-but-curious user follows the
protocol but tries to retrieve information from the communications he sees passing by and finally
a malicious user tries to actively attack the protocol. If several users try to attack together with
a common goal, we talk about collusion but an attacker can also corrupt others. Some schemes
allow a limited number of collusions/corruptions, i.e. they are proven safe until this threshold
is reached.
Privacy in a World of Information. For the scenarios studied in this manuscript, we will
consider Uma, a user who wants to protect her privacy while wishing to take advantage of the
technological advances of her time. She therefore uses a cloud to store her data but would like
to allow a company to study her records, such as allowing it to do statistical studies of cancers
on her medical record but only if the company is forced by the system to recover only this



4

1 - Introduction

information and nothing more. Uma would also like to vote electronically at the next election
but requests that anonymity is guaranteed as well as the result of the election. Finally, Uma
would like to be able to log in anonymously while being properly authenticated to a system. She
accepts that, in return, if she misuses and abuses the system, her anonymity may be revoked by
a judge.
All of these scenarios require new and more complex security concepts than the one historically used. Cryptology should not be a hindrance to the use of new technological advances.

1.2.1

Decentralization

Decentralized Cryptography is one of the main directions of research in cryptography, especially in a concurrent environment of multi-user applications, where there is no way to trust any
authority. Recently, the rise of blockchain’s applications also showed the importance of decentralized applications. However, the blockchain mainly addresses the decentralized validation of
transactions, but it does not help in decentralizing computations. For the computational purpose, though general solutions can be achieved via multi-party computation, reasonably efficient
solutions only exist for a limited number of protocols, as decentralization usually adds design
constraints to protocols: in broadcast encryption [FN94], the decentralized protocol in [PPS12]
is much less efficient than the underlying original protocol [NNL01]; in attribute-based encryption [SW05], the decentralized scheme [CC09] implies some constraints on the access control
policy, that are removed in [LW11], but at the cost of using bilinear groups of composite order
with 3 prime factors, etc...
In the last decade, the most active research direction was about computing over encrypted
data, with the seminal papers on Fully Homomorphic Encryption (FHE) [Gen09] and on Functional Encryption (FE) [BSW11, GKP+ 13, GGH+ 13]. FE was generalized to the case of multiuser setting via the notion of multi-input/multi-client FE [GGG+ 14, GGJS13, GKL+ 13]. It is
of practical interest to consider the decentralization for FHE and FE without need of trust in
any authority. In FE, the question in the multi-client setting was recently addressed by Chotard
et al. [CDG+ 18a] for the inner product function and then improved in [ABKW19, CDG+ 18b],
where all the clients agree and contribute to generate the functional decryption keys, there is no
need of central authority anymore. Note that, in FE, there are efficient solutions for quadratic
functions [Gay16, BCFG17] but actually, only linear function evaluations can be decentralized
as none of the methods to decentralize linear schemes seems to apply, and no new method has
been proposed so far.

1.2.2

Anonymity

Sometimes confidentiality is not the most desired property for a system as it does not protect
the sender or the receiver. In 1981, Chaum wrote the first article [Cha81] proposing a scheme
able to hide the participants of a communication.
A user is anonymous when his name is either not known or not given. In practice, the
anonymity is defined as the property to not be identifiable within a set. Hence, the anonymity
notion can be obtained throught an unlinkability property. In the next two sections we will see
use-cases of anonymity addressed in this thesis.
Electronic voting
There are mainly three ways to construct electronic voting schemes: from blind signatures, from
additively homomorphic encryption and from shuffles performed by mix-networks. The first
method requires to have interactions during the voting phase: the voter needs to communicate
with an authority so that, she can blindly sign his vote. The second method requires to make a



1.3 - Homomorphism

5

proof at the time of the vote that the ballot is a valid one (e.g. the ballot is the encryption of 0
or 1 but nothing else). The last one is the solution studied in this thesis.
A shuffle of ciphertexts is a set of ciphertexts of the same plaintexts but in a permuted order
such that it is not possible to trace back the senders after decryption. It can be used as a
building block to anonymously send messages: if several servers perform a shuffle successively,
nobody can trace the messages. More precisely, one honest mix-server suffices to mask the order
of the ciphertexts even if all the other ones are dishonest. Moreover increasing the number
of mix-servers leads to a safer protocol but also increases its cost. The succession of shuffles
constitutes the notion of a mix-net protocol introduced by Chaum [Cha81], with applications to
anonymous emails, anonymous routing, but also eletronic voting.
Anonymous authentication
In an anonymous credential scheme, a user asks an organization (a credential issuer) for a
credential on an attribute, so that he can later claim its possession, even multiple times, but in
an anonymous and unlinkable way.
Usually, a credential on one attribute is not enough and the user needs credentials on multiple
attributes. Hence the interest in attribute-based anonymous credential schemes (ABC in short):
depending on the construction, the user receives one credential per attribute or directly for a set
of attributes. One goal is to be able to express relations between attributes (or at least selective
disclosure), with one showing. As attributes may have different meanings (e.g. a university
delivers diploma while a city hall delivers a birth certificat), there should be several credential
issuers. Besides multi credential issuers, it can be useful to have a multi-show credential system
to allow a user to prove an arbitrary number of times one credential still without breaking
anonymity. For that, the showings are required to be unlinkable to each other.

1.2.3

Traceability

Nevertheless, with perfect anonymity comes the threat of malicious use of the system as it is
not possible to identify anyone, even in case of misbehavior. Thus, in tracing scheme, one takes
advantage of computational anonymity to find guilty members who can be at any level: a guilty
sender of an encrypted message, a guilty signer, a guilty verifyer or a guilty authority. Collusions
between users with different parts can also help to combine powers.
Here comes the traitor-tracing schemes [CFN94, CFNP00] with application to group signatures, group encryption [LYJP14], broadcast encryption, inner-product functional encryption [DPP20] or identity-based encryption [BBP19]. When the number of traitors is not bounded,
the scheme is said fully traceable. To identify a culprit, one can add a new authority possessing
a secret or one can request public traceability and in such a case, no secret is needed: everyone
can find a traitor in case of misbehavior.
However, finding a guilty is not enough. When someone is declared guilty one needs to have
guarantees against defamation of users or authorities. In particular, the exculpability property
ensures that no coalition of authorities can convincingly accuse an innocent user in a group
signature scheme. After finding a traitor and having the guarantee of its culpability, one can
eventually revoke him but revokability is usually a more difficult property to achieve. When it is
not possible, a solution is to combine traceability with decentralization. Hence, even a malicious
authority cannot defame a user easily, its ability to judge or revoke being shared among parties.

1.3

Homomorphism

The presented scenarios require to develop new cryptographic tools. Secret sharing techniques
allow decentralization by replacing an authority by a group of members. Indeed, thanks to



6

1 - Introduction

Shamir [Sha79], it is possible to decompose a secret key s in parts so that s = i si , each user
Ui of a group possesses si a fragment of the secret and is not able to decrypt a ciphertext alone.
However, they can decrypt by playing with the other members of the group which implicitly
P
reconstruct the secret s = i si .
All along this manuscript we will use another key ingredient: the homomorphism.
P

1.3.1

Homomorphic Encryptions

For some generic encryption scheme, if we modify a ciphertext it becomes a completely random
string and the content is lost as it is not decryptable anymore even with the secret key. Not
being able to manipulate ciphertexts is called non-malleability. For a long time, this property
ensured the security of encryption schemes: either we know the secret key and we can find the
message again or we do not know it and all the operations we can do will not help.
However, with the RSA encryption scheme, if we multiply two encryptions of m1 and m2
together, we obtain the ciphertext of the message m1 × m2 : if c1 = me1 mod n and c2 = me2
mod n then c1 · c2 = (m1 × m2 )e mod n. A cryptosystem with such property is said to be
multiplicatively homomorphic as one can operate on the clears by multiplication. With the
Paillier cryptosystem [Pai99], if we multiply two encryptions of m1 and m2 together, we obtain
the ciphertext of the message m1 + m2 . This scheme is thus additively homomorphic.
The homomorphism property can be of great interest: if Alice and Bob want to give a common gift to Charlie but none of them want to tell how much he gave. They both encrypt the
amount with an additively homomorphic scheme and can, thanks to the property of homomorphism, multiply their two encryptions together and send the result to Charlie. She will be able
to decrypt it and the message will correspond directly to the sum of the two amounts.
Another common usage of homomorphism with encryption is for refreshing a ciphertext:
by multiplying an encryption of 1 by a ciphertext of m, encrypted with a multiplicatively
homomorphic scheme, one can obtain a new encryption of m thanks to the usage of the neutral
element 1 for the multiplication. The new ciphertext while still encrypting the same message can
be indistinguishable from the original one. A similar relation can be obtained with an encryption
of 0 and an additively homomorphic scheme.
Generically, an encryption scheme in which making an operation on ciphertexts is equivalent
to encrypting the result of a “twin operation” on the clears is called homomorphic. The seminal
paper of Gentry [Gen09] published in 2009 combines for the first time both multiplicative and
additive properties, and thus, allows the evaluatation of any function on ciphertexts. This
scheme is called fully homomorphic encryption (FHE).

1.3.2

Homomorphic Signatures

Similarly to homomorphic encryption, one can define homomorphic signatures. The notion
dates back to Rivest in a series of talks [Riv00] and Johnson et al. [JMSW02], with notions in
[ABC+ 12].
They can help for computations on certified data. For example, Alice has n grades mi
all individualy signed into σi on a remote server. Later, the server is asked to perform an
authenticated computation of a mean of the data. Thus, it computes σ = f (σ1 , . . . , σn ) possible
thanks to homomorphism and M = f (m1 , . . . , mn ) and publishes the result (M, σ). Then,
anyone can check that the server correctly applied f to the data by verifying that σ is a valid
signature.
The linearly-homomorphic signatures, that allow to sign vector sub-spaces, were introduced
in [BFKW09], with several follow-ups by Boneh and Freeman [BF11b, BF11a]. With a linearly
homomorphic signature scheme, from a signature σ1 on the message m1 and σ2 a signature on
the message m2 , it is possible to compute for all α, β, the signature σ = ασ1 + βσ2 , a valid
signature on the message m = αm1 + βm2 .



1.4 - Contributions

7

As for encryption, a signature scheme can also be multiplicatively homomorphic: with the
RSA signature, if we compute σ1 ×σ2 = (m1 ·m2 )d mod n, this is a valid signature of the message
m1 · m2 from two valid signatures σ1 of m1 and σ2 of m2 . Even if this scheme illustrated the
homomorphism, it is, as presented, not secure.

1.3.3

Security with Homomorphism

The security of an homomorphic scheme is different and needs to be strengthen. For example,
an attacker seeing a signature of a message m, could simply forge the signature of m + m, which
would break the basic notion of security. He does not know the keys but he is able to compute
a valid signature of a new message (here m + m).
With the RSA signature scheme above, an attacker can forge any message of his choice: if an
attacker asks the signature σ = (m · re )d mod n, this is a valid signature of the message m · re .
However with that, the attacker can forge the signature σ ∗ = σ/r which is a valid signature of
m while the signer does not know m.
To include the malleability in the security, we will require that it is not possible for an
attacker to provide a signature outside the space generated by the signatures already given. A
similar change in the security definition is of course needed for all the homomorphic schemes
and thus, encryption ones.

1.3.4

Homomorphic Zero-Knowledge Proofs

The last kind of schemes we will intensively use in this thesis is the zero-knowledge proofs. They
were introduced for the first time by Goldwasser, Micali and Rackoff [GMR85] in 1985.
A zero-knowledge proof is a protocol where a prover knowing a witness w makes a proof that
a statement x ∈ L is true to a verifier. The zero-knowledge property implies that the verifier does
not learn more than the fact is true or false and nothing about the witness. In 1986, Goldreich,
Micali and Wigderson [GMW87] shows that any language in NP possess zero-knowledge proofs.
For example, Bob can make a proof of Diffie-Hellman tuple to Alice: Alice thanks to the
proof can verify if the tuple (X = g x , Y = g y , Z) is or not a Diffie-Hellman (if Z = g xy or not)
but she will not learn any of the exponents involved. The language is this case is the set of
Diffie-Hellman tuples and the witness of Bob can be the pair of scalars x and y.
The showing of a proof can be interactive or non-interactive if the verifier after having
received elements from the prover can check the proof latter without any further interaction
with the prover. Moreover, the zero-knowledge proofs is said of statements if it proves a relation
(as a proof of Diffie-Hellman tuple), or of knowledge if it proves the knowledge of a witness:
when Bob wants to authenticate himself to a system, he needs to show he knows the password.
A non-interactive zero-knowledge proof of knowledge is also called signature of knowledge.
With the Groth-Sahai [GS08] scheme, it is possible to combine together different proofs into
a unique one. This property can be viewed as an homomorphic property: the combinations of
the proofs creates a proof of a relation of statements.
In this thesis, zero-knowledge proofs will be used sometimes enhanced of the homomorphic
property to prove that a ciphertext is correctly construted or for authentication.

1.4

Contributions

This thesis studies the usage of the homomorphic property in concrete multi-users protocols
requiring not only confidentiality but also anonymity, authentication or verifiability. Homomorphic encryption schemes, homomorphic digital signatures and homomorphic zero-knowledge
proofs will be used together to create new protocols, but, each time, restrictions will be applied
to limit the possible malleability.



8

1 - Introduction

The results presented in this manuscript come from two published papers (co-authored with
Duong Hieu Phan and David Pointcheval) and one paper still in reviewing process (co-authored
with David Pointcheval).
First, we will present a decentralized encryption scheme that allows the controlled evaluation
of quadratic polynomials on outsourced data. Then, we will describe a new method to build mixnetworks from linearly homomorphic signatures allowing a verification which is cost-independent
of the number of servers. Finally, we will detail a new traceable multi-authority anonymous
credential protocol. After defining the security, the schemes are proved to achieve the desired
level of security. Below, we detail the contributions.
Decentralized Evaluation of Quadratic Polynomials on Encrypted Data [HPP19].
In this paper, we revisit the Boneh-Goh-Nissim (BGN) [BGN05] cryptosystem, and the
Freeman’s variant [Fre10], that allow evaluation of quadratic polynomials, or any 2-DNF
formula. Whereas the BGN scheme relies on integer factoring for the trapdoor in the
composite-order group, and thus possesses only one pair of public/secret keys, the Freeman’s scheme can handle multiple users with one general setup that just needs a pairingbased algebraic structure to be defined. We show that it can be efficiently decentralized,
with an efficient distributed key generation algorithm, without any trusted dealer, but also
efficient distributed decryption and distributed re-encryption, in a threshold setting.
To motivate our work, we focus on some real-life applications of computations on encrypted
data, without central authority which only require evaluations of quadratic polynomials
so that specific target users can get the result in clear, by running re-encryption in a
distributed manner under the keys of the target users.
This paper has been published in the proceedings of the conference ISC in 2019.
Linearly-Homomorphic Signatures and Scalable Mix-Nets [HPP20].
In this article, we propose a new approach for proving correct shuffling of signed ElGamal
ciphertexts: the mix-servers can simply randomize individual ballots, namely the ciphertexts, the signatures, and the verification keys, with an additional global proof of constant
size. This technique can be seen as an improvement of signatures on randomizable ciphertexts [BFPV11] which however does not allow updates of the verification keys. This
previous approach excluded anonymity because of the invariant verification keys.
The computational complexity for each mix-server is linear in the number of ballots and
the overhead after each shuffle can be updated to keep it constant-size. Thus, the final
proof implies just a constant-size overhead and the verification is also linear in the number
of ballots, but independent of the number of rounds of mixing. This leads to a new highly
scalable technique.
Our construction relies on Groth-Sahai proofs with pairings [GS08] and a new computational assumption that holds in the generic bilinear group model. We avoid the proof
of an explicit permutation on all the ciphertexts (per mixing step) but the appropriate
properties of the Mix-Nets are deeply guaranteed using linearly-homomorphic signature
schemes with new features, that are of independent interest.
This paper has been published in the proceedings of the conference PKC in 2020.
Traceable Multi-Authority Anonymous Credentials [HP20].
Following the path of aggregate signatures [CL11], our first contribution is the formalization of an aggregate signature scheme with randomizable tags (ART-Sign) for which
we propose a practical construction. With such a primitive, two signatures of different
messages under different keys can be aggregated only if they are associated to the same
tag. In our case, tags will eventually be like pseudonyms, but with some properties which



1.5 - Organization of the Manuscript

9

make them ephemeral (hence EphemerId scheme) and randomizable, even when they are
associated to the same user.
However our goal is to obtain a compact ABC system, which is our second contribution:
the EphemerId scheme generates keys for users, they will use for authentication. Public keys
being randomizable, multiple authentications using the same key will remain unlinkable.
In addition, these public keys will be used as (randomizable) tags with the above ARTSign scheme when the credential issuer signs an attribute. Thanks to aggregation, multiple
credentials for different attributes and from several credential issuers but under the same
tag, and thus the same user, can be combined into a unique compact (constant-size)
credential.
About security, whereas there exists a scheme proven in the universal composability (UC)
framework [CDHK15], for our constructions we consider a game-based security model for
ABC inspired from [FHS19]. As we support different credential issuers, we additionally
consider malicious credential issuers, with adaptive corruptions, and collusion with malicious users. However, the keys need to be honestly generated, thus our proofs hold in the
certified key setting. As for all the recent ABC schemes, our constructions will rely on
signature schemes proven in the bilinear generic group model.
Our last contribution is traceability, in the same vein as group signatures: whereas showings are anonymous, a tracing authority owns tracing keys, and thus is able to link a
credential to its owner. In such a case, we also consider malicious tracing authorities, with
the non-frameability guarantee. Because the previous constructions ([CL13], [Ver17]) are
broken, our scheme is the first traceable attribute-based anonymous credential scheme.

1.5

Organization of the Manuscript

This thesis is organized into seven chapters as follows:
Chapter 1 is the present introduction.
Chapter 2 is a preliminary chapter introducing the notations used in the manuscript. It also
provides some definitions and some general notions and presents already existing cryptographic primitives used in the next chapters. In particular, it describes the homomorphic
properties we will use a lot.
Chapter 3 presents our decentralized encryption scheme to evaluate quadratic polynomials on
encrypted data. It is based on the paper [HPP19].
Chapter 4 is an introduction to linearly homomorphic signatures. In particular, we present
two constructions: the first one is a modified already existing one used in our mix-net and
the second one is new and used in our anonymous credential scheme. This chapter can be
read independently of the previous one.
Chapter 5 presents our scalable mix-net. It is based on the paper [HPP20]. This chapter
depends on the previous one.
Chapter 6 presents our anonymous credential scheme. It is based on the paper [HP20]. This
chapter depends on the chapter 4.
Chapter 7 concludes this manuscript and expands the scope of the field with open questions.



10

1 - Introduction



Chapter

2

Preliminaries

Chapter content
2.1

Notations and Usefull Notions

. . . . . . . . . . . . . . . . . . . . . .

11

2.2

Provable Security . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

13

2.3

Computational Assumptions . . . . . . . . . . . . . . . . . . . . . . . .

14

2.4

Cryptographic Primitives

15

. . . . . . . . . . . . . . . . . . . . . . . . .

2.4.1

(Homomorphic) Encryption . . . . . . . . . . . . . . . . . . . . . . . . .

15

2.4.2

(Homomorphic) Signature . . . . . . . . . . . . . . . . . . . . . . . . . .

18

2.4.3

(Homomorphic) Proof . . . . . . . . . . . . . . . . . . . . . . . . . . . .

21

This preliminary chapter aims to fix the notations and to recall the basic notions we will use
throughout this thesis. In particular, we recall the homomorphic primitives we will manipulate
to provide concrete constructions in the following chapters.

2.1

Notations and Usefull Notions

Sets. The set of all bit strings is denoted by {0, 1}∗ , while the set of bit strings of length n ∈ N
is {0, 1}n . If x ∈ {0, 1}∗ , its bit-length is denoted |x|. If S is a finite set, we denote by |S| the
$
number of elements in S and by s ←
S the process of selecting s uniformly at random in the
set S.
Groups, Fields. We obtain a group by adding to a set a binary operation with good properties.
Usually in this thesis, groups will be finite of order p a prime number and denoted with the
multiplicative notation. Because a group of prime order is cyclic, an element of (G, ·) can be
seen as an element of {1, g, . . . , g p−1 } and we will use the abusive notation G = g to denote
such a group with generator g. Moreover, we assume given g ∈ G and x ∈ Zp , one can efficiently
compute g x . In other words, the multiplication over G is an efficient operation.
We denote the set of integers by Z and the set of non-negative ones by N. For a positive
integer n and an integer x ∈ Z, the reduction of x modulo n, denoted x mod n, is the remainder
of the Euclidean division of x by n. We denote by (Zn , +) the additive group of integers modulo
n and by (Zn , +, ·) the ring of integers modulo n. Again, p is a prime number in this thesis and,
we denote by Z∗p = Zp \{0} the group of units of Zp as Zp becomes a field in that case.
Vectors, Matrices. The vectors x = (xi )i and matrices M = (mi,j )ij are in bold and the
vectors are written as row vectors, with sometimes components separated by commas for clarity:
$
if x ←
X n , x = (x1 x2 · · · xn ) = (x1 , x2 , · · · , xn ).
We denote by Mm,n (Zp ) the set of matrices on Zp , of size m × n, and thus m row-vectors
of length n. (Mm,n (Zp ), +) is an Abelian group. When A ∈ Mm,n (Zp ) and B ∈ Mn,n0 (Zp ),
the matrix product is denoted A × B ∈ Mm,n0 (Zp ), or just AB if there is no ambiguity.
(Mn,n (Zp ), +, ×) is a ring, and we denote by GLn (Zp ) ⊂ Mn,n (Zp ) = Mn (Zp ) the subset of the



12

2 - Preliminaries

invertible matrices of size n (for the above matrix product ×), which is also called the general
linear group.
We will use the tensor product: for two vectors a = (a1 , a2 , · · · , an ) ∈ Znp and b =
(b1 , b2 , · · · , bm ) ∈ Zm
p , the tensor product a ⊗ b is the vector (a1 b, · · · , an b) = (a1 b1 , · · · , a1 bm ,
a2 b1 , · · · , a2 bm , · · · , an bm ) ∈ Zmn
p ; and for two matrices A ∈ Mm,n (Zp ) and B ∈ Mm0 ,n0 (Zp ),



a1





b1





B =  ... 

 
A =  ... 

bm0

am




A⊗B=



a1 ⊗ b1
a1 ⊗ b2
..
.

am ⊗ bm0




 ∈ Mmm0 ,nn0 (Zp ).



The bilinearity of the tensor product gives:
for A, A0 ∈ Mm,n (Zp ) and B, B0 ∈ Mm0 ,n0 (Zp ),
(A + A0 ) ⊗ (B + B0 ) = (A ⊗ B) + (A ⊗ B0 ) + (A ⊗ B0 ) + (A0 ⊗ B0 )
We will also use the following important relation between matrix product and tensor product:
for A ∈ Mm,k (Zp ), A0 ∈ Mk,n (Zp ), B ∈ Mm0 ,k0 (Zp ), and B0 ∈ Mk0 ,n0 (Zp ),
(A × A0 ) ⊗ (B × B0 ) = (A ⊗ B) × (A0 ⊗ B0 ).
Projections. In order to continue with matrix properties and linear applications, a projection
π in a space of dimension n is a linear function such that π ◦ π = π. Any projection of rank 1
can be represented by the matrix P = B−1 Un B, where Un is the canonical projection and B is
the change of basis matrix:
0 ... 0 0
..


.


Un = 

0 . . . 0 0
0 ... 0 1








p1
 . 
 .. 



B=


pn−1 

b

where K = p1 , . . . , pn−1 is the kernel of the projection and b the image.
Given two projections π1 and π2 of rank 1, that are represented by P1 = B−1
1 Un B1 and
−1
P2 = B2 Un B2 , respectively, the tensor product π = π1 ⊗ π2 is represented by P = P1 ⊗ P2 ,
that is equal to
−1
−1
−1
(B−1
1 Un B1 ) ⊗ (B2 Un B2 ) = (B1 ⊗ B2 ) × (Un ⊗ Un ) × (B1 ⊗ B2 )

= (B1 ⊗ B2 )−1 × Un2 × (B1 ⊗ B2 ).
The associated change of basis matrix is thus B = B1 ⊗ B2 . In dimension 2:


B1 =

p1
b1

!

!

and B2 =

p2
,
b2



p1 ⊗ p2
p ⊗ b 

2
then B = B1 ⊗ B2 =  1
,
b1 ⊗ p2 
b1 ⊗ b2

hence, the image of π = π1 ⊗ π2 is spanned by b = b1 ⊗ b2 , while {p1 ⊗ p2 , p1 ⊗ b2 , b1 ⊗ p2 }
$
is a basis of the kernel. But, as explained below, p1 ⊗ r2 + r1 ⊗ p2 , for r1 , r2 ←
Z2p , provides a
uniform sampling in ker(π):
ker(π) = {(x1 + x2 ) · p1 ⊗ p2 + y2 · p1 ⊗ b2 + y1 · b1 ⊗ p2 , x1 , x2 , y1 , y2 ∈ Zp }
= {p1 ⊗ (x2 · p2 + y2 · b2 ) + (x1 · p1 + y1 · b1 ) ⊗ p2 , x1 , x2 , y1 , y2 ∈ Zp }.



2.2 - Provable Security

13

Cryptographic Notations. All along this manuscript, κ will be the security parameter. In
all the public-key cryptographic primitives, keys will implicitly include the global parameters
and secret keys will include the public keys.
Bilinear Group Setting. A bilinear group generator G is an algorithm that takes a security
parameter κ as input, and outputs a tuple (G1 , G2 , GT , p, g, g, e) such that G1 = g and G2 = g
are cyclic groups of prime order p (a κ-bit prime integer), and e : G1 × G2 → GT is an admissible
pairing:
• e is bilinear: for all a, b ∈ Zp , e(g a , gb ) = e(g, g)ab ;
• e is efficiently computable (in polynomial-time in κ);
• e is non-degenerated: e(g, g) 6= 1.
Furthermore, the bilinear setting (G1 , G2 , GT , p, g, g, e) is said symmetric when G1 = G2 and
asymmetric when G1 6= G2 and of
• Type 1: if there exist two efficiently computable isomorphisms from G1 to G2 and conversely from G2 to G1 ;
• Type 2: if there only exists an efficiently computable isomorphism from G2 to G1 ;
• Type 3: if there is no efficiently computable isomorphism between G1 and G2 .
In this thesis, we will only use asymmetric pairing of type 3 and denote in Fraktur font
elements of G2 for the sake of clarity.

2.2

Provable Security

Correctly evaluate the security of a system is challenging and fundamental. Especially because
it is always possible to attack a system: it suffices to try all the possible secrets until finding
the correct one. This method is called the brute-force attack. However, it takes time and
sometimes more efficient attacks can be found. Moreover knowing precisely the powers of an
attacker is often impossible: what does he intend to do, how much power or how long does he
have? Therefore, the goal becomes to modelize the interactions between some adversary and
the system so that a real attacker would have less power than the idealized/considered one.
This is usually achieved by upper bounding the data he has access to and formalized by an
experiment representing the desired security as a game between an attacker and an implicit
challenger playing as wanted by the system.
With the current computational power available, one considers an attack to be infeasible
if it requires 2128 computational steps to break the system and one says that a cryptosystem
provides κ bits of security if it requires 2κ elementary operations to be broken. Hence, the goal
becomes to prove that the attacker winning the experiment has to perform at least this number
of operations.
After having defined the attacker and the security model we want to achieve, the proof
usually consists in hybrid games where the first one corresponds to the interactions between the
attacker and the system and each step of the proof shows that this intermediate experiment is
equivalent to the next one until the final experiment corresponds to the desired security or a
difficult mathematical problem. Usually at the end, one can tell if the attacker can break the
system if he is also able to break this well-known hard problem.
For that, it can be easier to make proofs in the Random Oracle Model (ROM) [BR93] in
which hash functions used in a scheme are considered as an ideal random oracle. Hence, the
randomness is considered as perfect.



14

2 - Preliminaries

Another possible model to help in the study of the security is the Generic Group Model
(GGM) [Sho97]: if the attacker has access to group elements, then he can just make linear
combinations of them and nothing else. For example, if the attacker knows A and B such that
A = g a and B = g b then the attacker can obtain C = g αa+βb for any α and β but cannot have
D = g d with d not in relation with a and b. In fact, this corresponds to an idealization of the
group structure as the attacker can not exploit any special structure of the representation of the
group elements. Similarly, the Generic Bilinear Group Model (GBGM) adds the idealization of
the pairing operation.
Finally, security proofs in the Common Reference String Model [Dam00] assume that a string
crs, known by all the participants before the begining of the scheme, exists and was honestly
generated.
Of course, the best model is the Standard Model where no idealization of the system is made
but difficult to achieve.

2.3

Computational Assumptions

As introduced in the previous chapter, in an asymmetric bilinear setting (G1 , G2 , GT , p, g, g, e),
or just in a simple group G, we can make assumptions that will help in the establishment of the
security proofs of the cryptographic schemes.
The most famous one is the Discrete Logarithm (DL) Assumption:
Definition 1 — Discrete Logarithm (DL) Assumption
In a group G of prime order p, it states that for any generator g, given y = g x , it is
computationally hard to recover x.
There exists a variant of the DL assumption when having two groups G1 , G2 :
Definition 2 — Symmetric External Discrete Logarithm (SEDL) Assumption
In groups G1 and G2 of prime order p, it states that for any generators g and g of G1 and
G2 respectively, given f = g x and f = gx , it is computationally hard to recover x.
The second most famous assumption is the Decisional Diffie-Hellman (DDH) assumption:
Definition 3 — Decisional Diffie-Hellman (DDH) Assumption
In a group G of prime order p, it states that for any generator g, the two following
distributions are computationally indistinguishable:
$
$
Ddh (g) = {(g, g x , h, hx ); h ←
G, x, ←
Zp }
$
$
D$4 (g) = {(g, g x , h, hy ); h ←
G, x, y, ←
Zp }.

More precisely, the advantage Advddh
G (A) of an adversary A against the Decisional DiffieHellman (DDH) problem in G is defined by:
h

i

h

i

$
$
Pr A(g, g x , g y , g xy ) = 1|x, y ←
Zp − Pr A(g, g x , g y , g z ) = 1|x, y, z ←
Zp .

The DDH problem in G is said (t, ε)-hard if for any advantage A running within time t, its
ddh
advantage Advddh
G (A) is bounded by ε. We also denote by AdvG (t) the best advantage any
adversary can get within time t.
It is well-known, using an hybrid argument, or the random-self-reducibility, that the DDH
assumption implies the Decisional Multi Diffie-Hellman (DMDH) assumption:



2.4 - Cryptographic Primitives

15

Definition 4 — Decisional Multi Diffie-Hellman (DMDH) Assumption
In a group G of prime order p, it states that for any generator g and for any constant
n ∈ N, the two following distributions are computationally indistinguishable:
$
$
n
Znp }
Dmdh
(g) = {(g, (g xi )i , h, (hxi )i ); h ←
G, (xi )i ←
$
$
Znp }.
D$2n+2 (g) = {(g, (g xi )i , h, (hyi )i ); h ←
G, (xi )i , (yi )i ←

2.4

Cryptographic Primitives

In this section we introduce the homomorphic blocks at the core of this thesis. Each time the
primitive will be presented in its simplest form with its corresponding security definition and,
after that, homomorphic properties will be utilized to enhance it. Hence, the notations will be
fixed and already existing constructions given.
The first part focuses on the definition of an encryption scheme then, the second one describes
a signature scheme and the last one concerns zero-knowledge proofs.

2.4.1

(Homomorphic) Encryption

We begin with the most famous crytographic primitive: encryption. In this thesis we only use
Public-Key Encryption schemes:
Definition 5 — Public-Key Encryption Scheme
A public-key encryption scheme consists of the following algorithms:
EKeygen(κ): Given a security parameter κ, it outputs the public key pk with the associated
private key sk;
Encrypt(pk, m): Given a message m and a public key pk, it outputs the ciphertext C;
Decrypt(sk, C): Given a ciphertext C and a secret key sk, it outputs a message m.
A user with the pair (sk, pk) of secret-public keys can publish pk to everyone likely to send
him a message. However, sk needs to be stored in a safe place.
A public-key encryption scheme if said correct is for all message m and (sk, pk) ← EKeygen(κ),
Decrypt(sk, Encrypt(pk, m)) = m.
Example 6 (El Gamal Cryptosystem). To illustrate, the El Gamal encryption scheme (1984) is
composed of the three algorithms (EKeygen, Encrypt, Decrypt) defined on a cyclic group G = g
of prime order p with:
El Gamal Encryption Scheme [ElG84]
$
EKeygen(κ): Given a security parameter κ, it chooses x ←
Zp and outputs the public key
pk = g −x and the private key sk = x.
$
Encrypt(pk, m): To encrypt a message M ∈ G using public key pk, it chooses r ←
Zp and
outputs the ciphertext C = (M · pkr , g r ) ∈ G2 .

Decrypt(sk, C): Given C = (c1 , c2 ) and the private key sk, it computes c1 · csk
2 .
r
r sk
−skr+rsk = M .
The scheme is correct as c1 · csk
2 = M · pk · (g ) = M · g



16

2 - Preliminaries

Security. The security of a public encryption scheme can be defined by different levels (from
the weakest to the strongest):
IND-CPA: the older is the semantic security, a.k.a. Indistinguishability Under Chosen-Plaintext
Attacks. Informally, it means that an attacker can not find which message is encrypted
after receiving a ciphertext of one of the two messages of its choice;
IND-CCA: the Indistinguishability Under adaptive Chosen-Ciphertext Attacks is similar to the
previous scenario except that the attacker has access to an oracle answering the decryption
of encrypted messages. The only restriction is that the attacker can not request the
decryption of the challenge ciphertext.
IND-CCA ⇒ IND-CPA
Let us now formally define the semantic security for a public-key encryption scheme. The
attack is done in two steps, and so the adversary outputs a state s to resume the process in the
second step:
Definition 7 — IND-CPA
Let E = (EKeygen, Encrypt, Decrypt) be an encryption scheme.
Expind-cpa-b
(A) the experiment defined by:
E

Let us denote

Expind-cpa-b
(A):
E
(sk, pk) ← EKeygen(κ)
(s, m0 , m1 ) ← A(pk)
C ← Encrypt(pk, mb )
b0 ← A(s, C)
return b0
(A) of an adversary A against indistinguishability under chosen
The advantage Advind-cpa
E
plaintext attacks (IND-CPA) is
Pr[ExpEind-cpa-1 (A) = 1] − Pr[ExpEind-cpa-0 (A) = 1].
An encryption scheme E is said (t, ε) − IND-CPA if for any adversary A running within
time t, its advantage Advind-cpa
(A) is bounded by ε and we denote by AdvEind-cpa (t) the best
E
advantage any adversary A can get within time t.
For example, the El Gamal cryptosystem is IND-CPA secure under the DDH assumption.
Homomorphic Encryption Scheme
An encryption scheme is said partially homomorphic or homomorphic within a group (G, ?) if
one can define an additional algorithm taking as input two ciphertexts C on implicit message
m and C 0 on implicit message m0 and producing a ciphertext C 00 on the message m ? m0 . For
a multiplicative group (G, ·), this algorithm is usually denoted Multiply(C, C 0 ) whereas for an
additive group (G, +), it is denoted Add(C, C 0 ).
If the scheme is at the same time additively (meaning having an Add algorithm as defined
above) and multiplicatively (meaning having an Multiply algorithm as defined above) homomorphic then, one can evaluate any function on ciphertexts and the scheme is said fully homomorphic.
Example 8 (El Gamal Cryptosystem). The El Gamal encryption scheme as presented in Example 6 is homomorphic in (G, ·) as one can define an algorithm Multiply:



2.4 - Cryptographic Primitives

17

Multiply(C, C 0 ): Given two El Gamal ciphertexts C = (c1 , c2 ) and C 0 = (c01 , c02 ), it outputs
C 00 = (c1 · c01 , c2 · c02 ).
This works as:
0

0

0

0

C 00 = ((M · pkr ) · (M 0 · pkr ), g r · g r ) = ((M · M 0 ) · pkr+r , g r+r ) = Encrypt(pk, M · M 0 ).
However, by changing the message space from G to Zp and by defining the encryption of
m ∈ Zp by Encrypt(pk, m) = (g m · pkr , g r ). The scheme becomes homomorphic in (Zp , +):
Add(C, C 0 ): Given two El Gamal ciphertexts C = (c1 , c2 ) and C 0 = (c01 , c02 ), it outputs
C 00 = (c1 · c01 , c2 · c02 ).
We will often use this El Gamal version in this manuscript.
Security. An homomorphic encryption scheme can be IND-CPA secure however, IND-CCA2
can not be achieved. Indeed, the attacker chooses two messages m0 , m1 and sends them to the
$
challenger, the challenger chooses b ←
{0, 1} and encrypts mb into Cb . The attacker receiving
Cb simply computes C = Cb × Cb and asks the decryption to obtain m = 2 · mb . Finding the
right b0 = b is then easy.
Freeman Cryptosystem.
To evaluate 2-DNF formulae on encrypted data, Boneh-Goh-Nissim described a cryptosystem [BGN05] in 2005 that supports additions, one multiplication layer, and additions again.
They used a bilinear map on a composite-order group and the secret key is the factorization of
the order of the group. Unfortunately, composite-order groups require huge orders, since the
factorization must be difficult, with costly pairing evaluations.
In order to improve the efficiency on this cryptosystem, Freeman in [Fre10] proposed a system
on prime-order groups, using a similar property of noise that can be removed, with the general
definition of subgroup decision problem:
Freeman’s Cryptosystem [Fre10]
EKeygen(κ): Given a security parameter κ, it generates (G, H, GT , p, g, h, e) ← G(κ), two
subgroups G1 ⊂ G, H1 ⊂ H and three homomorphisms π1 , π2 , πT such that G1 , H1
are contained in the kernels of π1 , π2 respectively and e(π1 (g), π2 (h)) = πT (e(g, h)).
Finally, it outputs the public key pk = (G, G1 , H, H1 , GT , e, g, h) and the private key
sk = (π1 , π2 , πT );
$
Encrypt(pk, m): To encrypt a message m using public key pk, one picks g1 ←
G1 and
$
m
m
h1 ← H1 , and outputs the ciphertext (CA , CB ) = (g · g1 , h · h1 ) ∈ G × H;

Decrypt(sk, C): Given C ∈ G (resp. ∈ H or ∈ GT ), it outputs m ← logπ1 (g) (π1 (C)) (resp.
logπ2 (h) (π2 (C)) or logπT (e(g,h)) (πT (C))).
Freeman’s scheme also has homomorphic properties:
Add(C, C 0 ): Given two ciphertexts C and C 0 of G (resp. of H or of GT ), it chooses g1 ∈ G1
and h1 ∈ H1 and outputs the ciphertext C 00 = C · C 0 · g1 (resp. C 00 = C · C 0 · h1 or
C 00 = C · C 0 · e(g1 , h) · e(g, h1 ));



18

2 - Preliminaries
Multiply(C, C 0 ): Given a ciphertext C ∈ G and C 0 ∈ H, it outputs the ciphertext C 00 =
e(C, C 0 ) · e(g1 , h) · e(g, h1 ).

This scheme is secure under the subgroup decision problem which informally means that an
attacker can not distinguish elements of the subgroup G1 ⊂ G from elements of G and as well
as elements of the subgroup H1 ⊂ H from elements of H.

2.4.2

(Homomorphic) Signature

After having described the encryption schemes with their homomorphic variant, we will now
present the signature schemes following the same structure. First, we provide the general definition with an example and the security requirement. Then, we extend the signature schemes
to their homomorphic version.
In their seminal article [DH76], Diffie and Hellman described a digital signature scheme
as a “digital phenomenon with the same properties as a written signature. It must be easy
for anyone to recognize the signature as authentic, but impossible for anyone other than the
legitimate signer to produce it”:
Definition 9 — Digital Signature Scheme
A signature scheme consists of the following algorithms:
SKeygen(κ): Given a security parameter κ, it outputs the (public) verification key vk with
the associated (private) signing key sk;
Sign(sk, m): Given a signing key and a message m, it outputs the signature σ;
VerifSign(vk, m, σ): Given a verification key vk, a message m and a signature σ, it outputs
1 if σ is a valid signature relative to vk, and 0 otherwise.
A signature scheme is said correct is for all message m and for all (sk, vk) ← SKeygen(κ),
VerifSign(vk, m, Sign(sk, m)) = 1.
Example 10 (Schnorr Signature Scheme). Let G = g be a cyclic group of prime order p and
H : {0, 1}∗ × G → Zp be a hash function. The Schnorr signature scheme (1989) is composed of
the three algorithms (SKeygen, Sign, VerifSign) with:
Schnorr Signature Scheme [Sch90]
$
SKeygen(κ): Given a security parameter κ, it outputs the signing key sk = x ←
Z∗p and
the verification key vk = g x ;
$
Sign(sk, m): Given a signing key sk and a message m ∈ {0, 1}∗ , it chooses a ←
Zp and
a
computes r = g , c = H(m, r) and s = a + cx mod p. The signature is then
σ = (s, c);

VerifSign(vk, m, σ): Given a verification key vk, a message m and a signature σ = (s, c),
it computes r = g s · vk−c and outputs 1 if c = H(m, r), and 0 otherwise.
The scheme is correct as H(m, r) = H(m, g s · vk−c ) = H(m, g s−xc ) = H(m, g a ).
Security. The security of a signature scheme was defined for the first time by Goldwasser et
al. [GMR88] and is called the unforgeability. As for encryption, one can distinguished different
levels of attackers (from the weakest scheme to the safest):



2.4 - Cryptographic Primitives

19

EUF: a scheme is said to be Existentially Unforgeable (EUF) if an attacker can not succeed in
forging the signature of one message, even not of his choice;
SUF: a scheme is said to be Strong Unforgeable (SUF) if an attacker can not succeed in forging
the signature of one message, even not of his choice;
Let us now formally define the universal unforgeability for a signature scheme:
Definition 11 — EUF-CMA
Let Σ = (SKeygen, Sign, VerifSign) be a signature scheme and A an attacker against it
having access to the signing oracle Sign(sk, ·). Let us denote Expeuf-cma (1κ ) the experiment
defined by:
Expeuf-cma (1κ ):
(sk, vk) ← SKeygen(κ)
(m∗ , σ ∗ ) ← ASign(sk,·) (vk)
return m∗ “new” ∧ VerifSign(vk, m∗ , σ ∗ )
The advantage Adveuf-cma (A) of an adversary A against existential unforgeability under
chosen-message attacks is Adveuf-cma (A) = | Pr[Expeuf-cma (1κ ) = 1]|. A signature scheme
Σ is said t−EUF-CMA secure if for any adversary A running in time t polynomial in κ and
making a number of signing queries also polynomial in κ, its advantage Adveuf-cma E(A) is
negligible.
By replacing m∗ “new” by (m∗ , σ ∗ ) “new” in the definition above, we obtain the formal
definition of the Strong Unforgeability.
Homomorphic Signature Schemes
In this part, we will provide the informal notions of the homomorphic signature schemes as a
more detailed presentation of the specific linearly homomorphic signatures will be done in the
Chapter 4. The concept dates back to Desmedt [Des93] in 1993.
Similarly to encryption, a signature scheme is said homomorphic in (G, ·) if one can define
an additional algorithm:
MultiplySign(vk, (ωi , mi , σi )`i=1 ): Given a public key vk and ` tuples of weights ωi and
Q
signed messages mi in σi , it outputs a signature σ on the message m = `i=1 mωi i .
Example 12 (Libert et al. [LPJY13] Signature Scheme). In their article, Libert et al. [LPJY13]
introduce a new signature scheme proven in the standard model with messages in M ∈ Gn , for
a cyclic group (G, ×) of prime order p and some n ∈ poly(κ):
One-Time Linearly Homomorphic Signature Scheme [LPJY13]
SKeygen(κ, n): Given a security parameter κ and the dimension n, it generates
(G, GT , p, g, e) ← G(κ) a symmetric bilinear setting of prime order p. Then, it
$
$
choses generators h, gz , gr , hz ←
G. For i = 1 to n, it picks χi , γi , δi ←
Zp and
χ
γ
χ
δ
n
computes gi = gz i gr i , hi = hz i h i . The signing key is sk = {χi , γi , δi }i=1 and the
verification key is vk = (gz , hr , hz , h, {gi , hi }ni=1 );
Sign(sk, M ): Given a signing key sk = {χi , γi , δi }ni=1 and a vector-message M = (Mi )i ∈



20

2 - Preliminaries
Gn , it outputs the signature σ = (z, r, u) with
z=

n
Y

Mi−χi ,

i=1

r=

n
Y

Mi−γi ,

u=

i=1

n
Y

Mi−δi ;

i=1

VerifSign(vk, M , σ): Given a verification key vk, a vector-message M = (Mi )i and a
signature σ, it outputs 1 if M 6= 1GnT and σ = (z, r, u) satisfies
1GT = e(gz , z) · e(gr , r) ·

n
Y

e(gi , Mi ),

1GT = e(hz , z) · e(h, u) ·

i=1

n
Y

e(hi , Mi ).

i=1

Their scheme was inspired by the one-time structure-preserving signature of Abe et al.[AFG+ 10]
and is multiplicatively homomorphic as one can define a MultiplySign algorithm:
MultiplySign(vk, (ωi , M i , σi )`i=1 ): Given a public key vk and ` tuples of weights ωi ∈ Zp and
signed messages M i in σi = (zi , ri , ui ), it outputs the signature σ = (z, r, u) with:
z=

`
Y
ziωi ,
i=1

r=

`
Y
riωi ,
i=1

u=

`
Y
uωi i ;
i=1

The output of this algorithm is a valid signature on the vector M = `i=1 M ωi i . In fact, as for
El Gamal, the signature scheme can be seen as a linearly homomorphic one as the message can
be m = (m1 , . . . , mn ) ∈ Znp such that M = (g m1 , . . . , g mn ).
Q

Security. Similarly to homomorphic encryption, the security of homomorphic signatures needs
to be specified. Indeed, if one can evaluate any function of previously seen signatures of messages,
an attacker can forged any message of his choice. Informally, the security will require that an
attacker can not forge a message outside an authorized space.
For example, the Libert et al. scheme defined above considers that a signature σ = σ1α · σ2β is
not a forgery if the attacker previously asked for the signatures σ1 and σ2 . The attacker needs
to provide a signature outside any linear combination of previously asked signatures.
Aggregate Signature Schemes
In 2001, Boneh, Lynn and Shacham propose a new signature scheme [BLS01] that was extended
firstly in 2007 by Bellare, Namprempre and Neven [BNN07] and then, in 2018 by Boneh, Drijvers
and Neven [BDN18]. These extensions allow aggregation of multiple messages signed by multiple
users. Hence, their signature is constant-size. Moreover, the verification is also constant-time
when the same message is signed by all the users (multi-signature). Since this is the most
interesting case for us, we focus on it.
BLS Aggregate Signature Scheme
Let G = g be a cyclic group of prime order p and H : {0, 1}∗ → G∗ be a full-domain hash function. The BLS signature scheme is composed of the three algorithms (SKeygen, Sign, VerifSign)
with:
Boneh-Lynn-Shacham Signature Scheme [BLS01]
$
SKeygen(κ): Given a security parameter κ, it chooses sk ←
Zp and outputs (sk, vk = gsk );
Sign(sk, m): Given a signing key sk and a message m ∈ {0, 1}∗ , it outputs the signature



2.4 - Cryptographic Primitives

21

σ = H(m)sk ;
VerifSign(vk, m, σ): Given a verification key vk, a message m and a signature σ, it outputs
1 if and only if (g, vk, H(m), σ) is a Diffie-Hellman tuple.
Given N tuples (vki , σi , mi ), it is possible to aggregate the signatures into a unique one
Q
σ = σi . To verify σ, one needs to check that:
e(g, σ) =

Y

e(vki , H(mi )).

i

However, this scheme is sensitive to the rogue public-key attack if all the message mi are the
same. In 2018, Boneh, Drijvers and Neven proposed a scheme to solve this issue.
BDN Multi-Signature Scheme
Let MSparam = (G1 , G2 , GT , p, g, g, e) ← G(κ) be an asymmetric pairing setting and let H0 :
{0, 1}∗ → G1 and H1 : {0, 1}∗ → Zp be two full-domain hash functions.
Boneh-Drijvers-Neven Multi-Signature Scheme [BDN18]
$
MSKeygen(MSparam): Given the global parameter MSparam, it chooses sk ←
Zp and
sk
outputs (sk, vk = g );

MSKeyAgg({vk1 , . . . , vkN }): Given N verification keys vki , it outputs the aggregated verQ
H1 (vki ,{vk1 ,...,vkN })
;
ification key avk = N
i=1 vki
MSSign({vk1 , . . . , vkN }, ski , m): Given N verification keys vki , a signing key ski and a
message m, it outputs σi = H0 (m)ski .
From all the individual signatures σi , any combiner (who can be one of the signers)
Q
H1 (vkj ,{vk1 ,...,vkN })
;
computes the multi-signature msig = N
j=1 σj
MSVerif(avk, m, msig): Given a verification key avk, a message m and a signature msig, it
outputs 1 if and only if e(g, msig) = e(H0 (m), avk).
Since the aggregated verification key can be precomputed, verification just consists of two
pairing evaluations.

2.4.3

(Homomorphic) Proof

A zero-knowledge proof (ZK) [GMR85] is a protocol between two players: a Prover and a Verifier
where the prover needs to convince the verifier of a given statement without revealing any other
information that the truth of this statement. The prover knowing a witness w and a statement
s provides a proof π that the verifier, given the statement s, accepts or rejects.
Informally, a zero-knowledge proof must satisfy the three properties:
Completeness: if the prover and the verifier follow the protocol, the verifier always accepts;
Soundness: a false proof is rejected with a probability of at least 1/2;
Zero-knowledge: whatever the verifier learns, he could have learned by himself without any
interaction with the prover.
Moreover, the zero-knowledge proof is said non-interactive (NIZK) if the prover simply sends
a proof π and, later, the verifier can verify π without any more information from the prover.



22

2 - Preliminaries

To achieve that, the classical method uses commitment schemes: the prover first commits some
random values and receives a challenge from the verifier, then the prover sends his response.
A commitment scheme ensures that a user committing a value m such that Com = Commit(m)
reveals no information about m (hiding property) but prevents the user from modifying m later:
there is only one way to open the commitment (binding property).
In particular, a commitment scheme is said perfectly hiding (resp. perfectly blinding) if the
hiding property (resp. blinding property) is true independently of the power of the attacker and
computationally if it relies on a computational assumption.
Example 13. To prove (g, h, A = g x , B = hx ) is a Diffie-Hellman tuple with a Schnorr-like
$
zero-knowledge proof, the prover first chooses r ←
Zp and sends the commitments U = g r and
r
V = h to the verifier that answers a challenge c ∈ Zp . The prover constructs its response
s = r − x · c mod p and the verifier checks whether both U = g s · Ac and V = hs · B c hold.
To make the proof non-interactive, one can use the Fiat-Shamir heuristic with c generated
by a hash function on the statement (g, h, A, B) and commitment (U, V ). The proof eventually
consists of (c, s). From this proof, one can compute the candidates for (U, V ), and check whether
the hash value gives back c.
Groth-Sahai Proofs
Let (G1 , G2 , GT , p, g, g, e) ← G(κ) be an asymmetric pairing setting. We recall the Groth-Sahai
methodology [GS08] to prove a Diffie-Hellman tuple in G2 (because it will be used in G2 later).
As the Groth-Sahai proofs are randomizable [BCC+ 09], we will also present how to randomize
a Diffie-Hellman proof of (g, g0 , A, A0 ) and how to update it into a new one for (g, g00 , A, A00 ).
First, we set a tuple (v1,1 , v1,2 , v2,1 , v2,2 ) ∈ G41 , such that (v1,1 , v1,2 , v2,1 , g × v2,2 ) is not a
Diffie-Hellman tuple. Then, given a Diffie-Hellman tuple (g, g0 , A, A0 ) in G2 , knowing the witness
α ∈ Zp such that A = gα and A0 = g0 α , one first commits α:
µ
µ
α
α
)
, d = v2,2
· g α · v1,2
Com = (c = v2,1
· v1,1
$
for a random µ ←
Zp , and one sets Θ = gµ and Ψ = Aµ , which satisfy:

e(c, g) = e(v2,1 , g0 ) · e(v1,1 , Θ)

e(d, g) = e(v2,2 · g, g0 ) · e(v1,2 , Θ)

e(c, A) = e(v2,1 , A0 ) · e(v1,1 , Ψ )

e(d, A) = e(v2,2 · g, A0 ) · e(v1,2 , Ψ )

The proof proof = (Com, Θ, Ψ ), when it satisfies the above relations, guarantees that (g, g0 , A, A0 )
is a Diffie-Hellman tuple.
Security. This proof is zero-knowledge, under the DDH assumption in G1 : by switching
(v1,1 , v1,2 , v2,1 , g × v2,2 ) into a Diffie-Hellman tuple, one can simulate the proof, as the commitment becomes perfectly hiding.
Efficiency. To verify the proof, instead of checking the four equations independently, one
can apply a batch verification [BFI+ 10], and pack them in a unique one with random scalars
$
x1,1 , x1,2 , x2,1 , x2,2 ←
Zp :
x

1,1
e(cx1,1 dx1,2 , gx2,1 Ax2,2 ) = e(v2,1
(v2,2 · g)x1,2 , g0

×
One thus just has 3 pairing evaluations.

x2,1

A0

x2,2

x1,1 x1,2
e(v1,1
v1,2 , Θx2,1 Ψ x2,2 )

)



2.4 - Cryptographic Primitives

23

Updating the Diffie-Hellman proof. The interesting property of Groth-Sahai proofs is that
it is possible from a Diffie-Hellman proof for (g, g0 , A, A0 ) to generate the Diffie-Hellman proof
0
0
for (g, g00 = g0 α , A, A00 = A0 α ) just knowing the incremental witness α0 , whereas the new witness
shoud be αα0 , but is unknown to the prover: from the Diffie-Hellman proof proof = (Com, Θ, Ψ )
for (g, g0 , A, A0 ) where
α µ
α µ α
Com = (c = v2,1
v1,1 , d = v2,2
v1,2 g )

Θ = gµ

0

Ψ = Aµ

0

$
one can compute the proof proof 0 for (g, g00 = g0 α , A, A00 = A0 α ), with µ0 ←
Zp and:
0

0

0

0

µ
µ
Com0 = (cα · v1,1
, dα · v1,2
)

0

0

Θ 0 = Θ α · gµ

0

Ψ 0 = Ψ α · Aµ

0

One implicitly updates α into αα0 and µ into α0 µ + µ0 . In particular, one can remark that if
α0 = 1, this simply randomizes the original proof.



24

2 - Preliminaries



Chapter

3

Decentralized Evaluation of
Quadratic Polynomials on
Encrypted Data

This chapter is based on the paper [HPP19] published in the proceedings of the International
Conference on Information Security, ISC 2019.

Chapter content
3.1

3.2

3.3

Freeman’s Approach . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

26

3.1.1

Notations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

26

3.1.2

Freeman’s Scheme with Projections . . . . . . . . . . . . . . . . . . . . .

27

3.1.3

Homomorphic Properties . . . . . . . . . . . . . . . . . . . . . . . . . .

28

3.1.4

Security Properties . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

30

3.1.5

Re-Encryption . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

32

3.1.6

Verifiability . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

33

3.1.7

Distributed Decryption . . . . . . . . . . . . . . . . . . . . . . . . . . .

Optimized Version . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

37
37

3.2.1

Instantiation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

37

3.2.2

Security Properties . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

39

3.2.3

Decentralized Homomorphic Encryption . . . . . . . . . . . . . . . . . .

40

3.2.4

Efficiency . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

43

Applications

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

43

3.3.1

Encryption for Boolean Formulae . . . . . . . . . . . . . . . . . . . . . .

44

3.3.2

Group Testing on Encrypted Data . . . . . . . . . . . . . . . . . . . . .

44

3.3.3

Consistency Model on Encrypted Data . . . . . . . . . . . . . . . . . . .

45

In 2005, Boneh, Goh and Nissim [BGN05] proposed a nice solution for quadratic polynomials evaluation. However, their solution relies on a composite-order elliptic curve and thus on
the hardness of the integer factoring. This possibly leads to a distributed solution, but that
is highly inefficient. Indeed, no efficient multi-party generation of distributed RSA modulus is
known, except for 2 parties. Catalano and Fiore [CF15] introduced an efficient technique to
transform a linearly-homomorphic encryption into a scheme able to evaluate quadratic operations on ciphertexts. They are able to support decryption of a large plaintext space after the
multiplication. However, as in Kawai et al. [KMH+ 19] which used this technique to perform
proxy re-encryption, they only consider a subclass of degree-2 polynomials where the number
of additions of degree-2 terms is bounded by a constant. This is not enough for most of the
applications and we do not try to decentralize these limited protocols.
In 2010, Freeman [Fre10] proposed a conversion from composite-order groups to prime-order
groups for the purpose of improving the efficiency. In Section 3.1, we show Freeman’s conversion allows multi-user setting, since a common setup can handle several keys and we show it



26

3 - Decentralized Evaluation of Quadratic Polynomials on Encrypted Data

is well-suited for distributed evaluation of 2-DNF formulae. However, it is not enough to have
an efficient distributed setup. One also needs to distribute any use of the private keys in the
construction: for decryption and re-encryption. Unfortunately, Freeman’s generic description
with projection matrices does not directly allow the design of a decentralized scheme, i.e., with
efficient distributed (threshold) decryption without any trusted dealer. We thus specify in Section 3.2 particular projections, with well-chosen private and public keys. Finally, in Section 3.3,
we propose two more applications that are related to the group testing and the consistency
model in machine learning.

Related Work. In a previous and independent work, Attrapadung et al. [AHM+ 18] proposed an efficient two-level homomorphic encryption in prime-order groups. They put forward
a new approach that avoids Freeman’s transformation from BGN encryption. Interestingly, our
work shows this scheme falls into Freeman’s framework because their construction is similar
to the simplified non-decentralized version of our scheme which is obtained from BGN via a
Freeman transformation with a particular choice of projections. The concrete implementations
in [AHM+ 18] show that such a scheme is quite efficient, which applies to our construction, and
even to the distributed construction as each server, for a partial decryption, essentially has to
perform a decryption with its share. In another unpublished work [CPRT18], Culnane et al.
considered a universally verifiable MPC protocol in which one of the two steps is to distribute
the key generation in somewhat homomorphic cryptosystems. However, as we mentioned above,
Freeman’s generic description with projection matrices, as considered in [CPRT18], does not
lead to an efficient distributed decryption. In short, our result bridges the gap between the
objective of decentralization as in [CPRT18] and the efficiency goal as in [AHM+ 18].

3.1
3.1.1

Freeman’s Approach
Notations

In this section, for a generator g of a cyclic group G = g , we use the implicit representation
[a] of any element h = g a ∈ G and by extension we will use the “bracket” notations, which
makes use of the matrix properties over the exponents defined in Chapter 2, that are scalars in
Zp when G is a cyclic group of order p. See Figure 3.1 for more details about the “brackets”.
• For x ∈ Zp , A ∈ Mm,n (Zp ): [x] = g x , [A] = g A = (g aij )ij
• For x ∈ Zp , A, B ∈ Mm,n (Zp ), X ∈ Mn,n0 (Zp ), Y ∈ Mm0 ,m (Zp ):
x · [A] = g xA

[A] · X = g AX

Y · [A] = g YA

[A]

[B] = [A + B]

• For A ∈ Mm,n (Zp ), B ∈ Mm0 ,n0 (Zp ): [A]1 • [B]2 = [A ⊗ B]T
Figure 3.1: Bracket Notations
In case of bilinear groups, we also define, for A ∈ Mm,n (Zp ) and B ∈ Mm0 ,n0 (Zp ), [A]1 •
[B]2 = [A ⊗ B]T , which can be evaluated with pairing operations between G1 and G2 group
elements.



3.1 - Freeman’s Approach

3.1.2

27

Freeman’s Scheme with Projections

The main goal of Freeman’s approach was to generalize the BGN cryptosystem to any hardsubgroup problems, which allows applications to prime-order groups under the classical Decisional Diffie-Hellman or Decisional Linear assumptions, with high gain in efficiency.
We now present a variant of Freeman’s cryptosystem allowing multiple users, without the
twin ciphertexts (in G and H). Since we will work in groups G1 , G2 , and GT , the algorithms
EKeygen, Encrypt and Decrypt will take a sub-script s to precise the group Gs in which they
operate, but the Setup is common.
Multi-User Freeman’s Cryptosystem
Setup(κ): Given a security parameter κ, it runs and
(G1 , G2 , GT , p, g1 , g2 , e) ← G(κ).

outputs

param

=

$
GL2 (Zp ), let Ps = B−1
EKeygens (param): For s ∈ {1, 2}, it chooses Bs ←
s U2 Bs and
ps ∈ ker(Ps ) \ {0}, and outputs the public key pks = [ps ]s and the private key
sks = Ps .

From (pk1 , sk1 ) ← EKeygen1 (param) and (pk2 , sk2 ) ← EKeygen2 (param), one can
consider pkT = (pk1 , pk2 ) and skT = (sk1 , sk2 ), which are associated public and
private keys in GT , as we explain below.
Encrypts (pks , m, As ): For s ∈ {1, 2}, to encrypt a message m ∈ Zp using public key
$
Zp and outputs the ciphertext Cs =
pks and As = [a]s ∈ G2s , it chooses r ←
2
2
(m · [a]s r · [ps ]s , [a]s ) ∈ Gs × Gs .
$
For s = T , with As = ([a1 ]1 , [a2 ]2 ), it sets [a]T = [a1 ]1 • [a2 ]2 ∈ G4T , chooses [r1 ]1 ←
$
G21 , [r2 ]2 ← G22 , and outputs CT = (m·[a]T [p1 ]1 •[r2 ]2 [r1 ]1 •[p2 ]2 , [a]T ) ∈ G4T ×G4T .
Decrypts (sks , Cs ): For s ∈ {1, 2}, given Cs = ([cs,1 ]s , [cs,2 ]s ) and sks = Ps , it lets Cs0 =
([cs,1 ]s · Ps , [cs,2 ]s · Ps ).
For s = T , it computes CT0 = ([cT,1 ]T · (P1 ⊗ P2 ), [cT,2 ]T · (P1 ⊗ P2 )).
In both cases, it outputs the logarithm of the first component of c0s,1 in base the first
component of c0s,2 .
With the algorithms defined above, we have three encryption schemes Es : (Setup, EKeygens ,
Encrypts , Decrypts ) for s = 1, 2 or T , with a common Setup.
Remark. We note that in Freeman’s cryptosystem, ciphertexts contain encryptions of m in
both G1 and G2 to allow any kind of additions and multiplication. But one could focus on one
ciphertext only when the formula to be evaluated is known.
Proposition 14. For s ∈ {1, 2, T }, Es is correct.
Proof. For s = 1, 2:
[cs,2 ]s · Ps = [a]s · Ps = [aPs ]s
[cs,1 ]s · Ps = (m · [a]s
= m · [aPs ]s

r · [ps ]s ) · Ps = m · [a]s · Ps
r · [ps Ps ]s = m · [aPs ]s

r · [ps ]s · Ps

r · [0]s = m · [aPs ]s



28

3 - Decentralized Evaluation of Quadratic Polynomials on Encrypted Data
For s = T :
[cT,2 ]T · (P1 ⊗ P2 ) = [a]T · (P1 ⊗ P2 ) = [a(P1 ⊗ P2 )]T
[cT,1 ]T · (P1 ⊗ P2 ) = (m · [a]T

[p1 ]1 • [r2 ]2

[r1 ]1 • [p2 ]2 ) · (P1 ⊗ P2 )

= m · [a(P1 ⊗ P2 )]T

([p1 ]1 • [r2 ]2 ) · (P1 ⊗ P2 )

= m · [a(P1 ⊗ P2 )]T

[p1 ⊗ r2 ]T · (P1 ⊗ P2 )

= m · [a(P1 ⊗ P2 )]T

[p1 P1 ⊗ r2 P2 ]T

= m · [a(P1 ⊗ P2 )]T

[0 ⊗ r2 P2 ]T

([r1 ]1 • [p2 ]2 ) · (P1 ⊗ P2 )

[r1 ⊗ p2 ]T · (P1 ⊗ P2 )

[r1 P1 ⊗ p2 P2 ]T

[r1 P1 ⊗ 0]T = m · [a(P1 ⊗ P2 )]T

0 = [c0 ] = m · [c0 ] = m · C 0 . Whatever the size of the vectors, one discrete
In both cases, Cs,1
s,1 s
s,2 s
s,2
logarithm computation is enough to extract m.

As already explained above, the encryption process masks the message by an element in the
kernel of a certain projection. The secret key is the corresponding projection Ps which later
removes this mask. In the Decrypt algorithm, Cs0 is a Diffie-Hellman tuple (whatever the group
under consideration), the discrete logarithm of one component is enough to decrypt, since the
plaintext is the common exponent.
One can note that matrices B1 and B2 are drawn independently, so the keys in G1 and G2
are independent. For any pair of keys (pk1 = [p1 ]1 , pk2 = [p2 ]2 ), one can implicitly define a
public key for the target group. To decrypt in the target group, both private keys sk1 = P1
and sk2 = P2 are needed. Actually, one just needs P1 ⊗ P2 to decrypt: CT0 = ([cT,1 ]T · (P1 ⊗
P2 ), [cT,2 ]T · (P1 ⊗ P2 )), but P1 ⊗ P2 and (P1 , P2 ) contain the same information and the latter
is more compact.

3.1.3

Homomorphic Properties

As BGN, Freeman cryptosystem also allows additions, one multiplication layer, and additions:
we detail the homomorphic functions below.
Add(Cs , Cs0 ): Given two ciphertexts Cs = ([cs,1 ]s , [cs,2 ]s ), C 0 = ([c0s,1 ]s , [c0s,2 ]s ) in one of
G21 × G21 , G22 × G22 , G4T × G4T , if [cs,2 ]s = [c0s,2 ]s , it outputs ([cs,1 ]s [c0s,1 ]s , [cs,2 ]s ),
otherwise it outputs ⊥.
Multiply(C1 , C2 ): Given two ciphertexts C1 = ([c1,1 ]1 , [c1,2 ]1 ) ∈ G21 × G21 and C2 = ([c2,1 ]2 ,
[c2,2 ]2 ) ∈ G22 × G22 , it outputs CT = ([c1,1 ]1 • [c2,1 ]2 , [c1,2 ]1 • [c2,2 ]2 ) ∈ G4T × G4T .
Randomizes (pks , Cs ): Given a ciphertext Cs = ([cs,1 ]s , [cs,2 ]s ), for s ∈ {1, 2} and a public
$
key pks = [ps ]s , it chooses α, r ←
Zp and outputs (α · ([cs,1 ]s r · [ps ]s ), α · [cs,2 ]s );
$
$
while for s = T and a public key pkT = ([p1 ]1 , [p2 ]2 ), it chooses α ←
Zp , [r1 ]1 ←
G21
$
and [r2 ]2 ← G22 , and outputs (α · ([cT,1 ]T [p1 ]1 • [r2 ]2 [r1 ]1 • [p2 ]2 ), α · [cT,2 ]T ).
Instead of performing a systematic randomization of ciphertexts as proposed by Freeman
each time an Add or a Multiply is computed, we create a specific function Randomize usable at
any time, when more privacy is required.
Let us check the correctness of the three homomorphic functions:
Proposition 15. Add and Multiply are correct.
Proof. Let us first consider the addition operations:



3.1 - Freeman’s Approach

29

• For s = 1, 2:
Add(Encrypts (pks , m, [a]s ; r), Encrypts (pks , m0 , [a]s ; r0 ))
= ([ma + rps ]s · [m0 a + r0 ps ]s , [a]s ) = ([(m + m0 )a + (r + r0 )ps ]s , [a]s )
= Encrypts (pks , m + m0 , [a]s ; r + r0 )
• For s = T :
Add(EncryptT (pkT , m, ([a1 ]1 , [a2 ]2 ); r1 , r2 ),
EncryptT (pkT , m0 , ([a1 ]1 , [a2 ]2 ); r01 , r02 ))
= ([m([a1 ]1 • [a2 ]2 ) + r1 ⊗ p2 + p1 ⊗ r2 ]T ·
[m0 ([a1 ]1 • [a2 ]2 ) + r01 ⊗ p2 + p1 ⊗ r02 ]T , [a1 ]1 • [a2 ]2 )
= ([(m + m0 )([a1 ]1 • [a2 ]2 ) + (r1 + r01 ) ⊗ p2 + p1 ⊗ (r2 + r02 )]T , [a1 ]1 • [a2 ]2 )
= EncryptT (pkT , m + m0 , ([a1 ]1 , [a2 ]2 ); r1 + r01 , r2 + r02 )
About multiplication, we can see that
Multiply(Encrypt1 (pk1 , m1 , [a1 ]1 ; r1 ), Encrypt2 (pk2 , m2 , [a2 ]2 ; r2 ))
= ([m1 a1 + r1 p1 ]1 · [m2 a2 + r2 p2 ]2 , [a1 ]1 • [a2 ]2 )
= ([(m1 a1 + r1 p1 ) ⊗ (m2 a2 + r2 p2 )]T , [a1 ]1 • [a2 ]2 )
= ([m1 a1 ⊗ m2 a2 + m1 a1 ⊗ r2 p2 + r1 p1 ⊗ m2 a2 + r1 p1 ⊗ r2 p2 ]T , [a1 ]1 • [a2 ]2 )
= ([m1 a1 ⊗ m2 a2 + m1 a1 ⊗ r2 p2 + r1 p1 ⊗ (m2 a2 + r2 p2 )]T , [a1 ]1 • [a2 ]2 )
= ([m1 m2 (a1 ⊗ a2 ) + p1 ⊗ (r1 m2 a2 + r1 r2 p2 ) + (r2 m1 a1 ) ⊗ p2 ]T , [a1 ]1 • [a2 ]2 )
= EncryptT (pkT , m1 m2 , ([a1 ]1 , [a2 ]2 ); m1 r2 a1 , m2 r1 a2 + r1 r2 p2 )
Proposition 16. For s ∈ {1, 2, T }, Randomizes is correct, with α = 1.
Proof. For s ∈ {1, 2}:
Randomizes (pks , Encrypts (pks , m, [a]s ; r), α, r0 )
= ([α(ma + rps + r0 ps )]s , [αa]s ) = ([m(αa) + α(r + r0 )ps ]s , [αa]s )
= Encrypts (pks , m, [αa]s ; α(r + r0 ))
Since r0 is uniformly distributed, the mask of the first component of the ciphertext is uniformly
distributed, as in a fresh ciphertext, while with α = 1, the basis in the second component
remains unchanged. In addition, the random α also randomizes the basis [αa]s , in the second
component of the ciphertext, but computationally only, under the DDH assumption in Gs .
For s = T :
RandomizeT (pkT , EncryptT (pkT , m, ([a1 ]1 , [a2 ]2 ); r), α, r01 , r02 )
= (α · (m · [a]T

[p1 ]1 • [r2 ]2

[r1 ]1 • [p2 ]2

[p1 ]1 • [r02 ]2

[r01 ]1 • [p2 ]2 , [a]T ),

([αa1 ]1 , [αa2 ]2 ))
= (α · (m · [a]T

[p1 ]1 • [r2 + r02 ]2

[r1 + r01 ]1 • [p2 ]2 ), ([αa1 ]1 • [αa2 ]2 ))

= EncryptT (pkT , m, ([αa1 ]1 , [αa2 ]2 ); α(r2 + r01 ), α(r2 + r02 ))
Again, since r01 and r02 are uniformly distributed, the mask of the first component of the ciphertext is uniformly distributed, as in a fresh ciphertext. In addition, the random α randomizes
the basis in the second component of the ciphertext, but computationally only, under the DDH
assumption in both G1 and G2 .



30

3 - Decentralized Evaluation of Quadratic Polynomials on Encrypted Data

3.1.4

Security Properties

Theorem 17. For s ∈ {1, 2}, Es is IND-CPA under the DDH assumption in Gs : for any
adversary A running within time t, AdvEind-cpa
(A) ≤ 2 × Advddh
Gs (t).
s
Proof. We denote by Advind-cpa
(A) the advantage of A against Es . We assume the running time
Es
of A is bounded by t.
Game G0 : In this first game, the simulator plays the role of the challenger in the experiment
Expind-cpa-0
(A), where b = 0:
Es
S(κ):
• param = (G1 , G2 , GT , p, g1 , g2 , e) ← Setup(κ)
• (sks , pks ) ← EKeygens (param)
• m0 , m1 , [a]s ← A(param, pks )
• Cs = (m0 · [a]s
•

b0

r · [ps ]s , [a]s ) ← Encrypts (pks , m0 , [a]s )

← A(param, pks , Cs )

We are interested in the event E: b0 = 1. By definition,
h

i

Pr[E] = Pr Expind-cpa-0
(A) = 1 .
E

G0

Game G1 : Now the simulator takes as input a Diffie-Hellman tuple ([p]s , [r]s ), with r =
r · p for some scalar r, and emulates EKeygens and Encrypts by defining pks ← [p]s and
Cs ← (m0 · [a]s [r]s , [a]s ). Thanks to the Diffie-Hellman tuple, this game is perfectly
indistinguishable from the previous one: PrG1 [E] = PrG0 [E].
Game G2 : The simulator now receives a random tuple ([p]s , [r]s ): PrG2 [E] − PrG1 [E] ≤
Advddh
Gs (t).
Game G3 : The simulator still receives a random tuple ([p]s , [r]s ), but generates Cs ← (m1 ·
[a]s [r]s , [a]s ). Thanks to the random mask [r]s , this game is perfectly indistinguishable
from the previous one: PrG3 [E] = PrG2 [E].
Game G4 : The simulator now receives a Diffie-Hellman tuple ([p]s , [r]s ), with r = r · p for
some scalar r: PrG4 [E] − PrG3 [E] ≤ Advddh
Gs (t).
Game G5 : In this game, the simulator can perfectly emulate the challenger in the experiment
Expind-cpa-1
(A), where b = 1: This game is perfectly indistinguishable from the previous
Es
one: PrG5 [E] = PrG4 [E].
h

i

One can note, that in this last game, PrG5 [E] = Pr ExpEind-cpa-1
(A) = 1 , hence
s
h

i

h

i

Pr Expind-cpa-1
(A) = 1 − Pr ExpEind-cpa-0
(A) = 1 ≤ 2 × Advddh
Gs (t),
Es
s
which concludes the proof.
Corollary 18. ET is IND-CPA under the DDH assumptions in G1 or G2 . More precisely, for
any adversary A running within time t,
ddh
Advind-cpa
(A) ≤ 2 × min{Advddh
G1 (t + tm + te ), AdvG2 (t + tm + te )},
ET

where tm is the time for one multiplication and te the time for one encryption.



3.1 - Freeman’s Approach

31

Proof. The semantic security for ciphertexts in GT comes from the fact that:
EncryptT (pkT , m, ([a1 ]1 , [a2 ]2 ))
= Multiply(Encrypt1 (pk1 , m, [a1 ]1 ), Encrypt2 (pk2 , 1, [a2 ]2 ))
= Multiply(Encrypt1 (pk1 , 1, [a1 ]1 ), Encrypt2 (pk2 , m, [a2 ]2 ))
Indeed, with this relation, each ciphertext in G1 can be transformed into a ciphertext in GT
(idem with a ciphertext in G2 ). Let A be an adversary against IND-CPA of ET , in GT .
Game G0 : In the first game, the simulator plays the role of the challenger in the experiment
Expind-cpa-0
(A), where b = 0:
ET
S(κ):
• param = (G1 , G2 , GT , p, g1 , g2 , e) ← Setup(κ)
• (sk1 , pk1 ) ← EKeygen1 (param),(sk2 , pk2 ) ← EKeygen2 (param)
• m0 , m1 , [a]1 , [a]2 ← A(param, (pk1 , pk2 ))
• CT = EncryptT ((pk1 , pk2 ), m0 , ([a]1 , [a]2 ))
• β ← A(param, (pk1 , pk2 ), CT )
We are interested in the event E: b0 = 1. By definition,
i

h

(A) = 1 .
Pr[E] = Pr ExpEind-cpa-0
T

G0

Game G1 : The simulator interacts with a challenger in ExpEind-cpa-0
(A), where b = 0. It thus
1
first receives param, pk1 from that challenger, generates pk2 by himself to provide (pkT =
(pk1 , pk2 )) to the adversary. The latter sends back (m0 , m1 , [a]1 , [a]2 ), from which it sends
(m0 , m1 , [a]1 ) to the challenger. It gets back C1 = Encrypt1 (pk1 , m0 , [a]1 ). It can compute
the ciphertext CT = Multiply(C1 , Encrypt2 (pk2 , 1, [a2 ]2 )), to be sent to the adversary. This
game is perfectly indistinguishable from the previous one: PrG1 [E] = PrG0 [E].
Game G2 : The simulator interacts with a challenger in ExpEind-cpa-1
(A), where b = 1:
1
Pr[E] − Pr[E] ≤ AdvEind-cpa
(t + tm + te ),
1

G2

G1

where tm is the time for one multiplication and te the time for one encryption.
Game G3 : In this final game, the simulator plays the role of the challenger in the experiment
Expind-cpa-1
(A), where b = 1. This game is perfectly indistinguishable from the previous
ET
one: PrG3 [E] = PrG2 [E].
h

i

One can note, that in this last game, PrG3 [E] = Pr Expind-cpa-1
(A) = 1 , hence
ET
h

i

h

i

Pr Expind-cpa-1
(A) = 1 − Pr ExpEind-cpa-0
(A) = 1 ≤ Advind-cpa
(t + tm + te ),
ET
ET
T
which concludes the proof, since it works exactly the same way for G2 .



32

3 - Decentralized Evaluation of Quadratic Polynomials on Encrypted Data

3.1.5

Re-Encryption

We have three efficient encryption schemes able to compute homomorphic operations and supporting multiple users. When a result should be available to a unique user, a classical technique
called proxy re-encryption [BBS98] is to re-encrypt to this target user: this is a virtual decryption followed by encryption under the new key. With Freeman’s approach, and our formalism,
this is just a change of basis in the exponents: we can re-encrypt a message encrypted under a
private key pka into another encryption for a private key pkb by using a special secret key called
re-encryption key rka→b .
Below we describe REKeygens that creates the re-encryption key from the secret keys and
REEncrypts the function to re-encrypt a ciphertext, but under a different basis.
REKeygens (skas , skbs ): For s = 1, 2, from two different secret keys skas = Ps and
skbs = P0s associated respectively to the two public keys pkas and pkbs , compute
0
0 −1
0
Bs , B0s ∈ GL2 (Zp ) such that Ps = B−1
s UBs and Ps = Bs UBs and output
a→b
−1
0
rks
= Rs = Bs Bs the secret re-encryption key. From the re-encryption keys
a→b
rk1 = R1 ← REKeygen1 (ska1 , skb1 ) and rka→b
= R2 ← REKeygen2 (ska2 , skb2 ), we will
2
a→b
a→b
a→b
consider rkT = (rk1 , rk2 ), as the matrix RT actually is R1 ⊗ R2 .
REEncrypts (rksa→b , Cs ): To re-encrypt a ciphertext C = ([cs,1 ]s , [cs,2 ]s ):
• for s = 1, 2, output ([cs,1 ]s · rka→b
, [cs,2 ]s · rka→b
);
s
s
• for s = T , output ([cT,1 ]T · (rka→b
⊗ rka→b
), [cT,2 ]T · (rka→b
⊗ rka→b
)).
1
2
1
2
We stress that the basis a is modified with the re-encryption process, into aRs or a(R1 ⊗R2 ),
which could leak some information about the re-encryption key. But as explained above, the
randomization process can provide a new ciphertext that computationally hides it, under DDH
assumptions. However, this requires this basis a to be part of the ciphertext as it cannot be a
constant.
Correctness of Re-Encryption. The correctness of the re-encryption is based on a change
of basis that transforms an element in the kernel of Ps in an element in the kernel of P0s : let
p ∈ ker(Ps ) and p0 ∈ ker(P0s ) because ker(Ps ) and ker(P0s ) are of dimension 1 in Z2p , there exist
a, b, k ∈ Zp , such that p = k · (a, b) and a0 , b0 , k 0 ∈ Zp , such that p0 = k 0 · (a0 , b0 ). We have:
p · rk = p · B−1 B0 = k(1, 0)B0 = k(a0 , b0 ) ⇒ p · rk = kk 0

−1 0

p = r 0 p0

for some r0 ∈ Zp and with that, the correctness follows, where rka→b
is denoted Rs : for s ∈ {1, 2},
s
REEncrypts (rksa→b , Encrypts (pkas , m, a, r)) = ([cs,1 ]s · rka→b
, [cs,2 ]s · rka→b
)
s
s
= ([maRs + rps Rs ]s , [aRs ]s ) = ([maRs + rr0 p0s ]s , [aRs ]s )
= Encrypts (pkbs , m, aRs ; rr0 )
For s = T ,
REEncryptT (rkTa→b , EncryptT (pkaT , m, a; r1 , r2 ))
= ([cT,1 ]T · (rk1a→b ⊗ rka→b
), [cT,2 ]T · (rka→b
⊗ rka→b
))
2
1
2
= ([(ma + p1 ⊗ r2 + r1 ⊗ p2 ) · (R1 ⊗ R2 )]T , [a · (R1 ⊗ R2 )]T )
= ([ma(R1 ⊗ R2 ) + p1 R1 ⊗ r2 R2 + r1 R1 ⊗ p2 R2 ]T , [a · (R1 ⊗ R2 )]T )
= ([ma(R1 ⊗ R2 ) + r01 p01 ⊗ r2 R2 + r1 R1 ⊗ r02 p02 ]T , [a · (R1 ⊗ R2 )]T )
= ([ma(R1 ⊗ R2 ) + p01 ⊗ r01 r2 R2 + r02 r1 R1 ⊗ p02 ]T , [a · (R1 ⊗ R2 )]T )
= EncryptT (pkbT , m, a(R1 ⊗ R2 ); r02 r1 R1 , r01 r2 R2 )



3.1 - Freeman’s Approach

3.1.6

33

Verifiability

When a ciphertext is randomized or re-encrypted by a third party, one may want to be sure the
content is kept unchanged. Verifiability is thus an important property we can efficiently achieve,
with classical zero-knowledge proofs of discrete logarithm relations à la Schnorr. Such linear
proofs of existence for k scalars that satisfy linear relations generally consist of a commitment
c, a challenge e ∈ Zp and the response r ∈ Zkp (see Preliminaries 2.4.3). The non-interactive
variant just contains e and r, and thus k + 1 scalars.
Example 19. Let M ∈ M2 (Zp ) and ([x]s , [y]s ), ([x0 ]s , [y0 ]s ) ∈ G2s . We will make the zeroknowledge proof of existence of M such that both [y]s = [x]s · M and [y0 ]s = [x0 ]s · M, where
[x]s , [y]s , [x0 ]s and [y0 ]s are public, but the prover knows M. This is the classical zero-knowledge
proof of equality of discrete logarithms with matrices.
$
The prover chooses M0 ←
M2 (Zp ) and sends the commitments [c]s = [x]s · M0 and [c0 ]s =
0
0
[x ]s · M to the verifier that answers a challenge e ∈ Zp . The prover constructs its response
R = M0 − eM in M2 (Zp ) and the verifier checks whether both [c]s = [x]s · R e[y]s and
[c0 ]s = [x0 ]s · R e[y0 ]s , in G2s . To make the proof non-interactive, one can use the Fiat-Shamir
heuristic with e generated by a hash function (modeled as a random oracle) on the statement
([x]s , [y]s ), ([x0 ]s , [y0 ]s ) and commitments ([c]s , [c0 ]s ). The proof eventually consists of (e, R).
From this proof, one can compute the candidates for ([c]s , [c0 ]s ), and check whether the hash
value gives back e.
Before entering into the details of the relations to be proven, for each function of our encryption scheme, we rewrite the EKeygens and REKeygens algorithms to prepare the verifiability of
Decrypts and REEncrypts . These new EKeygens and REKeygens algorithms consist of the original EKeygens and REKeygens but with more elements in the output: they both output a public
version of the produced secret key plus a zero-knowledge proof of the correctness of the keys.
This significantly simplifies the relations to be proven afterwards for Decrypts and REEncrypts .
At the end of this section, we prove that adding those elements do not compromise the security
of the encryption scheme.
EKeygens for Verifiability.
While the secret key is the projection Ps , the verification key vsks consists of [Ps ]s :
$
EKeygens (param): For s ∈ {1, 2}. It chooses Bs ←
GL2 (Zp ), lets Ps = B−1
s U2 Bs and
ps ∈ ker(Ps ) \ {0} and outputs the public key pks = [ps ]s , the private key sks = Ps
and vsks = [Ps ]s a verifiable public version of the secret key with the proof πs :

{∃sks ∈ M2 (Zp ), vsks 6= [0]s ∧ vsks = [1]s · sks ∧ pks · sks = [0]s }.
The proof πs guarantees that all the keys are well-formed: vsks is the exponentiation of a
2 × 2-matrix sks , for which the discrete logarithm of pks is in the kernel. Hence, sks is not
full rank, and vsks 6= [0]s proves that sks is of dimension 1: a projection. As a consequence,
πs consists of 5 scalars of Zp , using the above non-interactive zero-knowledge technique à la
Schnorr.
From (vsk1 , vsk2 ), we consider vskT = vsk1 •vsk2 . It satisfies vskT = [P1 ⊗P2 ]T if (vsk1 , vsk2 ) =
([P1 ]1 , [P2 ]2 ).
REKeygens for Verifiability.
As above, while the secret re-encryption key is an invertible change of basis matrix rka→b
, the
s
is
verification key vrksa→b consists of [rksa→b ]s . However, in order to prove the matrix rka→b
s



34

3 - Decentralized Evaluation of Quadratic Polynomials on Encrypted Data

invertible, one can show it is non-zero, and not of rank 1, which would mean that vrka→b
would
s
consist of a Diffie-Hellman tuple:
REKeygens (skas , skbs ): For s = 1, 2, from two different secret keys skas = Ps and skbs = P0s
associated respectively to the two public keys pkas and pkbs , it computes Bs , B0s ∈
a→b
0
0 −1
0
M2 (Zp )2 such that Ps = B−1
= Rsa→b =
s UBs and Ps = Bs UBs . Let rks
a→b
0
B−1
= [rka→b
]s be a verifiable public
s Bs be the secret re-encryption key, vrks
s
0
version of the re-encryption key and [r ]s = λ · [r12 ]s where λ is such that r21 = λ · r11
(with r11 , r12 , r21 , r22 the components of rka→b
, and πsa→b :
s
{∃rksa→b ∈ M2 (Zp ),∃λ ∈ Zp ,
vrks 6= [0]s ∧ vrka→b
= [1]s · rka→b
∧ pkbs = pkas · rka→b
s
s
s
∧ [r0 ]s = λ · [r12 ]s ∧ [r21 ]s = λ · [r11 ]s ∧ [r0 ]s 6= [r22 ]s }
It outputs (rksa→b , vrksa→b , [r0 ]s , πsa→b ).
The proof πsa→b guarantees that vrka→b
is well-formed and, since in M2 (Zp ), the matrices
s
are 0, or of rank 1 as a projection, or invertible: πsa→b first checks it is not 0, and then not of
rank 1 either, as vrksa→b is not a Diffie-Hellman tuple.
The two checks vrksa→b 6= [0]s and [r0 ]s 6= [r22 ]s are just simple verifications, thus πsa→b needs
6 scalars of Zp as a proof à la Schnorr.
Similarly as for vsks , from (vrk1 , vrk2 ), we consider vrkT = vrk1 • vrk2 . So that, vrkT =
[R1 ⊗ R2 ]T if (vrk1 , vrk2 ) = ([R1 ]1 , [R2 ]2 ).
Now, we explain for each function, the relations to be proven:
The function Randomizes .
It takes a ciphertext Cs = ([cs,1 ]s , [cs,2 ]s ) encrypted with a public key pks and produces a
ciphertext Cs0 = ([c0s,1 ]s , [c0s,2 ]s ) such that:
• for s ∈ {1, 2} and pks = [ps ]s , it exists α, r ∈ Zp such that:
[c0s,1 ]s = α · ([cs,1 ]s

r · [ps ]s ) ∧ [c0s,2 ]s = α · [cs,2 ]s

• for s = T and pkT = ([p1 ]1 , [p2 ]2 ), it exists α ∈ Zp , r1 , r2 ∈ Z2p such that:
[c0T,1 ]T = α · ([cT,1 ]T

[p1 ]1 • [r2 ]2

[r1 ]1 • [p2 ]2 ) ∧ [c0T,2 ]T = α · [cT,2 ]T

These relations are equivalent to the linear relations:
• for s ∈ {1, 2}, it exists α, r ∈ Zp such that:
[c0s,1 ]s = α · [cs,1 ]s

r · [ps ]s ∧ [c0s,2 ]s = α · [cs,2 ]s

• for s = T , it exists α ∈ Zp , r1 , r2 ∈ Z2p such that:
[c0T,1 ]T = α · [cT,1 ]T

[p1 ]T · r2

r1 · [p2 ]T ∧ [c0T,2 ]T = α · [cT,2 ]T

These proofs consist of 3 scalars of Zp for s ∈ {1, 2}, and 6 scalars of Zp for s = T .
The functions Add and Multiply.
They are public and deterministic thus everyone can check the operations.



3.1 - Freeman’s Approach

35

The function Decrypts .
It takes a ciphertext Cs = ([cs,1 ]s , [cs,2 ]s ) encrypted with a public key pks and produces its
decryption m such that:
• for s ∈ {1, 2} and pks = [ps ]s , it exists sks = Ps ∈ M2 (Zp ) such that:
[ps ]s · Ps = [0]s ∧ Ps 6= 0 ∧ [cs,1 ]s · Ps = m · [cs,2 ]s · Ps
• for s = T and pkT = ([p1 ]1 , [p2 ]2 ), it exists skT = (P1 , P2 ) ∈ M2 (Zp )2 such that:
[p1 ]1 · P1 = [0]1 ∧ [p2 ]2 · P2 = [0]2 ∧ P1 6= 0 ∧ P2 6= 0
∧ [cT,1 ]T · (P1 ⊗ P2 ) = m · [cT,2 ]T · (P1 ⊗ P2 )
Instead of proving these relations, the prover will use vsks for s ∈ {1, 2, T } produced by EKeygens
for verifiability and will make the proof of the relations:
• for s ∈ {1, 2}, it exists sks = Ps ∈ M2 (Zp ) such that:
[vsks ]s = [1]s · Ps ∧ ([cs,1 ]s

m · [cs,2 ]s ) · Ps = [0]s

• for s = T , it exists skT = (P1 , P2 ) ∈ M2 (Zp )2 such that:
[vskT ]T = [1]T · (P1 ⊗ P2 ) ∧ ([cT,1 ]T

m · [cT,2 ]T ) · (P1 ⊗ P2 ) = [0]T

The linear proofs consist of 5 scalars of Zp for s ∈ {1, 2} and 17 scalars of Zp for s = T .
The function REEncrypts .
It takes a ciphertext Cs = ([cs,1 ]s , [cs,2 ]s ) encrypted with a public key pkas and produces a
ciphertext Cs0 = ([c0s,1 ]s , [c0s,2 ]s ) encrypted with a public key pkbs such that:
• for s ∈ {1, 2}, it knows rksa→b = Rs ∈ GL2 (Zp ) such that:
([c0s,1 ]s , [c0s,2 ]s ) = ([cs,1 ]s · Rs , [cs,2 ]s · Rs ) ∧ pkbs = pkas · Rs
• for s = T , pkaT = (pka1 , pka2 ), pkbT = (pkb1 , pkb2 ) and vrkT = ([R1 ]1 • [R2 ]2 ), it knows
rka→b
= (R1 , R2 ) ∈ GL2 (Zp )2 such that:
T
([c0T,1 ]T , [c0T,2 ]T ) = ([cT,1 ]T · (R1 ⊗ R2 ), [cT,2 ]T · (R1 ⊗ R2 ))
∧ pkbT = (pkb1 , pkb2 ) = (pka1 · R1 , pka2 · R2 )
Instead of proving these relations, the prover will use vrks for s ∈ {1, 2, T } produced by
REKeygens for verifiability and will make the proof of the relations below:
• for s ∈ {1, 2}, it knows rksa→b = Rs ∈ M2 (Zp ) such that:
([c0s,1 ]s , [c0s,2 ]s ) = ([cs,1 ]s · Rs , [cs,2 ]s · Rs ) ∧ vrka→b
= [1]s · Rs
s
• for s = T , it knows rkTa→b = (R1 ⊗ R2 ) ∈ M4 (Zp ) such that:
([c0T,1 ]T , [c0T,2 ]T ) = ([cT,1 ]T · (R1 ⊗ R2 ), [cT,2 ]T · (R1 ⊗ R2 ))
∧ vrkTa→b = [1]T · (R1 ⊗ R2 )



36

3 - Decentralized Evaluation of Quadratic Polynomials on Encrypted Data

This proof needs 5 scalars of Zp for s ∈ {1, 2} and 17 scalars of Zp for s = T .
Proposition 20. For s ∈ {1, 2}, Es with verifiability is still secure. More precisely, for any
adversary A running within time t,
AdvEind-cpa
(A) ≤ 4 × Advddh
Gs (t).
s
Proof. The modified EKeygens also outputs vsks and a zero-knowledge proof πs . This implies
that some games need to be added before the first game in the security proof of Es for Theorem 17:
Game G0 : In the first game, the simulator plays the role of the challenger in the experiment
Expind-cpa-0
(A), where b = 0:
Es
S(κ):
• param = (G1 , G2 , GT , p, g1 , g2 , e) ← Setup(κ)
• (sks , pks , vsks , πs ) ← EKeygens (param)
• m0 , m1 , [a]s ← A(param, pks )
• Cs = (m0 · [a]s
•

b0

r · [ps ]s , [a]s ) ← Encrypts (pks , m0 , [a]s )

← A(param, pks , Cs )

We are interested in the event E: b0 = 1. By definition,
i

h

Pr[E] = Pr Expind-cpa-0
(A) = 1 .
Es

G0

Game G1 : The first modification is to replace πs by its simulation, possible thanks to the
zero-knowledge property. This game is statistically indistinguishable from the previous
one, under the statistical zero-knowledge property of the proof à la Schnorr in the Random
Oracle Model.
Game G2 : Now the simulator takes as input a Diffie-Hellman tuple ([a]s , [b]s ), with b = r · a
for some scalar r, and emulates EKeygens by defining vsks the matrix defined by the two
vectors ([a]s , [b]s ). Thanks to the Diffie-Hellman tuple this corresponds to the matrix
of a projection, and thus this game is perfectly indistinguishable from the previous one:
PrG2 [E] = PrG1 [E].
Game G3 : The simulator now receives a random tuple ([a]s , [b]s ): PrG3 [E] − PrG2 [E] ≤
Advddh
Gs (t). In this game, there is no information in vsks anymore and the zero-knowledge
proofs are simulated. In the original proof, sks is never used, thus we can plug the games
from the original proof here. To finish the proof we need to unravel the games of vsks and
πs in order to have:
Game G4 : S(κ):
• param = (G1 , G2 , GT , p, g1 , g2 , e) ← Setup(κ)
• (sks , pks , vsks , πs ) ← EKeygens (param)
• m0 , m1 , [a]s ← A(param, pks )
• Cs = (m1 · [a]s
•

b0

r · [ps ]s , [a]s ) ← Encrypts (pks , m0 , [a]s )

← A(param, pks , Cs )

the experiment Expind-cpa-1
(A).
Es
Hence, we have:
h

i

h

i

Pr Expind-cpa-1
(A) = 1 − Pr ExpEind-cpa-0
(A) = 1 ≤ 4 × Advddh
Gs (t).
Es
s



3.2 - Optimized Version

37

Corollary 21. ET with verifiability is still secure.
Proof. Similarly to the previous proof, the zero-knowledge proofs are replaced by their simulations. Then, vsk1 and vsk2 are replaced by random matrices in M2 (G1 ) and M2 (G2 ) respectively.
Thus, vskT is also a random matrix.

3.1.7

Distributed Decryption

When a third-party performs the decryption, it is important to be able to prove the correct
decryption, which consists of zero-knowledge proofs, as described in the previous Section 3.1.6.
However, this is even better if the decryption process can be distributed among several servers,
under the assumption that only a small fraction of them can be corrupted or under the control
of an adversary.
To decrypt a ciphertext in Gs with s ∈ {1, 2}, one needs to compute ([cs,1 ]s · sks , [cs,2 ]s · sks ).
In a Shamir’s like manner [Sha79], one can perform a t-out-of-n threshold secret sharing by
P
distributing sks such that sks = i∈I λI,i sks,i with I ⊂ {1, . . . , n} a subset of t users, and for all
i ∈ I, λI,i ∈ Zp and sks,i is the secret key of the party Pi .
For s = T and with just the distribution of sk1 and sk2 , it is also possible to perform a
distributed decryption, using the relation sk1 ⊗ sk2 = (sk1 ⊗ 1) × (1 ⊗ sk2 ). One can thus make
a two round decryption, first in G1 and then in G2 .
Remark. Because the operations to decrypt or re-encrypt are the same, one can make distributed re-encryption in the same vein: in our applications, computations will be performed
on data encrypted under a controller’s key, where the controller is actually a pool of controllers
with a distributed decryption key. The latter will be used to re-encrypt the result under the
targer end-user’s key.
However, in this scheme, the secret key must be a projection matrix, which is not easy to
generate at random: for this key generation algorithm, a trusted dealer is required, which is not
ideal when nobody is trusted. This is the goal of the rest of the chapter, to show that we can
optimize this generic construction, and distribute everything without any trusted dealer.

3.2

Optimized Version

We presented the translation of Freeman’s approach with projection matrices. This indeed leads
to a public-key encryption scheme that can evaluate quadratic polynomials in Zp , under the
DDH assumption. However, because the secret key must be a projection matrix, the distributed
generation, while possible, is not as efficient as one can expect. We thus now propose a particular
instantiation of projections, which allows very compact keys and ciphertexts.

3.2.1

Instantiation

While in the generic transformation of Freeman, the secret key belongs to the whole projection
matrix space, our particular instantiation of projections means that the secret key will belong
to a proper sub-space of the projection matrix space. In addition, this will allow to generate
keys in a distributed manner, without any trusted dealer.
Indeed, it is possible to reduce by a factor two the size of the keys: for s ∈ {1, 2}, the
secret key is just one scalar and the public key one group element in Gs . For the keys, we will
consider orthogonal projections on (1, x) , for any x ∈ Zp . Thus, sks can simply be described
by x ∈ Zp , which is enough to define the projection. The public key pks can simply be described
by gs−x ∈ Gs , which is enough to define (gs−x , gs ), as (−x, 1) is a vector in the kernel of the
projection, to add noise that the secret key will be able to remove.



38

3 - Decentralized Evaluation of Quadratic Polynomials on Encrypted Data

More precisely, we can describe our optimized encryption schemes, for s ∈ {1, 2, T }, as
Es : (Setup, EKeygens , Encrypts , Decrypts ) with a common Setup (as the index s indicates the
group, in this section, elements of G2 will not be denoted in Fraktur font):

Setup(κ): Given a security parameter κ, it runs and outputs
param = (G1 , G2 , GT , p, g1 , g2 , e) ← G(κ).
$
Zp and outputs the public key
EKeygens (param): For s ∈ {1, 2}. It chooses xs ←
pks = gs−xs and the private key sks = xs . From (pk1 , sk1 ) ← EKeygen1 (param)
and (pk2 , sk2 ) ← EKeygen2 (param), one can consider pkT = (pk1 , pk2 ) and skT =
(sk1 , sk2 ), which are associated public and private keys in GT .

Encrypts (pks , m): For s ∈ {1, 2}, to encrypt a message m ∈ Zp using public key pks , it
$
chooses r ←
Zp and outputs the ciphertext
Cs = (cs,1 = gsm · pkrs , cs,2 = gsr ) ∈ G2s .
For s = T , to encrypt a message m ∈ Zp using public key pkT = (pk1 , pk2 ), it
$
chooses r11 , r12 , r21 , r22 ←
Z4p and outputs the ciphertext





CT = 

cT,1
cT,2
cT,3
cT,4

=
=
=
=

e(g1 , g2 )m · e(g1 , pk2 )r11 · e(pk1 , g2 )r21 ,
e(g1 , g2 )r11 · e(pk1 , g2 )r22 ,
e(g1 , pk2 )r12 · e(g1 , g2 )r21 ,
e(g1 , g2 )r12 +r22




 ∈ G4T


Decrypts (sks , Cs ): For s ∈ {1, 2}, given Cs = (cs,1 , cs,2 ) and the private key sks , it coms
putes d = cs,1 · csk
s,2 and outputs the logarithm of d in basis gs . For s = T , given
sk1 sk1 ·sk2
2
CT = (cT,1 , cT,2 , cT,3 , cT,4 ) and skT = (sk1 , sk2 ), it computes d = cT,1 ·csk
T,2 ·cT,3 ·cT,4
and outputs the logarithm of d in basis e(g1 , g2 ).

In G1 and G2 , this is actually the classical ElGamal encryption. We essentially extend it to
GT , to handle quadratic operations:

Add(Cs , Cs0 ) just consists of the component-wise product in Gs ;
Multiply(C1 , C2 ) for C1 = (c1,1 = g1m1 · pkr11 , c1,2 = g1r1 ) ∈ G21 and C2 = (c2,1 = g2m2 ·
pkr22 , c2,2 = g2r2 ) ∈ G22 , consists of the tensor product:
CT = (e(c1,1 , c2,1 ), e(c1,1 , c2,2 ), e(c1,2 , c2,1 ), e(c1,2 , c2,2 )) ∈ G4T
Randomizes (pks , Cs ) is, as usual, the addition of a random ciphertext of 0 in the same
group Gs . For s ∈ {1, 2}: Given a ciphertext Cs = (cs,1 , cs,2 ) with its public key pks ,
$
it chooses r ←
Zp and outputs (cs,1 · pkrs , cs,2 · gsr ); while for s = T , a public key pkT
$
0 , r0 , r0 , r0 ←
and a ciphertext (cT,1 , cT,2 , cT,3 , cT,4 ), it chooses r11
Zp and outputs
12 21 22
0
0
0
0
0
(cT,1 · e(g1 , pk2 )r11 · e(pk1 , g2 )r21 , cT,2 · e(g1 , g2 )r11 · e(pk1 , g2 )r22 , cT,3 · e(g1 , pk2 )r12 ·
0
0
0
e(g1 , g2 )r21 , cT,4 · e(g1 , g2 )r12 +r22 ).



3.2 - Optimized Version

3.2.2

39

Security Properties

Whereas the correctness directly comes from the correctness of Freeman’s construction, presented in the Section 3.1, and verification is straightforward, the semantic security comes from
the classical ElGamal encryption security, under the DDH assumptions, for the basic schemes
in G1 and G2 :
Theorem 22. For s ∈ {1, 2}, Es is IND-CPA under the DDH assumption in Gs : for any
adversary A running within time t, Advind-cpa
(A) ≤ 2 × Advddh
Gs (t).
Es
Corollary 23. ET is IND-CPA under the DDH assumptions in G1 or G2 .
Proof. The semantic security for ciphertexts in GT comes from the fact that:
EncryptT (pkT , m) = Multiply(Encrypt1 (pk1 , m), Encrypt2 (pk2 , 1))
= Multiply(Encrypt1 (pk1 , 1), Encrypt2 (pk2 , m))
Indeed, with this relation, each ciphertext in G1 can be transformed into a ciphertext in GT
(idem with a ciphertext in G2 ). Let A be an adversary against IND-CPA of ET , in GT .
Game G0 : In the first game, the simulator plays the role of the challenger in the experiment
Expind-cpa-0
(A), where b = 0:
ET
•
•
•
•

param = (G1 , G2 , GT , p, g1 , g2 , e) ← Setup(κ)
(sk1 , pk1 ) ← EKeygen1 (param),(sk2 , pk2 ) ← EKeygen2 (param)
m0 , m1 ← A(param, (pk1 , pk2 )); CT = EncryptT ((pk1 , pk2 ), m0 )
β ← A(param, (pk1 , pk2 ), CT )

We are interested in the event E: b0 = 1. By definition,
i

h

(A) = 1 .
Pr[E] = Pr ExpEind-cpa-0
T

G0

Game G1 : The simulator interacts with a challenger in Expind-cpa-0
(A), where b = 0. It
E1
thus first receives param, pk1 from that challenger, generates pk2 by himself to provide
(pkT = (pk1 , pk2 )) to the adversary. The latter sends back (m0 , m1 ) the simulators forwards to the challenger. It gets back C1 = Encrypt1 (pk1 , m0 ). It can compute CT =
Multiply(C1 , Encrypt2 (pk2 , 1)), to be sent to the adversary. This game is perfectly indistinguishable from the previous one: PrG1 [E] = PrG0 [E].
Game G2 : The simulator interacts with a challenger in ExpEind-cpa-1
(A), where b = 1:
1
Pr[E] − Pr[E] ≤ Advind-cpa
(t + 4 · tp + 4 · te ),
E1

G2

G1

where tp is the time for one pairing and te the time for one exponentiation.
Game G3 : In this final game, the simulator plays the role of the challenger in Expind-cpa-1
(A),
ET
where b = 1. This game is perfectly indistinguishable from the previous one: PrG3 [E] =
PrG2 [E].
h

i

One can note, that in this last game, PrG3 [E] = Pr Expind-cpa-1
(A) = 1 , hence
ET
Advind-cpa
(A) ≤ Advind-cpa
(t + 4 · tp + 4 · te ),
ET
E1
which concludes the proof, since it works exactly the same way for G2 .
We stress that the security of ET only requires the DDH assumption in one of the two groups,
and not the SXDH assumption (which means that the DDH assumption holds in both G1 and
G2 ).



40

3.2.3

3 - Decentralized Evaluation of Quadratic Polynomials on Encrypted Data

Decentralized Homomorphic Encryption

Our main motivation was a decentralized key generation and a distributed decryption in order
to be able to compute on encrypted data so that nobody can decrypt intermediate values but the
result can be provided in clear to a target user. We now show that our optimized construction
allows both decentralized key generation without a trusted dealer and distributed decryption.
They are both quite efficient. We also show this is possible to do proxy re-encryption in a
distributed way, without any leakage of information.
Decentralized Key Generation
In fact, a classical decentralized t-out-of-n threshold secret sharing allows to generate the shares
of a random element and it seems hard (if one expects efficiency) to use it to generate the shares
of a structured matrix, such as projections required in the generic construction, because its
elements are not independently random. In our specific construction, the secret keys in G1 and
G2 are now one scalar and one can perform a classical t-out-of-n threshold secret sharing: each
player i generates a random polynomial Pi of degree t−1 in Zp [X], privately sends xi,j = Pi (j) to
P
−P (0)
player j, and publishes gs i ; each player i then aggregates the values into ski = j xj,i = P (i),
P
for P = j Pj , which leads to a share of x = P (0), and the public key is the product of all the
public values.
Distributed Decryption
In order to decrypt Cs = (cs,1 , cs,2 ) in G1 or G2 , each player in a sub-set of t players sends its
i
contribution csk
s,2 , that can be multiplied with Lagrange coefficients as exponents to obtain the
−r
sk
mask cs,2 = pks . To decrypt CT = (cT,1 , cT,2 , cT,3 , cT,4 ) in GT , one can first use the shares of
sk1
sk2
sk1 ·sk2
1
sk1 to compute csk
. Under the
T,3 and cT,4 , and then the shares of sk2 to compute cT,2 and cT,4
sk1
i
DDH assumptions in G1 , G2 and GT , one can show that the intermediate values csk
s,2 , or cT,3 ,
sk2
sk1 ·sk2
1
csk
do not leak more than the decryption itself. Of course, classical verifiable
T,4 , cT,2 , and cT,4
secret sharing techniques can be used, for both the decentralized generation and the distributed
decryption. This can allow, with simple Schnorr-like proofs of Diffie-Hellman tuples, universal
verifiability.
Distributed Re-encryption
Besides a distributed decryption, when outsourcing some computations on private information,
a distributed authority may want to re-encrypt the encrypted result to a specific user, so that
the latter can get the result in clear, and nobody else. More precisely, we assume the input
data were encrypted under the keys pk1 , pk2 , and pkT = (pk1 , pk2 ), which leads, after quadratic
evaluations, to a resulting ciphertext under the key pkT , for which the distributed authorities,
knowing a t-out-of-n additive secret sharing (sk1,i , sk2,i )i of (sk1 , sk2 ), will re-encrypt under
PKT = (PK1 , PK2 ) for the target user. Of course, such a re-encryption can be performed using
multi-party computation, but we will show an efficient way to do it.
$
We start with the re-encryption of cs = (cs,1 = gsm · pkrs , cs,2 = gsr ): player i chooses ri0 ←
Zp ,
sk

r0

r0

computes αi = cs,2s,i · PKsi and βi = gsi , and outputs (αi , βi ). Then, anybody can compute, for
the appropriate Lagrange coefficients λi ’s,
Cs = (Cs,1 = cs,1 ×

Y λ
Y λ
0
0
0
αi i = gsm pkrs gsr·sks · PKrs = gsm · PKrs , Cs,2 =
βi i = gsr )

with r0 = λi ri0 , where the sum is on the t members available.
$
For s = T , given a ciphertext cT = (cT,1 , cT,2 , cT,3 , cT,4 ), player i chooses ui ←
Zp , and first
sk
computes and sends α3,i = cT,41,i · e(g1 , g2 )−ui . With a linear combination for the appropriate
P



3.2 - Optimized Version

41

Lagrange coefficients λi ’s, anybody can compute, α3 =
u=

P

Q λi
−u , with implicit
1
α3,i = csk
T,4 · e(g1 , g2 )

$
0 , r0 , r0 , r0 , v ←
λi ui . Then each player i chooses r11,i
Zp and computes
12,i 21,i 22,i i

sk

0

βi = e(g1 , g2 )r11,i +ui · e(PK1 , g2 )r22,i

0

sk

0

γi = e(g1 , PK2 )r12,i · e(g1 , g2 )r21,i +vi

α1,i = cT,22,i · e(PK1 , g2 )r21,i

0

0

α2,i = cT,31,i · e(g1 , PK2 )r11,i

0

sk

0

0

δi = e(g1 , g2 )r12,i +r22,i

α4,i = α3 2,i · e(PK1 , g2 )vi

Again, with linear combinations for the appropriate Lagrange coefficients λi ’s, anybody can
0 = P λ r 0 , for j, k ∈ {1, 2}, and v = P λ v :
compute, with rjk
i jk,i
i i
0

CT,2 = e(g1 , g2 )r11 +u · e(PK1 , g2 )r22

0

r11
1
α2 = csk
T,3 · e(g1 , PK2 )

0

CT,3 = e(g1 , PK2 )r12 · e(g1 , g2 )r21 +v

1 sk2
· e(g1 , PK2 )u · e(PK1 , g2 )v
α4 = csk
T,4

CT,4 = e(g1 , g2 )r12 +r22

r21
2
α1 = csk
T,2 · e(PK1 , g2 )

0

0

0

0

0

0

0

Then, CT,1 = cT,1 × α1 α2 α4 = e(g1 , g2 )m · e(g1 , PK2 )r11 +u · e(PK1 , g2 )r21 +v , so that the ciphertext
CT = (CT,1 , CT,2 , CT,3 , CT,4 ) is a re-encryption of cT under PKT .
For random scalars, the re-encryption algorithms (which is just a one-round protocol in G1
and G2 , but 2-round in GT ) generate new ciphertexts under appropriate keys that look perfectly
fresh. In addition, one can claim:
Theorem 24. The above distributed protocols for re-encryption do not leak additional information than the outputs of the non-distributed algorithms.
Proof. The goal of this proof is to show that the distributed protocol to re-encrypt a ciphertext
under PKs does not leak more information than a direct encryption under PKs . For s ∈ {1, 2},
one is given cs = Encrypts (m, pks ; r) = (cs,1 , cs,2 ) and Cs = Encrypts (m, PKs ; R) = (Cs,1 , Cs,2 ),
two ciphertexts of the same message m under pks and PKs respectively. One can then note that
sks
SKs
r
Cs,1 /cs,1 = PKR
s /pks = cs,2 /Cs,2 .
The Re-Encryption in Gs , for s ∈ {1, 2}.
Game G0 : In the first game, the simulator just receives cs = (cs,1 , cs,2 ), and plays the real
protocol using the t-out-of-n distributed keys (sks,i )i to provide the keys to the corrupted
sk

r0

r0

users and to generate the values αi = cs,2s,i · PKsi and βi = gsi , on behalf of the noncorrupted players. We assume that among t players, ` are honest and t − ` are corrupted.
The latter are assumed to receive the secret keys sks,i and to generate their own outputs
(αi , βi ). The view of the attacker consists of the set of all the honest (αi , βi ).
Game G1 : The simulator is now given cs = (cs,1 , cs,2 ) and Cs = (Cs,1 , Cs,2 ) that encrypt the
same message. We want, for the appropriate Lagrange coefficients λi
Cs,1 = cs,1 ·

Y λ
α i
i

Cs,2 =

Y λ
βi i .

$
Hence, the simulator can take, for all the honest players except the last one, ri0 ←
Zp to

sk

r0

r0

compute αi = cs,2s,i · PKsi and βi = gsi . For the last honest player, from all the honest-user
shares and corrupted-user shares, one sets
α` = (Cs,1 /cs,1 ·

Y −λ
αi i )1/λ`

β` = (Cs,2 ·

i6=`

Y −λ
βi i )1/λ` .
i6=`

0

0

r
s
Then, for the t players: αiλi = csk
βiλi = gsr , for r0 = λi ri0 and with the
s,2 · PKs and
P
implicit r`0 = (R − i6=` λi ri0 )/λ` . So r0 = R. The view of the attacker remains exactly the
same.

Q

Q

P



42

3 - Decentralized Evaluation of Quadratic Polynomials on Encrypted Data

Game G2 : In this game, the simulator also takes as input a Diffie-Hellman tuple (A = g r , B =
PKrs ) with (gs , PKs ): it first derives enough independent pairs (Ai , Bi ) = (gsxi · Ayi , PKxs i ·
B yi ), for random xi , yi , for all the non-corrupted players (excepted the last one), and
sk
computes αi = cs,2s,i · Bi , βi = Ai . Since (gs , PKs , A, B) is a Diffie-Hellman tuple, the view
is perfectly indistinguishable from the previous one.
Game G3 : In this game, the simulator now receives a random tuple (A, B), which makes all
the (Ai , Bi ) independent random pairs, the rest is unchanged: under the DDH assumption
in Gs , the view is computationally indistinguishable.
Game G4 : This is the final simulation, where all the honest shares (αi , βi ) are chosen at
random, except the last ones (α` , β` ) that are still computed as above to complete the
values using cs and Cs : the view is perfectly indistinguishable from the previous one and
does not leak information.
As a consequence, we have proven that there is a simulator (defined in the last game) that
produces a view indistinguishable from the real view, with just the input-output pairs. This
proves that nothing else leaks.
The Re-Encryption in GT .
The proof follows the same path as in the previous proof: one is given two ciphertexts cT =
EncryptT (m, (pk1 , pk2 ); r11 , r12 , r21 , r22 ) and CT = EncryptT (m, (PK1 , PK2 ); R11 , R12 , R21 , R22 )
of the same message m under pkT and PKT respectively. One needs to simulate all the
α1,i , α2,i , α3,i , α4,i , βi , γi , δi for all the non-corrupted players. Since cT and CT encrypt the same
message, and we want
CT,1 = cT,1 ·

Y λ
λi
λi
· α4,i
α1,ii · α2,i

CT,2 =

Y λ
β i
i

CT,3 =

Y λ
γ i
i

CT,4 =

Y λ
δ i
i

$
0 , r0 , r0 , r0 , u , v ←
the simulator can take, for all the honest players except the last one, r11,i
12,i 21,i 22,i i i
Zp to compute, in the first round:

sk

α3,i = cT,41,i · e(g1 , g2 )−ui

α3 =

$
α3,` ←
GT

Y λ
α i

3,i

and in the second round, for all but the last honest player
sk

0

βi = e(g1 , g2 )r11,i +ui · e(PK1 , g2 )r22,i

sk

0

γi = e(g1 , PK2 )r12,i · e(g1 , g2 )r21,i +vi

α1,i = cT,22,i · e(PK1 , g2 )r21,i
α2,i = cT,31,i · e(g1 , PK2 )r11,i
sk

α4,i = α3 2,i · e(PK1 , g2 )vi

0

0

0

0

0

0

δi = e(g1 , g2 )r12,i +r22,i

and for the last honest player:
$
α2,` ←
GT

β` = (CT,2 ×

Y −λ
βi i )1/λ`
i6=`

$

α4,` ← GT

γ` = (CT,3 ×

Y −λ
γi i )1/λ`
i6=`

δ` = (CT,4 ×

Y −λ
δ i )1/λ`
i

i6=`



3.3 - Applications

43

0
0
0
0
which implies implicit values for r11,`
, r12,`
, r21,`
, r22,`
, u` , v` because the above system is invertsk

ible, where X, Y , and Z are the constant values introduced by cT,ij , for some i, j:
1 0
log β`
0
 log γ   0  0 sk2
` 

  
 log δ   0  0 1

  
` 
λ` × 
= +
log α4,`  X  0 0

   
log α3,`   Y  0 0
1 0
Z
log α2,`




 



0
r11,`
0 −sk1
1
0


0
r12,`

1
0
0
−1




0

0
1
0
0  r21,` 



0
0
0
sk2,` −1 
r


22,`

0
0
1
0   u` 

0
0
0
0
v`





−λi 1/λ`
Then it is possible to set: α1,` = (CT,1 /(cT,1 · α2 α4 ) × i6=` α1,i
)
.
First, this is clear that the α3,i ’s do not leak anything as they contain random masks
e(g1 , g2 )−ui . Then, to prove that all the α1,i , α2,i , α4,i , βi , γi , δi do not leak information, one
can perform a similar proof as above for Gs , by using the DDH assumption in both G1 and G2 .
Indeed, each element is masked using a pair either (g2r , PKr2 ) or (g1r , PKr1 ), for some random r. If
one wants to have an indistinguishability under the SXDH assumption (and thus only one DDH
assumption in one group), one could add more masks. But this does not make sense to have
one key compromised and not the other one, for the same user. Hence, we tried to make the
re-encryption as efficient as possible.

Q

We stress that for the re-encryption in G1 or G2 , one just needs the DDH assumption in
this group Gs . But for the re-encryption in GT , one needs the DDH assumption in both G1
and G2 (the so-called SXDH assumption). We could rely on only one of the two, by adding
masking factors, but this does not really make sense for a user to have his private key sk1 being
compromised without sk2 (or the opposite).
In addition, zero-knowledge proofs can be provided to guarantee the re-encryption is honestly
sk
applied: they just consist in proofs of representations, when gs s,i are all made public, for
s ∈ {1, 2} and all indices i.

3.2.4

Efficiency

In the concrete case where we have n servers able to perform a distributed protocol as described
above, each of them has two scalars corresponding to a secret key for the encryption in G1 and
a secret key for the encryption in G2 . We recall that a ciphertext, in G1 or G2 , is composed of
two group elements, and a ciphertext in GT is composed of four group elements. A recipient,
that wants the result of either a decryption or a re-encryption with the help of t servers, has to
perform a few exponentiations. The table below details the number of exponentiations for each
player involved in the distributed protocols.
distributed decryption
distributed re-encryption

3.3

in
in
in
in

G1 /G2
GT
G1 /G2
GT

per server
1
4
3
13

recipient
t
4t
t
7t

Applications

Boneh, Goh, and Nissim proposed two main applications to secure evaluation of quadratic polynomials: private information retrieval schemes (PIR) and electronic voting protocols. However,
the use of our decentralized scheme for electronic voting is much more preferable than the BGN



44

3 - Decentralized Evaluation of Quadratic Polynomials on Encrypted Data

scheme, as there is no way to trust any dealer in such a use-case. We propose two more applications that are related to the group testing and the consistency model in machine learning.
Our applications are particularly useful in practice in a decentralized setting, as they deal with
sensitive data. Interestingly, the use of distributed evaluation for quadratic polynomials in these
applications is highly non-trivial and will be explained in the last section.

3.3.1

Encryption for Boolean Formulae

In this part, we detail the specific case of the evaluation of 2-DNF.
First, as explained in [BGN05], a way to guarantee the ciphertexts are encryption of inputs
in {0, 1}, the verification can be done with our scheme (or the one of BGN or Freeman) with the
additional term Addj (Multiply(Cxj , Add(Cxj , C−1 )), multiplied by a random constant, so that it
adds zero if inputs are correct, or it adds a random value otherwise. This introduces a quadratic
term, just for the verification. This is at no extra cost if the Boolean formula is already quadratic,
which will be the case of our applications.
Every Boolean formula can be expressed as a disjunction of conjunctive clauses (an OR of
ANDs). This form is called disjunctive normal form (DNF) and, more precisely, k-DNF when
each clause contains at most k literals. Thus, a 2-DNF formula over the variables x1 , . . . , xn ∈
{0, 1} is of the form
m
_

(`i,1 ∧ `i,2 ) with `i,1 , `i,2 ∈ {x1 , x1 , . . . , xn , xn }.

i=1

The conversion of 2-DNF formulae into multivariate polynomials of total degree 2 is simple:
Pm
W
given Φ(x1 , . . . , xn ) = m
i=1 (yi,1 × yi,2 )
i=1 (`i,1 ∧ `i,2 ) a 2-DNF formula, define φ(x1 , . . . , xn ) =
where yi,j = `i,j if `i,j ∈ {x1 , . . . , xn } or yi,j = (1 − `i,j ) otherwise. In this conversion, a true
literal is replaced by 1, and a false literal by 0. Then, an OR is converted into an addition, and an
AND is converted into a multiplication. A NOT is just (1 − x) when x ∈ {0, 1}. φ(x1 , . . . , xn )
is the multivariate polynomial of degree 2 corresponding to Φ(x1 , . . . , xn ). As just said, this
conversion works if for the inputs, we consider 1 ∈ Zp as true and 0 ∈ Zp as false, but for the
output, 0 ∈ Zp is still considered as false whereas any other non-zero value is considered as true.
To evaluate the 2-DNF in an encrypted manner, we propose to encrypt the data and to
calculate the quadratic polynomial corresponding to the 2-DNF as seen above by performing
Adds and Multiplys. Because the result of the 2-DNF is a Boolean, when a decryption is performed, if the result is equal to 0, one can consider it corresponds to the 0-bit (false) and else,
it corresponds to the 1-bit (true).
Hence, when encrypting bits, we propose two different encodings before encryption, depending on the situation: either the 0-bit (false) is encoded by 0 ∈ Zp and the 1-bit (true) is encoded
by any non-zero integer of Z∗p ; or the 0-bit (false) is encoded by 0 ∈ Zp and the 1-bit (true) is
encoded by 1 ∈ Zp . With this second solution, it offers the possibility to perform one NOT on
the data before Adds and Multiplys by the operation 1 − x. However, one has to be aware of
making Randomize before decryption to mask the operations but also the input data in some
situations: for example, if an Add is performed between three 1s, the result 3 leaks information
and needs to be randomized.
Because one just wants to know whether the result is equal to 0 or the result is different
from 0, we do not need to compute the logarithm: we can decrypt by just checking whether
sk2
sk1
sk1 ·sk2
s
cs,1 · csk
= 1T ).
s,2 = 1s or not (for s = T , if cT,1 · cT,2 · cT,3 · cT,4

3.3.2

Group Testing on Encrypted Data

In this application we assume that a hospital collects some blood samples and wants to check
which samples are positive or negative to a specific test. Group testing [Dor43] is an efficient



3.3 - Applications

45

technique to detect positive samples with fewer tests in the case the proportion of positive cases
is small. The technique consists in mixing some samples, and to perform tests on fewer mixes.
More precisely, we denote X = (xij ) the matrix of the mixes: xij = 1 if the i-th sample is in
the j-th mix, otherwise xij = 0. The hospital then sends the (blood) mixes to a laboratory for
testing them: we denote yj the result of the test on the j-th mix.
If a patient (its sample) is in a mix with a negative result, he is negative (not infected). If
a patient (its sample) is in a mix with a positive result, we cannot say anything. However, for
well-chosen parameters, if a patient is not declared negative, he is likely positive. Thus, for a
patient i, the formula that we want to evaluate is ¬Fi (X, y), which means the patient’s test is
W
positive (infected) or not, for Fi (X, y) = j (xij ∧ ¬yj ). The latter is indeed true if there is a mix
containing a i-th sample for which the test is negative, and this should claim patient i negative
(false). The matrix X of the samples needs to be encrypted since the patient does not want the
laboratory to know his result. Because of the sensitiveness of the data, the result of the tests
needs to be encrypted too. But the patient will need access to his own result.
In this scenario, the hospital computes for all i, j, Cxij ∈ G21 , the encryption of xij , and
the laboratory computes for all j, Cyj ∈ G22 , the encryption of yj . Then, they both send the
ciphertexts to an external database. With our homomorphic encryption scheme, to compute
¬Fi , we can publicly evaluate the following formula: Ci = Randomize(Addj (Multiply(Cxij , Cyj )).
Anybody can publicly verify the computations and if it is correct, a pool of controllers perform
a distributed re-encryption of the result of patient i under his key PKi . In this way, the patient
cannot decrypt the database or the result of the tests directly, but only with the help of a pool
of controller. The goal of the controllers is to limit access to the specific users only. Under
an assumption about the collusions among the controllers, nobody excepted the users will have
access to their own results.

3.3.3

Consistency Model on Encrypted Data

Another famous application is machine learning, where we have some trainers that fill a database
and users who want to know a function of their inputs and the database. For privacy reasons,
trainers do not want the users to learn the training set, and users do not want the trainers to
learn their inputs. As in the previous case, we will involve a pool of distributed controllers to
limit decryptions, but the controllers should not learn anything either.
Suppose a very large network of nodes in which some combinations should be avoided as
they would result to failures. When a failure happens, the combination is stored in a database.
And before applying a given combination, one can check whether it will likely lead to a failure,
and then change. For example, the network can be a group of people where each of them can
receive data. But, for some specific reasons, if a subgroup A of people is knowing a file a, the
subgroup B must not have the knowledge of a file b. This case of application can be viewed as
a consistency model [Sch14] which can be formally described as: the input is a vector of states
(each being either true or false), and if in the database all the j-th states are true a new input
needs to have its j-th state to be true; if all the j-th states in the database are false, the new
input needs to have its j-th state to be false; otherwise the j-th state can be either true or false.
As a consequence, if we denote the i-th element of the database as a vector xi = (xij )j and
the user’s vector by y = (yj ), that vector y is said consistent with the database if the following
predicate is true:

^
(∧i xij ∧ yj ) ∨ (∧i xij ∧ y j ) ∨ (∨i xij ∧ ∨i xij ) .
j

Let Xj = ∧i xij , Yj = ∧i xij , and Zj = ∨i xij ∧ ∨i xij . We define F(x1 , . . . , xm , y) the formula we
want to compute on the encrypted inputs:
F(x1 , . . . , xm , y) =

^
j



(Xj ∧ yj ) ∨ (Yj ∧ y j ) ∨ Zj .



46

3 - Decentralized Evaluation of Quadratic Polynomials on Encrypted Data

By definition, Xj , Yj , and Zj are exclusive, as Xj means the literals are all true, Yj means the
literals are all false, and Zj means there are both true and false literals. So we have: Xj ∨Zj = Yj
and Yj ∨ Zj = Xj . Thus, we have
¬F(x1 , . . . , xm , y) =

_

((Yj ∨ yj ) ∧ (Xj ∨ yj )) .

j

Now, we see how the encryption and the decryption is performed to obtain the result of an
evaluation. First, we explain how the trainers can update the database, when adding a vector
xm . The values Xj are updated into Xj0 as
Xj0

=

m
^
i=1

xij =

m−1
^

(

xij ∧ xmj =

i=1

Xj =
false

Vm−1
i=1

xij

if xmj = true
otherwise

which is easy to compute for the trainer, since it knows xm in clear, even if Xj is encrypted:
the trainer can dynamically compute CXj the encryption of Xj , when adding a new line in the
database, by just making a Randomize if xmj is true (to keep the value Xj unchanged), or by
replacing the value by a fresh encryption of 0 otherwise. Similarly, the trainer can update CYj ,
the encryption of Yj . On the user-side, he can compute Cyj and Cyj the encryptions of his inputs
yj and yj respectively. Then, everyone and thus the controllers can compute:






Cj = Randomize Addj Multiply(Add(CYj , Cyj ), Add(CXj , Cyj ))

.

Because of the Multiply, CYj and Cyj must be ciphertexts in G1 , while CXj and Cyj must be
ciphertexts in G2 . To allow a control of the final decryption, a pool of controllers re-encrypt for
the user in a distributed way.



Chapter

4

Linearly-Homomorphic
Signatures

This chapter introduces the building blocks of the two following ones: the Linearly-Homomorphic
Signatures. For readability, it presents results coming from the two papers [HPP20, HP20].

Chapter content
4.1
4.2
4.3
4.4
4.5

Definition, Properties and Security . . . . . .
Our One-Time LH-Sign Scheme . . . . . . . .
FSH LH-Sign Scheme . . . . . . . . . . . . . .
Square Diffie-Hellman . . . . . . . . . . . . . .
SqDH LH-Sign Scheme . . . . . . . . . . . . . .
4.5.1 A First Generic Conversion . . . . . . . . . .
4.5.2 A Second Generic Conversion . . . . . . . . .

.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.

. . . . .
. . . . .
. . . . .
. . . . .
. . . . .
. . . . . .
. . . . . .

47
50
51
53
56
56
57

The notion of homomorphic signatures dates back to [JMSW02], with notions in [ABC+ 12],
but the linearly-homomorphic signatures, that allow to sign vector sub-spaces, were introduced
in [BFKW09], with several follow-up by Boneh and Freeman [BF11b, BF11a] and formal security
definitions in [Fre12].
We begin in a first section with the formal definition of linearly-homomorphic signature
scheme, then, we will introduce a new property for linearly-homomorphic signature scheme:
the tag randomizability. It will be the key element in our use-cases. Finally, we provide the
security definition, so-called unforgeability in case of signatures. In fact in the Preliminaries
we presented a weaker version of LH-Sign scheme without any tag called One-Time. The first
construction proposed in Section 4.2 is a One-Time linearly-homomorphic signature while the
two other constructions in Section 4.3 and in Section 4.4 are full fledged (not one-time). In the
last section 4.5, we provide two generic conversions from a One-Time scheme to a full fledged
one.

4.1

Definition, Properties and Security

Our definition of linearly-homomorphic signature scheme is inspired by the formal definition
from Libert et al. [LPJY13], but with a possible private key associated to a tag:
Definition 25 — Linearly-Homomorphic Signature Scheme (LH-Sign)
A linearly-homomorphic signature scheme with messages in M ∈ Gn , for a cyclic group
(G, ×) of prime order p, some n ∈ poly(κ), and some tag set T , consists of the seven
algorithms (Setup, SKeygen, NewTag, VerifTag, Sign, MultiplySign, VerifSign):
Setup(1κ ): Given a security parameter κ, it outputs the global parameter param, which
includes the tag space T ;
SKeygen(param, n): Given a public parameter param and an integer n, it outputs a key



48

4 - Linearly-Homomorphic Signatures
pair (sk, vk). We will assume that vk implicitly contains param and sk implicitly
contains vk;
NewTag(sk): Given a signing key sk, it outputs a tag τ and its associated secret key τ̃ ;
VerifTag(vk, τ ): Given a verification key vk and a tag τ , it outputs 1 if the tag is valid
and 0 otherwise;
Sign(sk, τ̃ , M ): Given a signing key, a secret key tag τ̃ and a vector-message M = (Mi )i ∈
Gn , it outputs the signature σ under the tag τ ;
MultiplySign(vk, τ, (ωi , M i , σi )`i=1 ): Given a public key vk, a tag τ and ` tuples of weights
ωi ∈ Zp and signed messages M i in σi , it outputs a signature σ on the vector
Q
M = `i=1 M ωi i under the tag τ ;
VerifSign(vk, τ, M , σ): Given a verification key vk, a tag τ , a vector-message M and a
signature σ, it outputs 1 if VerifTag(vk, τ ) = 1 and σ is also valid relative to vk and
τ , and 0 otherwise.

Note that we talk about linearly homomorphic signature with combinations component-wise
in the exponents as we will consider a multiplicative group (G, ×) and messages directly in G
instead of Zp . Moreover, this definition is more related to the notion of linearly homomorphic structure preserving signatures as the evaluated function is not provided in input of the
verification algorithm unlike definitions as in [GVW15, CFN18] where the evaluated function
matters.
The tag in MultiplySign allows linear combinations of signatures under the same tag but
excludes any operation between signatures under different tags. The latter exclusion will
be formalized by the unforgeability. However, the former property is the correctness: for
any keys (sk, vk) ← Keygen(param, n), for any tags (τ, τ̃ ) ← NewTag(sk), if for i = 1, . . . , `,
σi = Sign(sk, τ̃ , M i ) are valid signatures and σ = MultiplySign(vk, τ, {ωi , M i , σi }`i=1 ) from some
scalars ωi , then both
VerifTag(vk, τ ) = 1

VerifSign(vk, τ, M , σ) = 1.

Our definition includes, but is more relaxed than, [LPJY13] as we allow a secret key associated to the tag, hence the NewTag algorithm: in such a case, the signer can only sign a
message on a tag he generated himself. When there is no secret associated to the tag, one can
actually consider that τ̃ = τ is enough to generate the signature (in addition to sk). Whereas the
MultiplySign algorithm generates a signature under the same tag, we do not require to keep the
same tag in the unforgeability notion below, this will allow our tag randomizability. However,
we expect only signatures on linear combinations of messages already signed under a same tag,
as we will formalize in the security notion.
Homomorphic Properties
From the definition of linearly homomorphic signature, we have the following property:
Property 26 (Message Homomorphism). Given several vector-messages with their signatures,
MultiplySign generates the signature of any linear combination of the vector-messages.
In addition, one can introduce a new algorithm RandTag associated to a new property for
linearly-homomorphic signature schemes:



4.1 - Definition, Properties and Security

49

RandTag(vk, τ, M , σ): Given a verification key vk, a tag τ and a signature σ on a vectormessage M = (Mi )i ∈ Gn , it outputs a new tag τ 0 and σ 0 a new signature on the
new tag τ 0 of M still valid under the verification key vk.
Property 27 (Tag Randomizability). For any vector-message M = (Mi )i ∈ Gn , key pair
(sk, vk) ← SKeygen(param, n), tag (τ̃ , τ ) ← NewTag(sk), valid signature σ ← Sign(sk, τ̃ , M ),
and (τ 0 , σ 0 ) ← RandTag(vk, τ, M , σ) the two following distributions are indistinguishable:
D0 = {(vk, τ, M , σ)}

D1 = {(vk, τ 0 , M , σ 0 )}.

Libert et al. [LPJY13] proposed a LH-Sign construction which security relies on the Simultaneous Double Pairing assumption, which is implied by the linear assumption in the symmetric
case. In our use cases, the tag will be linked to the identity of a user. Hence, the tags need
to be randomizable to provide privacy. However, we do not know how to build it in the standard model. Thus, we choose to focus on constructions secure in the generic bilinear group
model [Sho97, BBG05, Boy08].
Notations and Constraints
Since we will mainly work on sub-vector spaces of dimension 2 (in a larger vector space), we
will denote σ = Sign(sk, (M , M 0 )), with the verification check VerifSign(vk, σ, (M , M 0 )) = 1, a
signature that allows to derive a valid σ 0 for any linear combinations of M and M 0 . In general,
σ can be the concatenation of σ1 = Sign(sk, M ) and σ2 = Sign(sk, M 0 ), but some joint random
coins may be needed, and some common elements can be merged (the tag).
We will also be interested in signing affine spaces: given a signature on M and N , one
wants to limit signatures on M × N α and 1 × N β . This is possible by expanding the messages
with one more component: for M = (g, M ) and N = (1, N ), linear combinations are of the
form (g α , M α N β ). By imposing the first component to be g, one limits to α = 1, and thus to
β
(g, M N β ) = M × N , while by imposing the first component to be 1, one limits to α = 0, and
β
thus to (1, N β ) = N .
Unforgeability
Whereas linear combinations are possible under the same tag, other combinations (non-linear
or under different tags) should not be possible. This is the unforgeability notion.
Definition 28 — Unforgeability for LH-Sign
For a LH-Sign scheme with messages in Gn , for any adversary A that, given tags and
signatures on messages (M i )i under tags (τi )i both of its choice (for Chosen-Message
Attacks), outputs a valid tuple (vk, τ, M , σ) with τ ∈ T , there must exist (ωi )i∈Iτ 0 , where
Iτ 0 is the set of messages already signed under some tag τ 0 ∈ {τi }i , such that M =
Q
ωi
i∈Iτ 0 M i with overwhelming probability.
Again, because our version is relaxed compared to [LPJY13], we do not exclude the adversary
to be able to generate valid signatures under new tags. The linear-homomorphism for signatures,
also known as signatures on vector-spaces, requires that the adversary cannot generate a valid
signature on a message outside the vector spaces spanned by the already signed messages. Tags
are just a way to keep together vectors that define vector spaces. The adversary can rename a
vector space with another tag, this is not a security issue. On the opposite, we will exploit this
feature for unlinkability with the additional randomizability property on tags.



50

4 - Linearly-Homomorphic Signatures

4.2

Our One-Time LH-Sign Scheme

As in [LPJY13] and presented in the Example 12, we can consider a weaker notion of linearlyhomomorphic signature: a one-time linearly-homomorphic signature (OT-LH-Sign), where the
set of tags is a singleton T = {}. In this case, the algorithms NewTag and VerifTag can be
dropped, as well as the τ and τ̃ .
We will consider a simplified variant of one-time linearly-homomorphic signature of Libert
et al. [LPJY13] that can only be proven in the generic bilinear group model even if their scheme
was originally built in the standard model.
Our One-Time linearly-homomorphic signature scheme with messages in M ∈ Gn1 , for some
n ∈ poly(κ) consists of the five algorithms (Setup, SKeygen, Sign, MultiplySign, VerifSign):
Our One-Time LH-Sign Scheme
Given a security parameter κ, let (G1 , G2 , GT , p, g, g, e) be an asymmetric bilinear setting, where g and g are random generators of G1 and G2 respectively. We
set param = (G1 , G2 , GT , p, g, g, e);

Setup(1κ ):

$
SKeygen(param, n): Given the public parameters param, one randomly chooses ski = si ←
Zp , for i = 1, . . . , n, which defines the signing key sk = (ski )ni=1 , and the verification
key vk = (gi )ni=0 for gi = gsi and g0 = g;

Sign(sk, M = (Mi )i ): Given a signing key sk = (si )i and a vector-message M = (Mi )i ∈
Q
Gn1 , one sets σ = ni=1 Misi ∈ G1 ;
MultiplySign(vk, (ωi , M i , σi )`i=1 ): Given a verification key and ` tuples of weights ωi ∈ Zp
Q
and signed messages M i in σi , it outputs σ = σiωi ;
VerifSign(vk, M = (Mi )i , σ): Given a verification key vk, a vector-message M , and a sigQ
nature σ, one checks whether the equality e(σ, g0 ) = ni=1 e(Mi , gi ) holds or not.
If a message-signature is valid for a verification key vk, then it is also valid for the verification
Q
Q
key vk0 = vkα , for any α, as e(σ, g0 ) = ni=1 e(Mi , gi ) implies e(σ, gα0 ) = ni=1 e(Mi , gαi ).
However, for two different verification keys vk and vk0 , and signatures σ and σ 0 of M :
Qn
Qn
α
0 β
α
0 0β
α
0β
00
α 0 β is a valid
i=1 e(Mi , gi ) · e(Mi , gi ) = e(σ, g0 ) · e(σ , g0 ), so σ = σ σ
i=1 e(Mi , gi · gi ) =
β
signature of M under vk00 = vkα vk0 if g00 = g0 .
Hence, one can ask for a similar property on the keys than on the messages:
Property 29 (Key Homomorphism). Given a vector-message with signatures under several
keys, it is possible to generate the signature of this vector-message under any linear combination
of the keys.
MultiplyKey(M , (ωi , vki , σi )`i=1 ): Given a message M and ` tuples of weights ωi ∈ Zp and
signatures σi of M under vki , it outputs a signature σ of M under the verification
Q
key vk = `i=1 vkωi i .
Our scheme only supports the relaxed version:
Property 30 (Weak Key Homomorphism). Given a vector-message with signatures under several keys (with a specific restriction, as a common g0 in our case), it is possible to generate the
signature of this vector-message under any linear combination of the keys.
Eventually, one needs to prove the unforgeability of our scheme:



4.3 - FSH LH-Sign Scheme

51

Theorem 31 (Unforgeability). Let us consider an adversary A in the generic bilinear group
model. Given valid pairs (M j , σj )j under a verification key vk (M i ’s possibly of adversary’s
choice, for Chosen-Message Attacks), when A produces a new valid pair (M , σ) under the same
Q
α
verification key vk, there exist (αj )j such that M = j M j j .
Proof. The adversary A is given (M j = (Mj,i )i , σj )j which contains group elements in G1 , as
well as the verification key vk = (gk )k in G2 . Note that in the generic bilinear group model,
programmability of the encoding allows to simulate the signatures for chosen messages, which
provides the security against Chosen-Message Attacks.
For any combination query, the simulator will consider the input elements as independent
variables Xj,i , Vj , and Sk to formally represent the discrete logarithms of Mj,i and σi in basis g,
and gk in basis g0 = g. As usual, any new element can be seen as a multivariate polynomial in
these variables, of degree maximal 2 (when there is a mix between G1 and G2 group elements).
If two elements correspond to the same polynomial, they are definitely equal, and the simulator
will provide the same representation. If two elements correspond to different polynomials, the
simulator will provide random independent representations. The view of the adversary remains
unchanged unless the actual instantiations would make the representations equal: they would
be equal with probability at most 2/p, when the variables are set to random values. After N
combination queries, we have at most N 2 /2 pairs of different polynomials that might lead to
a collision for a random setting with probability less than N 2 /p. Excluding such collisions,
we can thus consider the polynomial representations only, denoted ∼. Then, for the output
(M = (Mk )k , σ), one knows αk,j,i , βk,j , γi,j , δj , such that:
Mk ∼

X

αk,j,i Xj,i +

j,i

X

σ∼

βk,j Vj

X

j

γj,i Xj,i +

X

j,i

δ j Vj .

j

As ((Mj,i )i , σj )j and ((Mk )k , σ), are valid input and output pairs, we have the following relations
between polynomials:
Vj =

X

X

Xj,i Si

i

γj,i Xj,i +

j,i

X

δj Vj =

X

=

X

j



X
X

αk,j,i Xj,i +
βk,j Vj  Sk
j,i

k

j

αk,j,i Xj,i Sk +

k,j,i

X

βk,j Vj Sk

k,j

Hence, the two polynomials are equal:
X
j,i

γj,i Xj,i +

(δj − αi,j,i )Xj,i Si =

X

X

j,i

k6=i,j,i

αk,j,i Xj,i Sk +

X

βk,j Vj Sk

k,j

which leads, for all i, j, to γj,i = 0 and δj = αi,j,i , and for k 6= i, αk,j,i = 0 and βk,j = 0. Hence,
P
P
Q
δ
Mk ∼ j δj Xj,k and σ ∼ j δj Vj , which means that we have (δj )j such that Mk = j Mj,kj and
σ=

4.3

Q

δ

j

σj j .

FSH LH-Sign Scheme

In [LPJY13], the authors proposed a full-fledged LH-Sign by adding a public tag during the
signature. In our constructions, tags will be related to identities of users, and so, some kind of
randomizability will be required for anonymity, which is not possible with their scheme. Instead,
we will consider the scheme proposed in [FHS19], which is a full-fledged LH-Sign version of our
previous scheme. We can describe it as follows, using our notations:



52

4 - Linearly-Homomorphic Signatures
FSH LH-Sign Scheme
Setup(1κ ): Given a security parameter κ, let (G1 , G2 , GT , p, g, g, e) be an asymmetric bilinear setting, where g and g are random generators of G1 and G2 respectively. The
set of tags is T = G1 × G2 . We then define param = (G1 , G2 , GT , p, g, g, e; T );
$
SKeygen(param, n): Given the public parameters param, one randomly chooses ski = si ←
Zp , for i = 1, . . . , n, which defines the signing key sk = (ski )i , and the verification
key vk = (gi )ni=0 for gi = gsi and g0 = g;

1/R

$
NewTag(sk): It chooses a random scalar R ←
Zp and sets τ = (τ1 = g 1/R , τ2 = g0
τ̃ = R;

) and

VerifTag(vk, τ ): Given a verification key vk = (gi )ni=0 and a tag τ = (τ1 , τ2 ), it checks
whether e(τ1 , g0 ) = e(g, τ2 ) holds or not;
Sign(sk, τ̃ , M = (Mi )i ): Given a signing key sk = (si )i and a vector-message M = (Mi )i ∈
Q
Gn1 , together with some secret tag τ̃ , one sets σ = ( i Misi )τ̃ ;
MultiplySign(vk, τ, (ωi , M i , σi )`i=1 ): Given a verification key vk, a tag τ and ` tuples of
Q
weights ωi ∈ Zp and signed messages M i in σi , it outputs σ = σiωi ;
VerifSign(vk, τ, M = (Mi )i , σ): Given a verification key vk = (gi )i , a vector-message M =
(Mi )i , and a signature σ under the tag τ = (τ1 , τ2 ), one checks if the equalities
Q
e(σ, τ2 ) = ni=1 e(Mi , gi ) and e(τ1 , g0 ) = e(g, τ2 ) hold or not.
When the secret keys for tags are all privately and randomly chosen, independently for each
signature, unforgeability has been proven in [FHS19], under Chosen-Message Attacks, in the
generic bilinear group model. The intuition is the following: first, under the Knowledge of
Exponent Assumption [Dam92, HT98, Gro10], from a new pair (τ1 , τ2 ), on the input of either
(g, g) or any other honestly generated pair (g, g0 ), one can extract the common exponent 1/R
in the two components. Then, one can see σ as the signature with the secret key (Rsi )i , with
1/R
the generator g0 , instead of g0 in the previous construction.
However, if one knows two signatures σ and σ 0 on M and M 0 respectively, under the same
tag τ = (τ1 , τ2 ) with private key τ̃ , and the same key vk, then σ α σ 0 β is a valid signature of
M α M 0 β , still under the same tag τ and the same key vk: this is thus a LH-Sign, where one can
control the families of messages that can be combined.
Our LH-Sign has the tag randomizability property, with the algorithm RandTag defined by:
RandTag(vk, τ, M , σ): Given a verification key vk, a tag τ = (τ1 , τ2 ) and a signature σ on
1/µ 1/µ
a vector-message M = (Mi )i ∈ Gn1 , it chooses µ ∈ Z∗p and outputs τ 0 = (τ1 , τ2 )
and adapts σ 0 = σ µ .
Indeed, from a signature σ on M under the tag τ = (τ1 , τ2 ) for the key vk, σ 0 = σ µ is a new
1/µ 1/µ
signature on M for the same key vk under the tag τ 0 = (τ1 , τ2 ), perfectly unlinkable to τ ,
as this is a new random Diffie-Hellman tuple in basis (g, g0 ) with τ̃ 0 = µτ̃ , for g0 in vk.
As already explained above, we will essentially work on sub-vector spaces of dimension 2:
we will thus denote σ = (σ1 , σ2 ) = Sign(sk, τ̃ , (M , M 0 )), under the tag τ = (τ1 , τ2 ), where
σ1 = Sign(sk, τ̃ , M ) and σ2 = Sign(sk, τ̃ , M 0 ), for a common private key R = τ̃ which led to
τ = (τ1 , τ2 ).



4.4 - Square Diffie-Hellman

4.4

53

Square Diffie-Hellman

This section is a preamble to the next one in which we will propose a new construction of
LH-Sign scheme. We define here the useful building blocks: the Square Diffie-Hellman tuples,
an extractability assumption that holds in the generic bilinear group model and two important
theorems using Square Diffie-Hellman tuples.
Assumptions
We first begin be presenting the needed assumptions:
Definition 32 — Square Discrete Logarithm (SDL) Assumption
2
In a group G of prime order p, it states that for any generator g, given y = g x and z = g x ,
it is computationally hard to recover x.
Definition 33 — Decisional Square Diffie-Hellman (DSqDH) Assumption
In a group G of prime order p, it states that for any generator g, the two following
distributions are computationally indistinguishable:
2

$
Dsqdh (g) = {(g, g x , g x ), x ←
Zp }

$
D$3 (g) = {(g, g x , g y ), x, y ←
Zp }.

It is worth noticing that the DSqDH Assumption implies the SDL Assumption: if one can
2
break SDL, from g, g x , g x , one can compute x and thus break DSqDH.
A fortiori, this implies indistinguishability between the two distributions
2

$
$
Dsqdh (G) = {(g, g x , g x ), g ←
G, x ←
Zp }

$
D$3 (G) = {(g1 , g2 , g3 ) ←
G3 }.

Below, for proofs, we will need to explicitly extract linear combinations, hence the additional
assumption that holds in the generic bilinear group model:
Definition 34 — Extractability Assumption
The extractability assumption states that given n vectors (M j = (Mj,i )i )j , for any adQ
α
versary that produces a new vector M = (Mi )i such that M = j M j j , there exists an
extractor that outputs (αj )j .

Proof for Square Diffie-Hellman Tuples
2

As an SqDH-tuple (τ1 = h, τ2 = hτ̃ , τ3 = hτ̃ ) ∈ G31 is a Diffie-Hellman tuple (τ1 , τ2 , τ2 , τ3 ), one
can use a Schnorr-like proof:
$
• The prover chooses a random scalar r ←
Zp , and sets and sends U ← τ1r , V ← τ2r ;
$
• The verifier chooses a random challenge e ←
{0, 1}κ ;

• The prover sends back the response s = eτ̃ + r mod p;
• The verifier checks whether both τ1s = τ2e × U and τ2s = τ3e × V .
This provides an interactive zero-knowledge proof of knowledge of the witness τ̃ that (τ1 , τ2 , τ3 )
is an SqDH-tuple.



54

4 - Linearly-Homomorphic Signatures

Groth-Sahai Proof for Square Diffie-Hellman Tuples. If you just need a proof of validity
of the tuple, this is possible, using the Groth-Sahai methodology [GS08], to provide a noninteractive proof of Square Diffie-Hellman tuple: in the asymmetric pairing setting, one sets a
reference string (v1,1 , v1,2 , v2,1 , v2,2 ) ∈ G42 , such that (v1,1 , v1,2 , v2,1 , v2,2 ) is a Diffie-Hellman tuple.
2
Given a Square Diffie-Hellman tuple (τ1 = h, τ2 = hτ̃ , τ3 = hτ̃ ) ∈ G31 , one first commits τ̃ :
$
Com = (c = vτ̃2,1 vµ1,1 , d = vτ̃2,2 gτ̃ vµ1,2 ), for a random µ ←
Zp , and one sets π1 = τ1µ and π2 = τ2µ ,
which satisfy
e(τ1 , c) = e(τ2 , v2,1 ) · e(π1 , v1,1 )

e(τ1 , d) = e(τ2 , v2,2 · g) · e(π1 , v1,2 )

e(τ2 , c) = e(τ3 , v2,1 ) · e(π2 , v1,1 )

e(τ2 , d) = e(τ3 , v2,2 · g) · e(π2 , v1,2 )

The proof proof = (c, d, π1 , π2 ), when it satisfies the above relations, guarantees that (τ1 , τ2 , τ3 )
is a Square Diffie-Hellman tuple. This proof is furthermore zero-knowledge, under the DDH
assumption in G2 : by switching (v1,1 , v1,2 , v2,1 , g × v2,2 ) into a Diffie-Hellman tuple, one can
simulate the proof using the trapdoor in the reference string.
Moreover, one can apply a batch verification [BFI+ 10], and pack them in a unique one with
$
Zp :
random scalars x1,1 , x1,2 , x2,1 , x2,2 ←
x

x

x

x

x

x

x

x

x

x

1,1
1,2 x1,2
1,1
1,2
e(τ1 2,1 τ2 2,2 , cx1,1 dx1,2 ) = e(τ2 2,1 τ3 2,2 , v2,1
v2,2
g ) × e(π1 2,1 π2 2,2 , v1,1
v1,2
)

One thus just has to compute 13 exponentiations and 3 pairing evaluations for the verification,
instead of 12 pairing evaluations.
In addition, the proof can be updated using ρτ →τ 0 such that τ 0 = τ ρτ →τ 0 and randomized using
0
0
0
0
ρ
ρ
0
0
$
µ0 ←
Zp : Com0 = (c0 = c · vµ1,1 , d0 = d · vµ1,2 ), in addition π10 = π1 τ →τ · τ10 µ and π20 = π2 τ →τ · τ20 µ .
Restricted Combinations of Vectors
When one wants to avoid any combination, and just allow to convert a signature of M into
a signature of M α , while they are all of the same format, one can use expanded vectors (as
in Section 4.1), by concatenating a vector that satisfies this restriction: from multiple distinct
w2

(non-trivial) Square Diffie-Hellman tuples (gi , giwi , gi i ), a linear combination that is also a Square
Diffie-Hellman tuple cannot use more than one input tuple. We prove it in two different cases:
with random and independent bases gi , but possibly public wi ’s, or with a common basis gi = g,
but secret wi ’s.
We stress that in the first theorem, the wi ’s are random and public (assumed distinct), but
the bases gi ’s are truly randomly and independently generated.
i
Theorem 35. Given n valid Square Diffie-Hellman tuples (gi , ai = giwi , bi = aw
i ), with wi , for
Q
Q
$
$
random gi ←
G∗ and wi ←
Z∗p , outputting (αi )i=1,...,n such that (G = giαi , A = aαi i , B =
Q αi
bi ) is a valid Square Diffie-Hellman, with at least two non-zero coefficients αi , is computationally hard under the DL assumption.

Intuitively, from Square Diffie-Hellman tuples where the exponents are known but random
and the bases are also known and random, it is impossible to construct a new Square DiffieHellman tuple melting the exponents.
Proof. Up to a guess, which is correct with probability greater than 1/n2 , we can assume that
α1 , α2 6= 0. We are given a discrete logarithm challenge Z, in basis g. We will embed it in either
g1 or g2 , by randomly choosing a bit b:
$
• if b = 0: set X = Z, and randomly choose v ←
Zp and set Y = g v
$
• if b = 1: set Y = Z, and randomly choose u ←
Zp and set X = g u



4.4 - Square Diffie-Hellman

55

We set g1 ← X(= g u ), g2 ← Y (= g v ), with either u or v unknown, and randomly choose
βi ∈ Zp , for i = 3, . . . , n to set gi ← g βi . Eventually, we randomly choose wi , for i = 1, . . . , n
i
and output (gi , ai = giwi , bi = aw
) together with wi , to the adversary which outputs (αi )i=1,...,n
Q αi
Q iαi
Q
such that (G = gi , A = ai = Gw , B = bαi i = Aw ) for some unknown w. We thus have
the following relations:
α1 u + α2 v +

n
X

!

αi βi · x = α1 uw1 + α2 vw2 +

i=3

α1 uw1 + α2 vw2 +

n
X

!

αi βi wi · x = α1 uw12 + α2 vw22 +

i=3

If we denote T =
we deduce that:

i=3 αi βi ,

Pn

U =

n
X
i=3
n
X

α i β i wi
αi βi wi2

i=3

i=3 αi βi wi ,

Pn

and V =

2
i=3 αi βi wi ,

Pn

that can be computed,

(α1 uw1 + α2 vw2 + U )2 = (α1 u + α2 v + T )(α1 uw12 + α2 vw22 + V )
which leads to
α1 α2 (w12 − w22 )uv + α1 (V − 2U w1 + T w12 )u + α2 (V − 2U w2 + T w22 )v + (T V − U 2 ) = 0
We consider two cases:
1. K = α2 (w12 − w22 )v + V − 2U w1 + T w12 = 0 mod p;
2. K = α2 (w12 − w22 )v + V − 2U w1 + T w12 6= 0 mod p;
which can be determined by checking whether the equality below holds or not:
2

2

2

g −(V −2U w1 +T w1 )/(α2 (w1 −w2 )) = Y.
One can note that case (1) and case (2) are independent of the bit b.
• If the case (1) happens, but b = 0, one aborts. If b = 1 (which holds with probability
1/2 independently of the case) then we can compute v = −(V − 2U w1 + T w12 )/(α2 (w12 −
w22 )) mod p which is the discrete logarithm of Z in the basis g.
• Otherwise, the case (2) appears. If b = 1 one aborts. If b = 0 (which holds with probability
1/2 independently of the case), v is known and we have α1 Ku + α2 (V − 2U w2 + T w22 )v +
(T V − U 2 ) = 0 mod p, which means that the discrete logarithm of Z in the basis g is
u = −(α2 (V − 2U w2 + T w22 )v + (T V − U 2 ))/(α1 K) mod p.

In the second scenario, the basis is common (for all i, gi = g), but the wi ’s are secret, still
random and thus assumed distinct.
∗
i
Theorem 36. Given n valid Square Diffie-Hellman tuples (g, ai = g wi , bi = aw
i ) for any g ∈ G
Q
Q
Q
$
Z∗p , outputting (αi )i=1,...,n such that (G = g αi , A = aαi i , B = bαi i ) is a
and random wi ←
valid Square Diffie-Hellman, with at least two non-zero coefficients αi , is computationally hard
under the SDL assumption.

Lemma 37. Given any fixed value α ∈ Zp and n valid Square Diffie-Hellman tuples (g, ai =
i
g wi , bi = aw
i ), for any g ∈ G and random wi ∈ Zp , outputting (αi )i=1,...,n such that α =
Pn
i=1 αi wi , with at least one non-zero coefficient αi , is computationally hard under the SDL
assumption.



56

4 - Linearly-Homomorphic Signatures

Proof of the lemma. Up to a guess, which is correct with probability greater than 1/n, we can
2
assume that α1 6= 0. We are given a square discrete logarithm challenge (g, Z1 = g z , Z2 = g z ),
$
Zp , for i = 2, . . . , n to set
in basis g. We set a1 ← Z1 , b1 ← Z2 , and randomly choose wi ←
i
(ai ← g wi , bi ← aw
).
We
then
output
(g,
a
,
b
),
i
=
1,
.
.
.
,
n,
to
the
adversary which outputs
i
i
i
P
(αi )i=1,...,n and α such that α1 z + ni=2 αi wi = α. At this stage, we solve the square discrete
P
logarithm problem by returning z = (α − ni=2 αi wi )/α1 mod p.
Proof of the theorem. Again, up to a guess, which is correct with probability greater than 1/n,
we can assume that α1 6= 0. We are given a square discrete logarithm challenge (g, Z1 = g z , Z2 =
2
$
g z ), in basis g. We set a1 ← Z1 , a2 ← Z2 , and randomly choose wi ←
Zp , for i = 2, . . . , n to
w
w
i
i
set (ai ← g , bi = ai ). We then output (g, ai , bi ), i = 2, . . . , n, to the adversary that outputs
Q
Q
Q
(αi )i=1,...,n such that (G = g αi , A = aαi i = Gw , B = bαi i = Aw ) for some unknown w. We
thus have the following relations:
n
X

!

αi · w = α1 z +

i=1

n
X

n
X

α i wi

i=2

!

αi · w = α1 z +
2

2

i=1

n
X

αi wi2

i=2

which leads to
α1 z +

n
X

!2

α i wi

=

α1 +

n
X

!

αi × α1 z 2 +

i=2

i=2

n
X

!

αi wi2 .

i=2

that can be computed from
If we denote T = i=2 αi wi , U = i=2 αi , and V =
2
2
above scalars, we have (α1 z + T ) = (α1 + U ) · (α1 z + V ), and thus
Pn

Pn

2
i=2 αi wi ,

Pn

U α1 z 2 − 2T α1 z + (α1 + U )V − T 2 = 0 mod p.
Using Lemma 37 on the n − 1 tuples (g, ai , bi ), for i = 2, . . . , n, the probability that T =
Pn
i=2 αi wi = 0 is negligible, unless one can break the SDL Assumption. So we have T 6= 0, with
two cases:
1. If U 6= 0 then, because computing square roots in Zp is easy, one can solve the above
quadratic equation for z that admits solutions, and obtain two solutions for z. By testing
which one satisfies g z = Z1 , one can find out the correct z and thus solve the SDL problem.
2. If U = 0, one can compute z = (α1 V −T 2 )/(2T α1 ) mod p and thus solve the SDL problem.

Randomizable Tags
As in the Definition 27, we can randomize the tags together with the messages: but just in a
computational way, and not in a statistical way. Indeed, from a message-signature (M , σ) for
a tag τ = (τ1 , τ2 , τ3 , π), one can derive the signature for the message M 0 = M α for the tag
τ 0 = (τ1α , τ2α , τ3α , π 0 ), where π 0 can be adapted from π and α. The triple (τ1α , τ2α , τ3α ) in the tag is
not uniformly random, as w has not changed, but it is computationally unlinkable to (τ1 , τ2 , τ3 )
under the DDH assumption.

4.5

SqDH LH-Sign Scheme

In this section, we provide a generic transformation to convert a OT-LH-Sign to LH-Sign, using
2
Square Diffie-Hellman tuples (g, g wi , g wi ) for the tags. We thus obtain a new construction of
linearly homomorphic signature with randomizable tags.

4.5.1

A First Generic Conversion



4.5 - SqDH LH-Sign Scheme

57

First Generic Conversion from OT-LH-Sign to LH-Sign
Let Σ = (Setup, SKeygen, Sign, MultiplySign, VerifSign) be a OT-LH-Sign, we complete it
into Σ 0 = (Setup0 , SKeygen0 , NewTag0 , VerifTag0 , Sign0 , MultiplySign0 , VerifSign0 ) as follows:
Setup0 (1κ ): It runs Setup(1κ ) to obtain param and adds the tag space param0 =
(param, Z∗p × G∗ );
SKeygen0 (param0 , n): It runs SKeygen(param, n + 3);
$
$
NewTag0 (sk): It chooses a random scalar w ←
Z∗p and a random group element h ←
G,
and sets τ̃ = τ = (w, h);

VerifTag0 (vk, τ ): It checks whether τ = (w, h) ∈ Z∗p × G or not;
Sign0 (sk, τ̃ = (w, h), M ): It extends M into M 0 with the three additional components
2
(h,hw,hw ) and signs it as σ = Sign(sk, M 0 );
MultiplySign0 (vk, τ, {ωi , M i , σi }`i=1 ): It simply computes σ =
Q ωi
i h );

Q

ωi
i σi

and τ 0 = (w, h0 =

VerifSign0 (vk, τ = (w, h), M , σ): It first extends M into M 0 with the Square Diffie2
Hellman tuple (h, hw , hw ) and checks whether VerifSign(vk, M 0 , σ) = 1 or not.
One can note that the MultiplySign0 provides a signature under a new tag τ 0 , but this is
still consistent with the definition of the LH-Sign. However, randomizability of the tag is not
possible.
Theorem 38. If Σ is OT-LH-Sign then Σ 0 is LH-Sign under the DL assumption and the extractability assumption (Definition 34).
Proof. Since the tags are fully public, any NewTag0 -query is answered by a random pair (wi , gi ),
and a Sign0 -query is answered by simply forwarding a Sign-query to the Σ security game. Receiving the forgery (vk, τ = (w, G), M , σ), one first generates M 0 from M and τ and checks
the validity, which means, according to the unforgeability of Σ, that there exist (αi )i such that
Q
M 0 = M 0i αi . The above extractability assumption provides these coefficients (αi )i . If we
just keep the 3 last components of each extended messages and the tags, we have square Diffiei
equal when the
Hellman triples (gi , ai = giwi , bi = aw
i )i , for randomQgi and wi (but possibly
Q
Q
same tag is used several times), and the triple (G = giαi , A = Gw = aαi i , B = Aw = bαi i )
extracted from the forgery. By combining the identical tags together, and so by summing in
Q βj
βj the αi ’s that correspond to the same triples (gi , ai , bi ), we have (G =
gj , A = Gw =
Q βj

Q β

aj , B = Aw = bj j ), for random and distinct triples (gj , aj , bj )j . From Theorem 35, under
the DL assumption, at most one coefficient is non-zero: none or βJ , and so at most one tag
Q
is represented: none or (gJ , aJ , bJ ). Hence M is either (1, . . . , 1) or M αi i for i such that
(gi , ai , bi ) = (gJ , aJ , bJ ).

4.5.2

A Second Generic Conversion

Second Generic Conversion from OT-LH-Sign to LH-Sign
Let Σ = (Setup, SKeygen, Sign, MultiplySign, VerifSign) be a OT-LH-Sign, we complete it
into Σ 0 = (Setup0 , SKeygen0 , NewTag0 , VerifTag0 , Sign0 , MultiplySign0 , VerifSign0 ) as follows:
Setup0 (1κ ): It runs Setup(1κ ) to obtain param and adds the tag space param0 =
(param, G3 × Π). Note that we need the group G to be extended to a bilinear
setting (G, G2 , GT , p, g, g, e) for the proofs;



58

4 - Linearly-Homomorphic Signatures

SKeygen0 (param0 , n): It runs SKeygen(param, n + 3);
2

$
NewTag0 (sk): It chooses a random scalar w ←
Z∗p and sets τ̃ = w and τ = (g, g w , g w , π),
where π is a zero-knowledge proof of valid square Diffie-Hellman tuple for
2
(g, g w , g w );
2

VerifTag0 (vk, τ ): It checks the proof π on (g, g w , g w );
Sign0 (sk, τ̃ = w, M ): It extends M into M 0 with the three additional components
2
(g, g w , g w ), and signs it as σ = Sign(sk, M 0 );
MultiplySign0 (vk, τ = (τ1 , τ2 , τ3 , π), {ωi , M i , σi }`i=1 ): It computes σ = i σiωi , ω = i ωi
and τ 0 = (τ1 , τ2ω , τ3ω , π 0 ) with π 0 the updated proof of valid square Diffie-Hellman
tuple;
Q

P

VerifSign0 (vk, τ = (τ1 , τ2 , τ3 , π), M , σ): It first checks whether VerifTag0 (vk, τ ) = 1 or
not, if the tag is valid, it extends M into M 0 with τ and checks whether
VerifSign(vk, M 0 , σ) = 1 or not.
Note that for the MultiplySign0 to be possible, one needs an homomorphic zero-knowledge
proof of valid square Diffie-Hellman tuple, as the Groth-Sahai techniques [GS08] allow in a
bilinear setting: let (v1,1 , v1,2 , v2,1 , v2,2 ) ∈ G42 be a Diffie-Hellman tuple, for a Square DiffieHellman tuple (g, A = g w , B = Aw ) ∈ G3 one can generate a commitment of w, Com = (c =
w v µ , d = v w v µ g w ) ∈ G2 , and the proofs proof = (Θ = g µ , Ψ = Aµ ) ∈ G2 . The proof π
v2,1
2
2,2 1,2
1,1
thus consists of the pair (Com, proof), and is homomorphic. It is well-known to be perfectlysound, and for the zero-knowledge property, one just has to switch from the Diffie-Hellman
tuple (v1,1 , v1,2 , v2,1 , v2,2 ) to a random tuple (v1,1 , v1,2 , v2,1 , v2,2 ) because they are computationally
indistinguishable under the DDH assumption in G2 , or statistically indistinguishable in the
generic group model. The latter assumption will be required for the security analysis below.
Theorem 39. If Σ is OT-LH-Sign then Σ 0 is LH-Sign, in the generic group model.
Proof. Let us consider an adversary that asks several tags (τi )i and signatures (σi )i on messages
(M i )i and tags of its choice, and eventually produces a forgery (τ, M , σ) with probability ε. A
forgery means that
• the tag is valid, and so the proof π is accepted;
• the signature is valid;
• M is not in the spans of the messages signed under the same tag.
First, as the signature Σ 0 is based on the OT-LH-Sign Σ thanks to the concatenation of the
message and (τ1 , τ2 , τ3 ) in the tags, we know that necessarily M 0 (the completion of M with
the triple in the tag) is a linear combination of the extended messages involved in the signing
queries, unless one has broken the unforgeability of Σ, which can just happen with negligible
probability.
As a consequence, the triple (τ1 , τ2 , τ3 ) in the tag of the forgery is a linear combination of
the Square Diffie-Hellman triples in the signing queries, with probability ε0 = ε − negl():
• either (τ1 , τ2 , τ3 ) is not a Square Diffie-Hellman tuple;
• or (τ1 , τ2 , τ3 ) is a Square Diffie-Hellman tuple.
In the former case, where (τ1 , τ2 , τ3 ) is not a Square Diffie-Hellman tuple, then we break the
perfect soundness of Groth-Sahai proofs, as all the proofs for the honest tags have been generated



4.5 - SqDH LH-Sign Scheme

59

honestly. Hence, the latter case should happen with probability greater than ε” = ε0 − negl():
(τ1 , τ2 , τ3 ) is both a linear combination of the input triples but still a Square Diffie-Hellman
tuple, with probability greater than ε00 . Then, the Theorem 36 shows that (τ1 , τ2 , τ3 ) is one
of the input triples to a power α (or possibly (1, 1, 1)). However, to apply this theorem, we
are given random Square Diffie-Hellman tuples as input and we should be able to generate the
proofs of validity. To this aim, we switch the Groth-Sahai proofs in perfectly hiding mode: we
replace a Non Diffie-Hellman tuple by a Diffie-Hellman tuple in the CRS, which is statistically
indistinguishable to a generic adversary, as its probability to make the difference is N/p2 , where
N is the number of group operations. So after this switch, from a list of Square Diffie-Hellman
tuples, we simulate the proofs, and the adversary outputs a tuple (τ1 , τ2 , τ3 ) that is both a linear
combination of the input triples but still a Square Diffie-Hellman tuple, with probability greater
than ε00 − N/p2 . As we are considering a forgery, several tags should be involved, which is
excluded by the Theorem 36: ε00 is negligible, and so ε is negligible too.
Universal Tag
Whereas only messages signed under the same tag can be combined, a message signed under the
tag τ0 = (1, 1, 1, π), where π = (1, 1, 1) is a proof for w = 0 with µ = 0 in the commitment Com,
can be combined with any message. Such a tag (1, 1, 1, π), which was not in T , is a universal
tag. Indeed, multiplied to any Square Diffie-Hellman tuple, this is still a Square Diffie-Hellman
tuple. This does not contradict the Theorems 35 and 36, as they only deal with non-trivial
Square Diffie-Hellman triples.



60

4 - Linearly-Homomorphic Signatures



Chapter

5

MixNet

This chapter is based on the paper [HPP20] published in the proceedings of the International
Conference on Practice and Theory of Public-Key Cryptography, PKC 2020.

Chapter content
5.1
5.2
5.3

Our Scheme: General Description . . . . . .
Our Scheme: Full Description . . . . . . . . .
Scalability . . . . . . . . . . . . . . . . . . . . .
5.3.1 Constant-Size Proof . . . . . . . . . . . . . .
5.3.2 Efficiency . . . . . . . . . . . . . . . . . . . .
5.4 Security Analysis . . . . . . . . . . . . . . . . .
5.4.1 Proof of Soundness . . . . . . . . . . . . . . .
5.4.2 Proof of Privacy: Unlinkability . . . . . . . .
5.4.3 Proof of Correctness . . . . . . . . . . . . . .
5.5 Applications . . . . . . . . . . . . . . . . . . .
5.5.1 Electronic Voting . . . . . . . . . . . . . . . .
5.5.2 Message Routing . . . . . . . . . . . . . . . .

.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.

. . . . .
. . . . .
. . . . .
. . . . . .
. . . . . .
. . . . .
. . . . . .
. . . . . .
. . . . . .
. . . . .
. . . . . .
. . . . . .

62
64
66
67
67
68
68
71
76
78
78
79

In the two main techniques of Mix-Networks, Furukawa and Sako [FS01] make proofs of
permutation matrices and Neff [Nef01] considers polynomials which remain identical with a permutation of the roots. The former approach with proof of permutation matrices is more classical,
with many candidates. Groth and Lu [GL07] proposed the first non-interactive zero-knowledge
(NIZK) proof of shuffle without random oracles, using Groth-Sahai proofs with pairings [GS08]
but under an hypothesis proven in the generic bilinear group model. Even with that, computations are still very expensive because the overhead proof is linear in N n, where n is the number of
ciphertexts and N the number of mixing rounds. In addition, they needed a Common Reference
String (CRS) linear in n. More recently, Fauzi et al. [FLSZ17] proposed a new pairing-based
NIZK shuffle argument to improve the computation for both the prover and the verifier, and
improved the soundness of the protocol. However they still had a CRS linear in the number of
ciphertexts, and the soundness holds in the generic bilinear group model.
In this chapter we apply the construction of OT-LH-Sign and LH-Sign seen in the previous
chapter to build a new mix-network. In our shuffle, each ciphertext Ci (encrypted vote in the
ballot, in the context of electronic voting) is signed by its sender and the mix-server randomizes
the ciphertexts {Ci } and permutes them into the set {Ci0 } in a provable way. The goal of the
proof is to show the existence of a permutation Π from {Ci } to {Ci0 } such that for every i,
0
CΠ(i)
is a randomization of Ci . Then, the output ciphertexts can be mixed again by another
mix-server. The unforgeability of the signature schemes will essentially provide the soundness
of the proof of correct mixing: only permutations of ballots will be possible.
In a first step, we provide a high-level description of our construction to give the intuitions of
our new method. However, this high-level presentation suffers several issues which are detailed.
Then, the second section 5.2 provides the solutions with the full scheme. At this point, the
global proof of mixing, after several mix-servers, is linear (and verification thus has a linear



62

5 - MixNet

cost) in the number of mix-servers. Therefore in a third step 5.3, we explain how to obtain a
constant-time overhead for the proof to publish, and thus for the verification. We detail the
security analysis in Section 5.4 with the three parts: soundness, unlinkability and correctness.
Eventually, we conclude with some applications in Section 5.5.

5.1

Our Scheme: General Description

We first provide a high-level description of our mix-net in Figure 5.1. As said above, the
goal of this presentation is just for the intuition: there are still many problems, that will be
highlighted and addressed in the next sections. We need two signature schemes:
• any OT-LH-Sign scheme (Setup,Keygen,Sign,MultiplySign,VerifSign), with additional MultiplyKey,
that will be used to sign ElGamal ciphertexts in G1 : the ciphertexts Ci and the signatures
σi belong to G1 and are verified with the user’ verification keys vki = (gk )k in G2 ;
• and any LH-Sign with randomizable tag scheme (Setup∗ , Keygen∗ , NewTag∗ , RandTag∗ ,
VerifTag∗ , Sign∗ , MultiplySign∗ , VerifSign∗ ) that will be used to sign users’ verification
keys vki in G2 : the signatures Σi also belong to G2 and are verified with Certification
Authority’s verification key VK = (gk )k in G1 .
CA = Certificate Authority, Ui = Useri , Sj = Mix-Serverj
Keys
(SK, VK) ← Keygen∗ ()
Authority LH-Sign signing key
(EK, DK) ← EKeygen()
Authority homomorphic encryption key
Ui ’s keys:
(ski , vki ) ← Keygen()
User OT-LH-Sign signing key
CA signs vki : (τ̃i , τi ) ← NewTag∗ (SK) Σi ← Sign∗ (SK, τ̃i , vki )
Ciphertext for randomization: C0 ← Encrypt(EK, 1)
(

CA’s keys:

Initial ballots (fori = 1, . . . , n)

 Ci ← Encrypt(EK, Mi )
σi,0 ← Sign(ski , C0 )
Ui generates:

 σ
i,1 ← Sign(ski , Ci )
(0)
BBox = (Ci , σi,0 , σi,1 , vki , Σi , τi )i

User’s ballot encryption
User’s signature on randomization
User’s ballot signature

Mix (j-th mix-server, for i = 1, . . . , n)
From BBox(j−1) = (Ci , σi,0 , σi,1 , vki , Σi , τi )i , Sj makes, for all i:
Randomization of the ballot:
∗
Ci0 = Ci · C0 γj,i
σi,1
= MultiplySign(vki , {(γj,i , C0 , σi,0 ), (1, Ci , σi,1 )})
Randomization
of
the
keys:
(
vk0i = (vki )αj
Σi∗ = MultiplySign∗ (VK, τi , (αj , vki , Σi ))
0
(VK, τi , vki , Σi0 ) = RandTag∗ (VK, τi , vki , Σi∗ )
Adaptation of the signatures:
0
σi,0
= MultiplyKey(C0 , (αj , vki , σi,0 ))
0
∗ ))
σi,1
= MultiplyKey(C10 , (αj , vki , σi,1
0
0
0
0
0
BBox(j) = (CΠ(i)
, σΠ(i),0
, σΠ(i),1
, vk0Π(i) , ΣΠ(i)
, τΠ(i)
)i
Figure 5.1: High-Level Description (Insecure Scheme)



5.1 - Our Scheme: General Description

63

Each user Ui generates a pair (ski , vki ) ← Keygen() to sign vectors in G1 . Ui first encrypts his
message Mi under an ElGamal encryption scheme, with encryption key EK and signs it to obtain
the signed-encrypted ballot (Ci , σi,1 ) under vki . Obviously, some guarantees are needed.
In order to be sure that a ballot is legitimate, all the verification keys must be certified by the
system (certification authority CA) that signs vki under SK, where (SK, VK) ← Keygen∗ (), into
Σi . Then, anyone can verify the certified keys (vki , Σi )i are valid under the system verification
key VK. Since we want to avoid combinations between verification keys, we use LH-Sign with
randomizable tags to sign the verification keys with a tag τi per user Ui .
Because of encryption, Mi is protected, but this is not enough as it will be decrypted in the
end. One also needs to guarantee unlinkability between the input and output ballots to guarantee
anonymity of users. As the ballot boxes contain the ciphertexts, as well as the verification keys,
the ballots must be transformed in an unlinkable way, then they can be output in a permuted
way.
To have Ci0 unlinkable to Ci , Ci0 must be a randomization of Ci . With an ElGamal encryption,
it is possible to randomize a ciphertext by multiplying by an encryption of 1. Thus, anyone can
compute an encryption C0 of 1, and as we use an OT-LH-Sign scheme, from a signature σi,0 of C0
under the user’s key, one can adapt σi,1 by using the message homomorphism (Property 26) with
∗ . In the same way, vk0 and τ 0 must be randomizations of respectively
MultiplySign to obtain σi,1
i
i
0
α
vki and τi . If vki = vki , its signature must be derived from Σi with MultiplySign∗ and τi0 is
obtained with the randomizable tag (Property 27) with RandTag∗ . Eventually, as we change
0 and σ 0 must be adapted, which is possible thanks to the weak key
the verification key, σi,0
i,1
homomorphism (Property 30) with MultiplyKey.
Then one generates a random permutation Π to output a new ballot-box with permuted
0
0
0
0
randomized ballots (vk0Π(i) , ΣΠ(i)
, CΠ(i)
, σΠ(i),0
, σΠ(i),1
)i .
Difficulties
The above high-level scheme gives intuitions of our main approach. However, to get the required
security, we still face a few issues that will be explained below and which motivate the full scheme
described in the next section.
Expanded Vectors. From the signatures σi,0 and σi,1 with an OT-LH-Sign scheme, anyone
can compute σ = MultiplySign(vki , {(α, C0 , σi,0 ), (β, Ci , σi,1 )}) for any α, β. As explained in
Section 4.1, we can impose β = 1 and the right format of Ci0 .
Non-Trivial Transformation. The weak key homomorphism allows to randomize vki into
vk0i = vkαi but, with our scheme, VerifSign(vkαi , Ci , σi,1 ) is valid for any α 6= 0 if and only if
VerifSign(vki , Ci , σi,1 ) is valid. This provides a link between vk0i and vki . To solve this issue, we
introduce a randomizer vk0 , as for the ciphertext. This is a special vector also signed by CA
to randomize vki in a non-trivial way: vk0i = (vki · vkδ0i )α . We will thus also have the signature
Σi,0 of vk0 and the signature Σi,1 (instead of Σi ) of vki , both under the same tag τi to allow
combinations.
Legitimate Ballots. Whereas all the ballots must be signed, nothing prevents a mix-server
from deleting a ballot or from adding a ballot signed by a legitimate user (that owns a valid
key vki ). If one first checks that the number of ballots is kept unchanged, it is still possible
that a ballot is replaced by a new legitimate ballot. Since we will consider honest and corrupted
users (and so honest and corrupted ballots), four cases are possible: one replaces an honest or
corrupted ballot by another honest or corrupted one. Our scheme will not provide guarantees
against the replacement of a corrupted ballot by another corrupted ballot. Nonetheless, by



64

5 - MixNet

adding a zero-knowledge proof of Diffie-Hellman tuple between the products of the verification
keys before and after the mix, we can avoid all the other cases involving honest users.
Multiple Servers. After the last round, one gets a proof that the output ballot-box contains
a permutation of randomized ciphertexts from the input ballot-box. However, the last mixserver could start from the initial ballot-box instead of the previous one, and then know the
permutation. This would break anonymity, as soon as the last mix-server is dishonest. We will
ask the mix-servers to sign their contributions to prove the multiple and independent permutations: each mix-server j generates the Diffie-Hellman proofs from BBox(j−1) to BBox(j) , and
signs them. We will then detail this solution in the next section, which will provide a proof
linear in the number of ballots and in the number of mix-servers (because of the multiple signature). Thereafter, with specific multi-signature, one can become independent of the number of
mix-servers.

5.2

Our Scheme: Full Description

With all the previous remarks and explanations, we can now provide the full description of our
scheme which is given in Figure 5.2.
Keys. As we will sign expanded ciphertexts of dimension 4 (see below), each user needs a
secret-verification key pair (ski , vki ) ← Keygen(param, 4) in Z4p × G52 . With our OT-LH-Sign,
the first element of vki is common for all the users and initialized to g0 = g. Then, one also
needs a signature Σi = (Σi,0 , Σi,1 ) with our LH-Sign from the certification authority of the pair
(vk0 , vki ) where vk0 = (1, 1, g0 , 1, 1) is used to make the non-trivial transformation on vki during
the mixes. This signature is signed by the authority possessing (SK, VK) ← Keygen∗ (param0 , 5)
in Z5p × G61 with a specific tag τi per user. Eventually, each mix-server has a pair of (standard)
signature scheme (SKj , VKj ) ← SKeygen() just to sign with SSign its mixing contribution. The
$
keys VK and (VKj )j , as well as EK = h = g d ∈ G1 and the random ` ←
G1 , are assumed to be
known to everybody.
As we are using El Gamal ciphertexts, the ciphertext for randomization is C0 = (g, h), the
trivial encryption of 1 = g 0 , with random coin equal to 1.
Initial ballots. Each user encrypts his message Mi under EK to obtain Ci = (ai , bi ). With
the remarks we already made, one needs to expand Ci into C i = (g, `i , ai , bi ) and C0 into
C 0 = (1, `, g, h). The addition of the first element is due to the affine space we want in the
signature σi (see Section 4.1) and the second element is because we randomize the third position
of vki with vk0 = (1, 1, g0 , 1, 1) and because the first position of vki is used for the verification
but not to sign (the last four elements of vki are used to sign). Finally, σi = (σi,0 , σi,1 ) is simply
the OT-LH-Sign of (C 0 , C i ) under the signing key ski .
Mix. To make a mix, the j-th mix-server computes the randomized verification keys vk0i =
0
γ
1/µ
(vki · vkδ0i )α , the randomized ciphertexts C i = C i · C 0i and the randomized tags τi0 = τi i , and
updates the signatures σi0 and Σi0 , thanks to the properties of the signatures. The random scalar
α is common to all the ballots, but γi , δi , µi are independent random scalars for each ballot.
Then, the mix-server chooses a permutation Π and sets the j-th ballot-box BBox(j) with all the
0
0
0
0
randomized and permuted ballots (CΠ(i)
, `0Π(i) , σΠ(i)
, vk0Π(i) , ΣΠ(i)
, τΠ(i)
)i . As already explained,
the mix-server also needs to make a proof proof (j) from BBox(j−1) to BBox(j) , to guarantee the
proper relations between the products of the verification keys and the products of the messages,
and signs it in sig(j) . Finally, the output of the mix contains BBox(j) and (proof (k) , sig(k) )jk=1
the set of proofs and mix-server signatures of the previous mixes until the j-th mix.



5.2 - Our Scheme: Full Description

65

CA = Certificate Authority, Ui = Useri , Sj = Mix-Serverj
MixSetup(1κ ):
Let param = (G1 , G2 , GT , p, g, g, e) ← Setup(1κ ) and param0 = {param, T = G2 ×
G1 };
Let NIZKDH -param ← NIZKDH -Setup(1κ ) and Sparam ← SSetup(1κ );
$
Let (DK = d, EK = h = g d ) ← EKeygen(1κ ) and C 0 = (1, `, g, h) for ` ←
G1 ; It
0
outputs Mix-param = (param , NIZKDH -param, Sparam, EK, `).
MixKeygen(Mix-param):
(
$
SK= (S1 , S2 , S3 , S4 , S5 ) ←
Z5p , VK = (g, g S1 , g S2 , g S3 , g S4 , g S5 )
CA:
$
Zp , τi = (τi,1 = g1/Ri , τi,2 = g 1/Ri )
and for each user Ui , τ̃i = Ri ←
vk0 = (1, 1, g0 = g, 1, 1)
Sj : { (SKj , VKj ) ← SKeygen()

$
ski = 
(ui , vi , xi , yi ) ←
Z4p , vki = (g0 = g, fi = gu0 i , li = gv0i , gi = gx0 i , hi = gy0i )
Ui :
Σi = Σi,0 = gS3 τ̃i , Σi,1 = (gS0 1 fSi 2 lSi 3 gSi 4 hSi 5 )τ̃i
MixInit(ski , Mi , vki , Σi , τi ):
$
$
Ui chooses ri ←
Zp and `i ←
G1 and computes
Ci = (ai = g ri , bi = hri Mi )

C i = (g, `i , ai , bi )

σi = (σi,0 = `vi g xi hyi , σi,1 = g ui `vi i axi i byi i )
It outputs Bi = (Ci , `i , σi , vki , Σi , τi ).
BBox(0) = (Bi )N
i=1
Mix(SKj , BBox(j−1) , (proof (k) , sig(k) )j−1
k=1 , Πj ):
(j−1)
From BBox
= (Ci , `i , σi , vki , Σi , τi )i , (proof (k) , sig(k) )j−1
k=1 ,
$
$
Sj chooses α ← Zp and for each ballot i, γi , δi , µi ← Zp and computes
a0i = ai · g γi

b0i = bi · hγi

g00 = gα0

f0i = fαi

0
Σi,1
= (Σi,1 · Σi,0 δi )αµi

`0i = `i · `γi

γi
0
σi,1
= σi,1 · σi,0
· `0i

l0i = (li · gδ0i )α
αµi
0
Σi,0
= Σi,0

δi

g0i = gαi

0
σi,0
= σi,0 · `δi

h0i = hαi

1/µi

1/µi

0
τi,1
= τi,1

0
τi,2
= τi,2

proof (j) = NIZKDH -Proof((g0 , g00 , fi , f0i ) ∧ (g, h, a0i / ai , b0i / bi ))
Sj
sig(j) = SSign(SKj , proof (j) )
0
0
0
0
outputs BBox(j) = (CΠ
, `0Πj(i) , σΠ
, vk0Πj(i) , ΣΠ
, τΠ
)i ,(proof (k), sig(k) )jk=1
j(i)
j(i)
j(i)
j(i)


Q

Q

Q

Q

Figure 5.2: Detailed Shuffling of ElGamal Ciphertexts

Q

Q



66

5 - MixNet

MixVerif(BBox(0) , BBox(N ) , (proof (k) , sig(k) )N
k=1 ) :
After N mixes, the input of the verifier is:
BBox(0) = (C i , σi,1 , vki , Σi,1 , τi,1 )ni=1
0

0

0
0
0 n
BBox(N ) = (C i , σi,1
, vk0i , Σi,1
, τi,1
)i=1 , (proof (k) , sig(k) )N
k=1

It outputs 1 if: n = n0 , the (vki )i are all distinct
∀k,
NIZKDH -Verif(proof (k) ) = 1
SVerif(VKk , proof (k) , sig(k) ) = 1
and ∀i,
VerifSign(vki , C i , σi,1 ) = 1 = VerifSign∗ (VK, τi , vki , Σi,1 )
0
0 ) = 1 = VerifSign∗ (VK, τ 0 , vk0 , Σ 0 )
VerifSign(vk0i , C i , σi,1
i
i
i,1
Figure 5.3: Detailed Verification of Shuffling
P

ui

P

Proofs. Let us denote F = fi = g0
and F0 = f0i = g00 ui the product of the second
element of the user’s verification key on all the input ballots and output ballots. If the input
and output ballot-boxes contain the same ballots (with the same secret ui ), then F0 = Fα ,
with g00 = gα0 . Hence one adds a proof of Diffie-Hellman tuple for (g0 , g00 , F, F0 ) as described
in Preliminaries 2.4.3. Together with the verification that there is the same number of ballots
in the input and output of the mix, we will show that the same (honest) users are represented
in the two ballot-boxes. Since we cannot allow multiple ballots from the same user, we have
the guarantee that the same messages from all the honest users are represented in the two
ballot-boxes.
Q
Q
Q
Q
The additional proof of Diffie-Hellman tuple for (g, h, a0i / ai , b0i / bi ) will limit the
exchange of ballots for corrupted users, as the products of the plaintexts must remain the same:
Q 0
Q
Mi = Mi . Since we already know these products will be the same for honest users, this
products must be the same from corrupted users. This will limit the impact of the attack of
Cortier-Smyth [CS13].
With these two Diffie-Hellman proofs, the output ballots are a permutation of the input ones. We could use any non-interactive zero-knowledge proofs of Diffie-Hellman tuples
(NIZKDH -Setup, NIZKDH -Proof, NIZKDH -Verif) and any signature (SSetup, SSign, SVerif) to sign
the proofs but the next section will provide interesting choices, from the length point of view.
Q

Q

Verification. The complete verification process, after N mix-servers, is presented in Figure 5.3. After all the mixes are done, it just requires the input ballot-box BBox(0) , the output
ballot-box BBox(N ) , and the signed proofs (proof (k) , sig(k) ), for k = 1, . . . , N without the elements that were useful for randomization only. The verifier checks the number of input ballots
is the same as the number of output ballots, the verification keys (the fi ’s) in input ballots are
0 ,Σ
0
all distinct, the signatures σi,1 , σi,1
i,1 and Σi,1 are valid on individual input and output tuples
(equations recalled in 5.4) and all the proofs proof (k) with the signatures sig(k) are valid with
NIZKDH -Verif and SVerif respectively. For that, we suppose that the statement is included in
each zero-knowledge proof. Thus, even if the intermediate ballot-boxes are not given to the
verifier, it is still possible to perform the verification.

5.3

Scalability



5.3 - Scalability

5.3.1

67

Constant-Size Proof

From Figure 5.3, one can note that our mix-net provides a quite compact proof, as it just requires
BBox(0) and BBox(N ) , and the signed proofs (proof (k) , sig(k) ), for k = 1, . . . , N . The size is thus
linear in n and N . This is the same for the verification complexity.
Whereas the linear complexity in n cannot be avoided, as the ballot-box must be transferred,
the part linear in N could be avoided. Indeed, each proof proof (j) ensures the relations from
the j − 1-th ballot-box to the j-th ballot-box. The global chain of proofs ensures the relations
from the initial ballot-box to the last ballot-box. From the soundness point on view, a compact
global proof would be enough. But for privacy, one wants to be sure that multiple mix-servers
contributed, to get unlinkability as soon as one server is honest.
To avoid the dependence in N , one can use Groth-Sahai proofs [GS08] (see 2.4.3 for details)
to combine together the proofs into a unique one as already used in Chase et al. [CKLM12].
However, to be sure that all the mix-servers contributed: each mix-server does as above, but
(j−1)
from the initial ballot-box to the j − 1-th ballot-box and,
also receives a partial proof proof 0
(j)
thanks to the homomorphic properties of the Groth-Sahai proof, updates it into proof 0 , to
prove the relation from the initial ballot-box and the j-th ballot-box, as shown in 2.4.3 for the
Diffie-Hellman proof between the products of the keys (the proof is similar for the product of
the ciphertexts but with G1 and G2 swapped). At the end of the mixing steps, one has the same
(N )
elements as above, plus the global proof proof 0 . All the mix-servers can now verify the proofs
and the contributions of all the servers. Only this global proof can be kept, but signed by all the
servers: using the multi-signature of Boneh-Drijvers-Neven [BDN18], that is recalled in 2.4.2,
the size of the signature msig keeps constant, whatever the number of mix-servers. Hence, after
multiple mixing steps, the size of the mixing proof (with the input and output ballot-boxes)
remains constant.

5.3.2

Efficiency

We consider VK and (VKj )j are long-term keys known to everybody, as well as EK and `.
However, for fair comparison, we do not consider vki as long-term keys, and consider them as
part of the input of the verifier. But we insist that the fi ’s in the input ballot-box must be all
distinct.
Size of Verifier’s Input:

The verifier receives:

(C i , σi,1 , vki , Σi,1 , τi )ni=1

0

0
0
(C i , σi,1
, vk0i , Σi,1
, τi0 )ni=1

(proof 0

(N )

, msig0

(N )

)

As the first element g0 of vki is common to all the users (as well as g00 of vk0i ), the set of all the
users’ verification keys is represented by 4 × n + 1 elements of G2 . Then, all input or output
ballots contains 2 × 5n elements from G1 and 2 × (6n + 1) elements from G2 .
(N )
The global proof proof 0
is just 4 elements of G1 and 4 elements of G2 and msig one element
in G2 . Hence, the full verifier’s input contains: 10n + 4 elements of G1 , 12n + 6 elements of G2 ,
whatever the number of mix-servers.
Verifier’s Computation. Using batch verification [CHP07, BFI+ 10, HHK+ 17], the verifier
0 , Σ ,
only needs to make 8n + 7 pairing evaluations to verify together all the signatures σi,1 , σi,1
i,1
(N )

0 , τ , τ 0 , 6 pairing evaluations to verify proof 0
Σi,1
and 2 pairing evaluations to verify msig.
i i
With some specific choices of the bases for the batch verification, as presented in Figure 5.4,
one can improve to 8n + 14 pairing evaluations for the global verification. This has to be
compared to the 4n + 1 pairing evaluations that have anyway to be performed to verify the
signatures in the initial ballot-box.



68

5 - MixNet

σi,0

1

−1
= e(σi,0
, g0 ) e(g, gi ) e(h, hi ) e(`, li )

0
σi,0

1

0
0
0
0
= e(σ 0 −1
i,0 , g0 ) e(g, gi ) e(h, hi ) e(`, li )

Σi,0

e(τi,2 , Σi,0 )

= e(g3 , g0 )

0
Σi,0

0 , Σ0 )
e(τi,2
i,0

= e(g3 , g00 )

σi,1

e(σi,1 , g0 )
e(σ 0 i,1 , g00 )

0
σi,1

=

e(g, fi )

e(ai , gi ) e(bi , hi ) e(`i , li )

3n +2

=

e(g, f0i )

e(a0i , g0i ) e(b0i , h0i ) e(`0i , l0i )

+3n +1

τi

e(τi,2 , g)

= e(g, τi,1 )

+0

τi0

0 , g)
e(τi,2

0 )
= e(g, τi,1

+0

Σi,1

e(g1 , g0 )

e(τi,2 , Σi,1 )

=

e(g2 , fi ) e(g3 , li ) e(g4 , gi ) e(g5 , hi )

+n +4

0
Σi,1

0 , Σ0 )
e(τi,2
i,1

e(g1−1 , g00 )

=

e(g2 , f0i ) e(g3 , l0i ) e(g4 , g0i ) e(g5 , h0i )

+n

e(H0 (proof (N ) ), avk)

msig

proof (N ) with F =

i fi ,F

Q

0

=

= e(g, msig)

+1

Q 0
Q 0 Q
Q
Q
ai and B = i b0i / bi :
i fi , A =
i ai /
x

x

x

1,1
1,1
1,2
e(cx1,1 dx1,2 , gx2,1 Fx2,2 ) = e(v2,1
(v2,2 · g)x1,2 , g0 x2,1 F0 x2,2 )e(v1,1
v1,2
, Θx2,1 Ψ x2,2 )

e(g

x02,1

x02,2

A

x01,1 x01,2

,c

d

) = e(g

0
0 x2,1

B

x02,2

x01,1
, v2,1
(v2,2

· g)

x01,2

)e(θ

x02,1

ψ

x02,2

x01,1 x01,2
, v1,1
v1,2 )

+3
+3
= 8n +14

Figure 5.4: Verification Cost. One can remark that several pairings have common bases g, g1 ,
g2 , g3 , g4 , g5 and g0 = g, which can be combined together in order to decrease the number of
pairings to be computed for the verification.

5.4

Security Analysis

Let us now formally prove the two security properties: the soundness means the output ballotbox contains a permutation of randomizations of the input ballot-box and privacy means one
cannot link an input ciphertext to an output ciphertext, as soon as one mix-server is honest.
We stress that we are in a particular case where users have private signing keys, and ballots
are signed. Unfortunately these keys allow to trace the ballots: with ski = (ui , vi , xi , yi ) and
g00 , one can recover vk0i , which contradicts privacy for this ballot. They might also allow to
exchange some ballots, which contradicts soundness for these ballots. As a consequence, we do
not provide any guarantee to corrupted users, whose keys have been given to the adversary (or
even possibly generated by the adversary), but we expect honest users to be protected:
• soundness for honest users means that all the plaintexts of the honest users in the input
ballot-box are in the output ballot-box;
• privacy for honest users means that ballots of honest users are unlinkable from the input
ballot-box to the output ballot-box.

5.4.1

Proof of Soundness

As just explained, we first study the soundness of our protocol, but for honest users only, in the
certified key setting, where all the users must prove the knowledge of their private keys before
getting their verification keys vki certified by the Certification Authority in Σi .



5.4 - Security Analysis

69

Definition 40 — Soundness for Honest Users
A mix-net M is said sound for honest users in the certified key setting, if any PPT
adversary A has a negligible success probability in the following security game:
1. The challenger generates the certification keys (SK, VK) and the encryption keys
(DK, EK);
2. The adversary A then
• decides on the corrupted users I ∗ and generates itself their keys (vki )i∈I ∗;
• proves its knowledge of the secrete keys to get the certifications Σi on vki , for
i ∈ I ∗;
• decides on the set I of the (honest and corrupted) users that will generate a
ballot;
• generates the ballots (Bi )i∈I ∗ for the corrupted users but provides the messages
(Mi )i∈I\I ∗ for the honest users;
3. The challenger generates the keys of the honest users (ski , vki )i∈I\I ∗ and their ballots
(Bi )i∈I\I ∗ . The initial ballot-box is thus defined by BBox = (Bi )i∈I ;
4. The adversary mixes BBox in a provable way into (BBox0 , proof).
The adversary wins if MixVerif(BBox, BBox0 , proof) = 1 but {Decrypt∗ (BBox)} =
6
∗
∗
0
{Decrypt (BBox )}, where Decrypt extracts the plaintexts (using the decryption key DK),
but ignores ballots of non-honest users (using the private keys of honest users) and sets
of plaintexts can have repetitions.
One can note that this security game does not depend on the mixing steps, but just considers
the global mixing, from the input ballot-box BBox to the output ballot-box BBox0 . The proof
proof contains all the elements for proving the honest behavior. In our case, this is just the two
Diffie-Hellman proofs.
Theorem 41 (Soundness for Honest Users of Our Mix-Net). Our mix-net protocol is sound for
honest users, in the certified key setting, assuming the unforgeability against Chosen-Message
Attacks of the LH-Sign and OT-LH-Sign signature schemes and the SEDL assumption.
Proof. For proving this theorem, we will assume the verification is successful (MixVerif(BBox,
BBox0 , proof) = 1) and show that for all the honest ballots, in the input and output ballot-boxes,
there is a permutation from the input ones to the outputs ones. And we do it in two steps: first,
honest keys vk0i in the output ballot-box are permuted randomizations of the honest keys vki in
the input ballot-box; then we prove it for the plaintexts.
Permutation of Honest Keys. We first modify the security game by using the unforgeability
against Chosen-Message Attacks of the LH-Sign signature scheme: we are given VK, and ask the
Tag-oracle and the Signing-oracle to obtain Σi on all the verification keys vki and vk0 . The rest
remains unchanged. Note that because of the proof of knowledge of the private keys ski before
getting vki certified, one can also extract them. Actually, one just needs to extract ui for all the
corrupted users. Then one knows all the legitimate ui ’s (for honest and corrupted users).
Under the unforgeability of the signature scheme (Setup∗ , Keygen∗ , NewTag∗ , RandTag∗ ,
VerifTag∗ , Sign∗ , MultiplySign∗ , VerifSign∗ ), for any output ballot with verification key vk0j there
exists a related legitimate verification key vki such that vk0j = vkαi i × vkz0i , for some scalars zi ,
and αi .



70

5 - MixNet

Since in our construction vki = (g0 , fi , li , gi , hi ) and vk0 = (1, 1, g0 , 1, 1), and vk0j = (g00 , f0j , l0j ,
g0j , h0j ) and vk00 = (1, 1, g00 , 1, 1) with a common g00 for all the keys, αi is a common scalar α:
vk0j = (vki × vkδ0i )α and vk00 = vkα0 . As a consequence, all the keys in the output ballot-box are
derived in a similar way from legitimate keys (signed by the Certification Authority): u0j = ui
remains unchanged. However this does not means they were all in the input ballot-box: the
adversary could insert a ballot with a legitimate verification key vki , which was not in the initial
ballot-box.
Q
Q
The verification process also includes a Diffie-Hellman proof for the tuple (g0 , g00 , i fi , j f0j ).
P
This means that i ui are the same on the input ballots and the output ballots. As one
additionally checks the numbers of input ballots and output ballots are the same, the adversary
can just replace an input ballot by a new one: if N is the set of new ballots and D the set of
P
P
deleted ballots, the sums must compensate: D ui = N ui .
The second game uses the SEDL assumption and the simulation-soundness of the proof of
knowledge of ski (in the certified key setting): Let us be given a tuple (g, f = gu , g, f = g u ),
as input of a SEDL challenge in G2 and G1 : the simulator will guess an honest user i∗ that
will be deleted, and implicitly sets ui∗ = u, with fi∗ , which allows it to use f = g ui∗ in the
signature of C i∗ on the first component g, while all the other scalars are chosen by the simulator
(vi∗ , xi∗ , yi∗ ), as well as all the other honest user’ keys, the authority signing keys, and, for all
the corrupted users, the secret element ui can be extracted at the certification time (using the
extractor from the zero-knowledge proof of knowledge) while the zero-knowledge simulator is
used for i∗ , thanks to the simulation-soundness.
If some honest user is deleted in the output ballot-box, with probability greater than 1/n,
P
P
P
P
this is i∗ : as shown above, D ui = N ui , so ui∗ = N ui − D\{i∗ } ui , which breaks the
symmetric external discrete logarithm assumption.
Permutation of Honest Ballots. The last game uses the unforgeability of the OT-LH-Sign
signature scheme under Chosen-Message Attacks: the simulator receives one verification key
vk, that will be assigned at a random honest user i∗ , whereas all the other keys are honestly
generated. The simulator also generates (SK, VK) and (DK, EK), as well as all signatures Σi and
the honest ballots (with a signing query for σi∗ ). Then, the adversary outputs a proven mix of
the ballot-box. We have just proven that there exists a bijection Π from I into J such that
vk0Π(i) = (vki × vkδ0i )α for some scalar δi , for all the honest users i among the input users in I.
0
0
From the signature verification on the output tuples, CΠ(i)
is signed under vk0Π(i) in σΠ(i),1
,
0
α
0
α
0
i
for every i: e(σΠ(i),1
, g00 ) = e(g, fαi ) · e(`0Π(i) , lαi gαδ
0 ) · e(aΠ(i) , gi ) · e(bΠ(i) , hi ), and since the same
α appears in g00 = gα0 , then for every i, we have
0
e(σΠ(i)
, g0 ) = e(g, fi ) · e(`0Π(i) , li gδ0i ) · e(a0Π(i) , gi ) · e(b0Π(i) , hi )
δ

i
= e(g, fi ) · e(`0Π(i) , li ) · e(a0Π(i) , gi ) · e(b0Π(i) , hi ) · e(`0 Π(i)
, g0 )

0

i
0
and so σΠ(i)
/`0 δΠ(i)
is a signature of C Π(i) = (g, `0Π(i) , a0Π(i) , b0Π(i) ) under vki : under the unforge0
ability assumption of the signature scheme, CΠ(i
∗ ) is necessarily a linear combination of the already signed vectors under vki∗ , which are Ci∗ and C0 , with some coefficients u, v: a0Π(i∗ ) = aui∗ g v ,
0
b0Π(i∗ ) = bui∗ hv , and g = g u 1v . Hence, u = 1, which means that CΠ(i
∗ ) is a randomization of Ci∗ .
We stress that for this property to hold, each key vki must appear at most once in the ballots,
otherwise some combinations would be possible. Hence the test that all the fi ’s are distinct in
the input ballot-box.

We stress that this proposition only guarantees permutation of ciphertexts for honest users.
There is indeed no formal guarantee for corrupted users whose signing keys are under the control
of a mix-server. The latter could indeed replace the ciphertexts of some corrupted users, by some



5.4 - Security Analysis

71

other ciphertexts under the same identity or even under the identity of another corrupted user.
One can note that replacing ciphertexts (and plaintexts) even for corrupted users is not that easy
Q
Q
because of the additional Diffie-Hellman proof on the ciphertexts, which implies Mi = Mi0
where the first product is over all the messages Mi in BBox and the second product is over all
the messages Mi0 in BBox0 . However, this property is more for the privacy, as we will see below.
As a consequence, our result that guarantees a permutation on the honest ballots is optimal.
We cannot guarantee anything for the users that share their keys with the mix-servers.

5.4.2

Proof of Privacy: Unlinkability

After proving the soundness, we have to prove the anonymity (a.k.a. unlinkability), which can
also be seen as zero-knowledge property. More precisely, as for the soundness, privacy will only
be guaranteed for honest users.
Definition 42 — Privacy for Honest Users
A mix-net M is said to provide privacy for honest users in the certified key setting, if any
PPT adversary A has a negligible advantage in guessing b in the following security game:
1. The challenger generates the certification keys (SK, VK) and the encryption keys
(DK, EK);
2. The adversary A then
• decides on the corrupted users I ∗ and generates itself their keys (vki )i∈I ∗;
• proves its knowledge of the secret keys to get the certifications Σi on vki , for
i ∈ I ∗;
• decides on the corrupted mix-servers J ∗ and generates itself their keys
(VKj )j∈J ∗ ;
• decides on the set J of the (honest and corrupted) mix-servers that will make
mixes;
• decides on the set I of the (honest and corrupted) users that will generate a
ballot;
• generates the ballots (Bi )i∈I ∗ for the corrupted users but provides the messages
(Mi )i∈I\I ∗ for the honest users;
3. The challenger generates the keys of the honest mix-servers (SKj ,VKj )j∈J \J ∗ the
keys of the honest users (ski , vki )i∈I\I ∗ and their ballots (Bi )i∈I\I ∗ .
The initial ballot-box is thus defined by BBox = (Bi )i∈I . The challenger randomly chooses
$
a bit b ←
{0, 1} and then enters into a loop for j ∈ J with the attacker:
∗
• let Ij−1
be the set of indices of the ballots of the corrupted users in the input
ballot-box BBox(j−1) ;

• if j ∈ J ∗ , A builds itself the new ballot-box BBox(j) with the proof proof (j) ;
• if j 6∈ J ∗ , A provides two permutations Πj,0 and Πj,1 of its choice, with the restric∗ , then the challenger runs the mixing with Π ,
tion they must be identical on Ij−1
j,b
and provides the output (BBox(j) , proof (j) );
In the end, the adversary outputs its guess b0 for b. The experiment outputs 1 if b0 = b
and 0 otherwise.



72

5 - MixNet

Contrarily to the soundness security game, the adversary can see the outputs of all the
mixing steps to make its decision, hence the index j for the mix-servers. In addition, some can
be honest, some can be corrupted. We will assume at least one is honest.
Moreover, the privacy proof of our Mix-Net protocol will depend on a new assumption:
First, let us define some kind of credential as follows for a scalar u and a basis g ∈ G1 , with
g ∈ G2 , r, t ∈ Zp :


Cred(u, g; g, r, t) = g, g t , g r , g tr+u , g, gt , gu



Definition 43 — Unlinkability Assumption
In groups G1 and G2 of prime order p, for any g ∈ G1 and g ∈ G2 , it states that
the distributions Dg,g (u, u) and Dg,g (u, v) are computationally indistinguishable, for any
u, v ∈ Zp :
(

Dg,g (u, v) =

$
g0 ←
G2 ,
(Cred(u, g; g, r, t), Cred(v, g; g , r , t ));
$
0
r, t, r , t0 ←
Zp

0

0

)

0

Intuitively, as we can write the credential as, where × stands for the element-wise product,
Cred(u, g; g, r, t) =

g
g

!

,

g
g

!t

,

g
gt

!r

×

1
gu

!

!

, gu

the third component is an ElGamal ciphertext of the g u , which hides it, and makes indistinguishable another encryption g u from an encryption of g v while, given (g, gu ) and (g0 , g0 v ), one
cannot guess whether u = v, under the DDH assumption in G2 . However the pairing relation
allows to check consistency:
e(g rt+u , g) = e(g r , gt ) · e(g, gu ) = e(g r , gt ) · e(g, g)u
0 0

0

t0

v

0

t0

e(g r t +v , g0 ) = e(g r , g0 ) · e(g, g0 ) = e(g r , g0 ) · e(g, g0 )v
Because of the independent group elements g and g0 = gs in the two credentials, this assumption
clearly holds in the generic bilinear group model, as one would either need to compare u = v or
equivalently rt = r0 t0 , whereas combinations only lead to e(g, g) to the relevant powers rt, sr0 t0 ,
as well as u and sv, for an unknown s.
Theorem 44. Our Mix-Net protocol provides privacy for honest users, in the certified key
setting, if (at least) one mix-server is honest, under our unlinkability assumption (see Definition 5.4.2), and the DDH assumptions in both G1 and G2 .
Proof. This proof will follow a series of games (Gi )i , where we study the advantage Advi of the
adversary in guessing b. We start from the real security game and conclude with a game where
all the ballots are random, independently from the permutations. Hence, the advantage will be
trivially 0.
Game G0 : This is the real game, where the challenger (our simulator) generates SK and
$
VK for the certification authority signature, and randomly chooses d ←
Zp to generate
d
the encryption public key EK = h = g . One also sets vk0 = (1, 1, g0 = gA , 1, 1) and
$
C0 = EncryptEK (1) = (g, h) expanded into C 0 = (1, `, C0 ) with the noise parameter ` ←
G1 .
Actually, A = 1 in the initial step, when the user encrypts his message Mi , but since
the shuffling may happens after several other shuffling iterations, we have the successive
exponentiations to multiple α (in A) for vk0 . The attacker A chooses the set of the
initial indices of the corrupted users I ∗ and the set of the initial indices of the corrupted



5.4 - Security Analysis

73

mix-servers J ∗ , provides their verification keys ((vki )i∈I ∗ , (VKj )j∈J ∗ ) together with an
extractable zero-knowledge proof of knowledge of ski .
From I and J , one generates the signing keys for the honest mix-servers j ∈ J \J ∗ , and set
$
Zp and
J to the index of the last honest mix-server. For each i ∈ I, one chooses τi = Ri ←
1/R
1/R
∗
sets τi = (τi,1 = g i , τi,2 = g i ). For each honest user i ∈ I\I , one randomly chooses
$
Zp to generate vki = (g0 = g, fi = gu0 i , li = gv0i , gi = gx0 i , hi = gy0i ), and
ui , vi , xi , yi , ri , ρi ←
eventually generates all the signatures Σi of (vki , vk0 ) under SK with respect to the tag τi
(using SK and (τ̃i )i ).
For the corrupted users, the simulator directly receives the set of ballots (Bi = (C i , σi , vki ,
Σi , τi ))i∈I ∗ while for the honest users, it receives (Mi )i∈I\I ∗ and computes
Ci = EncryptEK (Mi ) = (ai = g ri , bi = hri Mi )

C i = (g, `i = `ρi , Ci )

and the signature σi of (C i , C 0 ) under ski . The input ballot-box is then BBox(0) =
{(Bi )i∈I } including the ballots of the honest and corrupted users. Let I0∗ = I ∗ be the
set of the initial indices of the corrupted users.
$
The simulator randomly chooses b ←
{0, 1} and now begins the loop of the mixes: depending if the mix-server j is corrupted or not, the simulator directly receives (BBox(j) , proof (j) )
from the adversary or receives (Πj,0 , Πj,1 ). In the latter case, one first checks if Πj,0 I ∗ =
j−1

Πj,1

∗
Ij−1

∗ . Then, the simulator randomly
using the honest secret keys to determine Ij−1

$
$
chooses global α ←
Zp and individual γi , δi , µi ←
Zp for all the users, as an honest mixserver would do, to compute

vk0i = (g00 = gα0 , f0i = fαi , l0i = (li · gδ0i )α , g0i = gαi , h0i = hαi ) = (vki · vkδ0i )α
vk00 = (1, 1, g00 , 1, 1) = vkα0
0

C i = (g, `0i = `i · `γ0i , a0i = ai · g0γi , b0i = bi · hγ0i ) = C i · C 0

γi

δ

δ

γi
0
0
· `0i i )
σi0 = (σi,0
= σi,0 · `00 i , σi,1
= σi,1 · σi,0
αµi
δi αµi
0
0
) )
, Σi,1
= (Σi,1 · Σi,0
Σi0 = (Σi,0
= Σi,0
1/µ

1/µ

0
0
τi0 = (τi,1
= τi,1 i , τi,2
= τi,2 i )
0
and sets BBox(j) = (BΠ
)i . Eventually, the simulator computes the proof proof (j) for
j,b (i)Q
Q
Q
Q
Q
Q
(g0 , g00 , fi , f0i ) and (g, h, a0i / ai , b0i / bi ), and signs it using SKj .

After the full loop on all the mix-servers, the adversary outputs its guess b0 : AdvG0 =
PrG0 [b0 = b]. One important remark is that under the previous soundness result, which
has exactly the same setup, the input ballot-box for the last honest mix-server necessarily
contains a randomization of the initial honest ballots (the adversary against the soundness
is the above adversary together with the honest simulator up to its last honest round,
that does not need any secret). Only the behavior of this last honest mix-server will be
modified below.
Game G1 : We first switch the Diffie-Hellman proofs for (g0 , g00 , fi , f0i ) to the zero-knowledge
setting: if the input ballot-box for the last honest mix-server is not a randomization of
the initial honest ballots, that can be tested using the decryption key, one has built a distinguisher between the settings of the zero-knowledge proofs. In this new setting, one can
use the zero-knowledge simulator that does not use α. Under the zero-knowledge property,
AdvG0 < AdvG1 + negl().
Q

Q

Game G2 : We also switch the proofs for (g, h, a0i / ai , b0i / bi ) to the zero-knowledge
setting: as above, the distance remains negligible. In this new setting, one can use the
Q

Q

Q

Q



74

5 - MixNet
zero-knowledge simulator that does not use
AdvG1 < AdvG2 + negl().

i γi .

P

Under the zero-knowledge property,

Game G3 : In this game, we do not know anymore the decryption key, and use the indistinguishability of the encryption scheme (which relies on the Decisional Diffie-Hellman
assumption): in an hybrid way, we replace the ciphertexts Ci of the honest users by
an encryption of 1: Ci = EncryptEK (1). Under the DDH assumption in G1 , AdvG2 <
AdvG3 + negl().
Game G4 : This corresponds to Ci = (ai = g ri , bi = hri ). But now we can know d, but ` is
random: under the DDH assumption, we can replace the random value `i = `ρi by `i = `ri .
$
Ultimately, we set C i = (g, `i = `ri , ai = g ri , bi = hri ) for ri ←
Zp , for all the honest users,
in the initial ballot-box. Under the DDH assumption in G1 , AdvG3 < AdvG4 + negl().
Game G5 : In this game, one can first extract the keys of the corrupted users during the
certification phase. Then, all the honest mix-servers generate random signing keys sk0i ,
random tags τi0 , and random encryptions Ci0 of 1, for all the honest users (the one who do
not correspond to the extracted keys), and generate the signatures using the signing keys
SK and sk0i , but still behave honestly for the ballots of the corrupted users. Then, they
apply the permutations Πj,b on the randomized ballots.
Lemma 45 (Random Ballots for Honest Users). Under the Unlinkability Assumption (see
Definition 5.4.2) and DDH assumption in G2 , the view is computationally indistinguishable: AdvG4 < AdvG5 + negl().
In this last game, the i-th honest user is simulated with initial and output (after each honest mixserver) ciphertexts that are random encryptions of 1, and initial and output signing keys (and
thus verification keys vki and vk0i ) independently random. As a consequence, permutations Πj,b
are applied on random ballots, which is perfectly indistinguishable from applying Πj,1−b (as we
have restricted the two permutations to be identical on ballots of corrupted users): AdvG5 = 0.
Which leads to Adv0 ≤ negl().
Proof of Lemma 45. In the above sequences of games, from G0 to G4 , we could have checked
whether the honest vki ’s in the successive ballot-boxes are permutations of randomized honest
initial keys, just using the secret keys of the honest users. So, we can assume in the next hybrid
games, from G0 (j) to G8 (j), for j = N, . . . , 1 that the input ballots in BBox(j−1) contain proper
permutations of randomized honest initial keys, as nothing is modified before the generation of
this ballot-box. In the following series of hybrid games, for index j, the honest mix-servers up
to the j − 1-th round play as in G4 and from the j + 1-th round, they play as in G5 . Only the
behavior of the j-th mix-server is modified: starting from an honest behavior. Hence, G0 (N ) =
G4 .
Game G0 (j): In this hybrid game, we assume that the initial ballot-box has been correctly
$
generated (with C i = (g, `i = `ri , ai = g ri , bi = hri ) for ri ←
Zp , for all the honest
(j)
users), and mixing steps up to BBox have been honestly generated (excepted the zeroknowledge proofs that have been simulated). The next rounds are generated at random
0
by honest mix-servers: random signing keys sk0i and random ciphertexts C i = (g, `0i =
0
0
0
`ri , a0i = g ri , b0i = hri ), with random ri0 , and then correct signatures, using SK and sk0i . The
following sequence of games will modify the randomization of BBox(j−1) into BBox(j) if
the j-th mix-server is honest.
Game G1 (j): We now start modifying the randomization of the ballots by the j-th mix-server,
for the corrupted users. As we assumed the signatures Σi provided by the certification



5.4 - Security Analysis

75

authority from a proof of knowledge of ski , our simulator has access to ski = (ui , vi , xi , zi )
for all the corrupted users. The mixing step consists in updating the ciphertexts, the keys
and the signatures, and we show how to do it without using α such that g00 = gα0 but,
instead, just g00 , ski , C 0 = (1, `, g, h) and the individual random coins γi , δi : from Bi a
received ballot of a corrupted user, one can compute vk0i = (g00 , g00 ui , g00 vi +δi , g00 xi , g00 yi ) and
0
γ
C i = C i · C 0i , and then the signatures σi0 and Σi0 using the signing keys, and choosing
$
τ̃i0 ←
Zp . This simulation is perfect for the corrupted users: AdvG1 (j) = AdvG0 (j) .
Game G2 (j): We now modify the simulation of the honest ballots. In this game, we choose
$
random d, e ←
Zp for h = g d and ` = g e . Then we have simulated C i = (g, `i = `ri , ai =
0
0
0
0
r
r
g i , bi = h i ) the ciphertext in BBox(0) and we can set C i = (g, `0i = `ri , a0i = g ri , b0i = hri )
$
the ciphertext in BBox(j) for known random scalars ri , ri0 ←
Zp , where ri0 is actually ri + γi :
γi is the accumulation of all the noises. All the signatures are still simulated using the
$
signing keys (and τ̃i0 = Ri0 ←
Zp ), with g00 = gα0 for a random scalar α. This simulation is
perfectly the same as above: AdvG2 (j) = AdvG1 (j) .
Before continuing, we study the format of the initial and randomized ballots: by denoting
σi the initial signature in BBox(0) and σi0 the signature to generate in BBox(j) , we have the
following relations:
e(σi,1 , g0 ) = e(g, fi (gi hi d li e )ri )

e(σi,0 , g0 ) = e(g, gi hi d li e )
d e

d e

0
e(σi,0
, g00 ) = e(g, g0i h0i l0i )

0

0
e(σi,1
, g00 ) = e(g, f0i (g0i h0i l0i )ri )

If we formally denote σi,0 = g ti and σi,1 = g si , then we have
g0 ti = gi hi d li e and g0 si = fi (gi hi d li e )ri = fi g0 ti ri
0

0

0 = g 0 ti and σ 0 = g si , and
which implies si = ui + ti ri . Similarly, if we formally denote σi,0
i,1
set α as the product of all the α’s and δi as aggregation of all the δi ’s (with α’s) in the
previous rounds plus this round, from
0

t0

0

s0i

d e

g0 αti = g00 i = g0i h0i l0i = gi α hi αd (li gδ0i )αe
g0 αsi = g00

d e

0

0

= f0i (g0i h0i l0i )ri = fαi (gαi hαi d (li gδ0i )αe )ri

0

0

0

eδi ri0

we also have g0 ti = (gi hi d lei )gδ0i e and g0 si = fi (gi hdi lei )ri g0
As consequence:

which implies s0i = ui + t0i ri0 .
0

0

0
σi,1 = g ui · (g ri )ti = g ui · ai ti and σi,1
= g ui · (g ri )ti = g ui · a0i

t0i

Game G3 (j): Let us randomly choose scalars ui , ri , ri0 , ti , t0i and α, then, from (g, g0 ), we can
0
0
0 ← a0 ti g ui , f0 ← g0 ui .
set g00 ← gα0 , ai ← g ri , σi,1 ← atii g ui , fi ← gu0 i , as well as a0i ← g ri , σi,1
0
i
i
$
Then, one additionally chooses xi , yi ←
Zp and sets

gi ← gx0 i
g0i ← g00

xi

hi ← gy0i
h0i ← g00

li ← (gt0i /(gi hdi ))1/e
t0

yi

C i ← (g, aei , ai , adi )
0

d

e

d

C i ← (g, a0i , a0i , a0i )

l0i ← (g00 i /(g0i h0i ))1/e
0

By construction: gt0i = gi hdi lei , g00 ti = g0i h0i d l0i e , and
σi,1 = atii g ui = g ti ri × g ui
0

t0

0 0

0
σi,1
= a0i i g ui = g ti ri × g ui
0

0 ← g ti , σ and σ 0 are valid signatures of (C , C ) and (C , C )
With σi,0 ← g ti and σi,0
i
0
0
i
i
i
respectively. Then, the verification keys vki = (g0 , fi , li , gi , hi ) and vk0i = (g00 , f0i , l0i , g0i , h0i ) are



76

5 - MixNet
(t −x −dy )/e

correctly related for the secret keys (ui , vi , xi , yi ). From li = (gt0i /(gi hdi ))1/e = g0 i i i :
0
0
we have vi = (ti − xi − dyi )/e. From l0i = (g00 ti /(g0i h0i d ))1/e = g00 (ti −xi −dyi )/e : we have
vi0 = (t0i − xi − dyi )/e = (t0i − ti )/e + vi , which means that δi = (t0i − ti )/e.
Using the signing key SK, we can complete and sign vki (with random Ri ) and vk0i (with
random Ri0 , which implicitly defines µi ). As shown above, this perfectly simulates the
view of the adversary for the honest ballots in the initial ballot-box BBox(0) , with Bi =
(C i , σi , vki , Σi , τi ) and a randomized version in the updated ballot-box BBox(j) , with Bi0 =
0
(C i , σi0 , vk0i , Σi0 , τi0 ): AdvG3 (j) = AdvG2 (j) .
$
Game G4 (j): Let us be given Cred(ui , g; g0 , ri , ti ) and Cred(ui , g; g00 , ri0 , t0i ), for random ui ←
Zp , which provide all the required inputs from the first part of the simulation in the
previous game (before choosing xi , yi ). They all follow the distribution Dg,g0 (ui , ui ). As
we do not need to know α to randomize ballots for corrupted users, we can thus continue
the simulation as above, in a perfectly indistinguishable way: AdvG4 (j) = AdvG3 (j) .

Game G5 (j): Let us be given two credentials of ui and u0i , Cred(ui , g; g0 , ri , ti ) and Cred(u0i , g;
$
g00 , ri0 , t0i ), for random ui , u0i ←
Zp . Inputs follow the distribution Dg,g0 (ui , u0i ) and we do
as above. Under the Unlinkability Assumption (see Definition 5.4.2) the view is computationally indistinguishable: AdvG4 (j) < AdvG5 (j) + negl().
$
6 (g ). So
Game G6 (j): We receive a Multi Diffie-Hellman tuple (g0 , gi , hi , g00 , g0i , h0i ) ←
Dmdh
0
we know all the scalars, except xi , yi and α, which are implicitly defined by the input
$
challenge. Then, by choosing ti , t0i ←
Zp , we can define li , l0i as in the previous game, and
$
the ciphertexts and signatures are generated honestly with random scalars ri , ri0 ←
Zp :
AdvG6 (j) = AdvG5 (j) .
$
Game G7 (j): We now receive (g0 , gi , hi , g00 , g0i , h0i ) ←
D$6 (g0 ). We do the simulation as above.
The view of the adversary is indistinguishable under the DDH assumption in G2 :
AdvG6 (j) < AdvG7 (j) + negl().
0

0

0

0

$
In this game, vk0i = (g00 , fi = g00 ui , li = g00 vi , gi = g00 xi , hi = g00 yi ), with x0i , yi0 ←
Zp because
0
0
0
of the random tuple, vi = vi + (ti − ti )/e, for random ti and ti , it is thus also random, and
u0i is chosen at random.

Game G8 (j): We now choose at random the signing keys ski = (ui , vi , xi , yi ) and sk0i =
(u0i , vi0 , x0i , yi0 ) in order to sign the ciphertexts: AdvG8 (j) = AdvG7 (j) .
With this last game, one can see that G8 (1) = G5 . Furthermore, for each round j = N, . . . , 1, we
have AdvG0 (j) ≤ AdvG8 (j) + negl(), while G0 (j − 1) = G8 (j): AdvG4 = AdvG0 (N ) ≤ AdvG8 (1) +
negl() = AdvG5 + negl().

5.4.3

Proof of Correctness

For the reader convenience, we also show the correctness of our mix-net: if the input ballot box
is correct and the mix-servers follow the protocol then the verifier outputs 1.
If the initial ballot-box BBox(0) = (C i , σi,1 , vki,1 , Σi,1 , τi,1 )ni=1 is correct, then
VerifSign(vki , C i , σi,1 ) = 1
0

and

VerifSign∗ (VK, τi , vki , Σi,1 ) = 1.
0

0 , vk0 , Σ 0 , τ 0 )n
The final ballot-box is BBox(N ) = (C i , σi,1
i,1
i,1 i,1 i=1 and the proof of each mix-servers
(k)
(k)
N
are (proof , σ )k=1 . If all the mix-servers follow the protocol then n = n0 and for all k,
NIZKDH -Verif(proof (k) ) = 1 and SVerif(VKj , proof (k) , σ (k) ) = 1. Let αk be the witness of
Q
0
0
0
the proof proof (k) and α = N
k=1 αk . One needs to verify if VerifSign(vki , C i , σi,1 ) = 1 and



5.4 - Security Analysis

77

0 ) = 1:
VerifSign∗ (VK, τi0 , vk0i , Σi,1
0
0 ) = 1 because
First one can remark that VerifSign(vk0i , C 0 , σi,0
0
e(σi,0
, g00 ) = e(σi,0 · `δi , g0 )α = e(σi,0 , g0 )α · e(`δi , g0 )α

= e(1, fi )α e(`, li )α e(g, gi )α e(h, hi )α · e(`δi , g0 )α
= e(1, f0i )e(g, g0i )e(h, h0i ) · e(`, li )α e(`, gδ0i )α
= e(1, f0i )e(g, g0i )e(h, h0i ) · e(`, lαi · gδ0i α )
= e(1, f0i )e(g, g0i )e(h, h0i )e(`, l0i )
0

0 ) = 1 with the help of the previous computation:
Now, one can check VerifSign(vk0i , C i , σi,1
δ

γi
0
0
e(σi,1
, g00 ) = e(σi,1
, gα0 ) = e(σi,1 · σi,0
· `0i i , gα0 )
δ

γi
= e(σi,1 , g0 )α · e(σi,0
, gα0 ) · e(`0i i , gα0 )
δ

γi
= e(g, fi )α e(`i , li )α e(ai , gi )α e(bi , hi )α · e(σi,0
, gα0 ) · e(`0i i , gα0 )
δ

γi
= e(g, f0i )e(`i , lαi )e(ai , g0i )e(bi , h0i ) · e(σi,0
, gα0 ) · e(`0i i , gα0 )
γi
= e(g, f0i )e(ai , g0i )e(bi , h0i ) · e(σi,0
, gα0 ) · e(`i , lαi )e(`δi i · `γi δi , gα0 )
γi
, gα0 ) · e(`i , lαi )e(`δi i , gα0 )e(`γi δi , gα0 )
= e(g, f0i )e(ai , g0i )e(bi , h0i ) · e(σi,0
γi
γi δi α
i
, g0 )
= e(g, f0i )e(ai , g0i )e(bi , h0i ) · e(σi,0
, gα0 ) · e(`i , lαi · gαδ
0 )e(`i · `
γi
, gα0 ) · e(`i , l0i )e(`γi δi , gα0 )
= e(g, f0i )e(ai , g0i )e(bi , h0i ) · e(σi,0
γi
, gα0 ) · e(`γi δi , gα0 )
= e(g, f0i )e(`i , l0i )e(ai , g0i )e(bi , h0i ) · e(σi,0

= e(g, f0i )e(`i , l0i )e(ai , g0i )e(bi , h0i ) · e((σi,0 `δi )γi , gα0 )
0
= e(g, f0i )e(`i , l0i )e(ai , g0i )e(bi , h0i ) · e(σi,0
, gα0 )γi

= e(g, f0i )e(`i , l0i )e(ai , g0i )e(bi , h0i ) · e(1, f0i )γi e(`, l0i )γi e(g, g0i )γi e(h, h0i )γi
= e(g, f0i )e(`i , l0i )e(ai , g0i )e(bi , h0i ) · e(1γi , f0i )e(`γi , l0i )e(g γi , g0i )e(hγi , h0i )
= e(g, f0i )e(`i · `γi , l0i )e(ai · g γi , g0i )e(bi · hγi , h0i )
= e(g, f0i )e(`0i , l0i )e(a0i , g0i )e(b0i , h0i )
About the tags, one can see
1/µ

1/µ

0
0
, g).
e(g, τi,1
) = e(g, τi,1 i ) = e(g, τi,1 )1/µi = e(τi,2 , g)1/µi = e(τi,2 i , g) = e(τi,2

For the certification, setting VK = (gi )6i and τ̃i = Ri , one has τ̃i0 = Ri µi and:
0
0
e(τi,2
, Σi,1
) = e(g 1/(Ri µi ) , (Σi,1 · Σi,0 δi )αµi )
1/R

1/R

= e(g, Σi,1 i )α · e(g, Σi,0 i )δi α
1/R

= e(g1 , g0 )α e(g2 , fi )α e(g3 , li )α e(g4 , gi )α e(g5 , hi )α · e(g, Σi,0 i )δi α
1/R

= e(g1 , g00 )e(g2 , f0i )e(g4 , g0i )e(g5 , h0i ) · e(g3 , lαi )e(g, Σi,0 i )δi α
= e(g1 , g00 )e(g2 , f0i )e(g4 , g0i )e(g5 , h0i ) · e(g3 , lαi )e(g3 , gδ0i α )
= e(g1 , g00 )e(g2 , f0i )e(g4 , g0i )e(g5 , h0i ) · e(g3 , lαi gδ0i α )
= e(g1 , g00 )e(g2 , f0i )e(g3 , l0i )e(g4 , g0i )e(g5 , h0i )



78

5 - MixNet

Randomization
In this part, we prove that a randomized ballot is a correct randomization of a ballot. A
ballot Bi for a user Ui can be parametrized by (ski , Mi ) the secret key of the user and his
message: Bi (ski , Mi ) = (C i , σi , vki , Σi , τi ). The three elements (C i , vki , τi ) need to be proved
indistinguishable from fresh ones but (σi , Σi ) are two deterministic signatures depending on the
three previous elements.
A fresh ciphertext C i is of the form (g, `i , g ri , hri Mi ) with `i random in G1 and ri random
0
0
0
γ
in Zp . The outputted ciphertext is C i = C i · C 0j,i = (g, `0i , g ri , hri Mi ) with `0i = `i · `γj,i and
0
ri0 = ri + γj,i . Thus, C i is perfectly indistinguishable from a fresh ciphertext.
0
0
1/µ
For the tag, τi = (g1/Ri , g 1/Ri ) and τi0 = τi i thus we have τi0 = (g1/Ri , g 1/Ri ) with Ri0 = Ri µi
which also corresponds to a fresh tag in a perfectly indistinguishable way.
About the verification key, we have vk0 = (1, 1, g0 , 1, 1), vki = (g0 , gu0 i , gv0i , gx0 i , gy0i ) for ski =
0
α
(ui , vi , xi , yi ), and vk0i = (vki · vkδ0i ) thus, vk0i = (g00 , g00 ui , g00 vi , g00 xi , g00 yi ) with g00 = gα0 and
vi0 = vi + δi which is indistinguishable from a fresh verification key under the DDH in G2 .

5.5

Applications

We now discuss use-cases of mix-nets: electronic voting and anonymous routing. In both cases, a
mix-server can, on the fly, perform individual verifications and randomization of ballots, as well
as the product of the fi ’s and the ciphertexts adaptively until the ballots are all sent. Eventually,
at the closing time for a vote or at the end of a time lapse for routing, one just has to do and
sign global proof of Diffie-Hellman tuples, and then output the ballots in a permuted order.

5.5.1

Electronic Voting

Our mix-net fits well the case of e-voting because after the multiple mixing steps, all the mixservers can perform a second round to sign in a compact way the constant-size proof, certifying
each of their contributions. The input size as well as the computation cost of the verifier are
both independent on the number of mixing steps. To our knowledge it is the first scheme with
this very nice property.
About security, as explained, soundness and privacy are guaranteed for the honest users only:
honest users are sure that their votes are randomized in the output ballot-box, and their inputoutput ballots are unlinkable. This is of course the most important requirements. However,
since the ui ’s are used to guarantee that no ballots are deleted or inserted, this is important
those values to be unknown to the mix-server.
In the Section 4.4, we proposed a construction that uses Square Diffie-Hellman tuples
wi
i
to obtain
(gr , Ai = gw
r , Bi = Ai ) as tags to add in any one-time linearly homomorphic signature
Q
Q 0
a linearly homomorphic signature with randomizable tags. Then, one can use Aj = ( Ai )α
Q 0
Q α
instead of fj and ( fi ) , in the Diffie-Hellman tuple, to guarantee the permutation of the verification keys. Only the privacy of the wi ’s is required to guarantee the soundness. Even if the
tag can be randomized just in a computational way and not in a statistical way, this is enough
for our mix-net application. We can also exploit the universal tag to optimize our construction
of mix-net. Indeed, instead of having Σi,0 the LH-Sign of vk0 for each user, it is possible to have
Σ0 = Sign∗ (SK, w, vk0 ) and still be able to randomize vki and adapt its signature Σi,1 keeping
the tag τi per user.
Q
Q
The proof that Mi = Mi0 is actually never used in the previous security proofs, as it
counts for privacy in e-voting only. Indeed, in our privacy security game we let the adversary
choose the messages of the honest users. In a voting scheme, the adversary could not choose
them and would like to learn the vote of a target voter. The first mix-server could take the vote
(ciphertext) of this voter and ask several corrupted voters to duplicate this vote. The bias in the



5.5 - Applications

79

tally would reveal the vote of the target voter: the proof on the products of the plaintexts avoids
this modification during the mixing. This does not exclude the attack of Cortier-Smyth [CS13]
if the votes are publicly sent, as the corrupted voters could simply use the ciphertext for their
own ballots.

5.5.2

Message Routing

Another important use case of mix-nets is in routing protocols where the mix-servers are proxy
servers guaranteeing that no one can trace a request of a message. In this scenario, it is not
possible to perform a second round on the mix-servers to obtain the multi-signature and the
efficiency is thus linear in the number of mixing steps. It is still an open problem to avoid the
second round while maintaining the independence in the number of mix-servers.



80

5 - MixNet



Chapter

6

Anonymous Credentials

This chapter is based on the paper [HP20] under submission.

Chapter content
6.1

6.2

6.3

6.4

6.5

6.6

Overview of our New Primitives . . . . . . . . . . . . . . . . . . . . .

82

6.1.1

Tag-based Signatures . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

82

6.1.2

Signatures with Randomizable Tags . . . . . . . . . . . . . . . . . . . .

83

6.1.3

Aggregate Signatures . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

Aggregate Signatures with Randomizable Tags . . . . . . . . . . . .

84
84

6.2.1

Anonymous Ephemeral Identities . . . . . . . . . . . . . . . . . . . . . .

85

6.2.2

Aggregate Signatures with Randomizable Tags . . . . . . . . . . . . . .

85

6.2.3

One-Time ART-Sign Scheme with Square Diffie-Hellman Tags (SqDH) .

87

6.2.4

Bounded ART-Sign Scheme with Square Diffie-Hellman Tags (SqDH) . .

90

Multi-Authority Anonymous Crendentials . . . . . . . . . . . . . . .

92

6.3.1

Definition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

92

6.3.2

Security Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

92

6.3.3

Anonymous Credential from EphemerId and ART-Sign Scheme . . . . . .

94

SqDH-based Anonymous Credentials . . . . . . . . . . . . . . . . . . .
6.4.1

The Basic SqDH-based Anonymous Credential Scheme . . . . . . . . . .

6.4.2

A Compact SqDH-based Anonymous Credential Scheme . . . . . . . . .

Traceable Anonymous Credentials . . . . . . . . . . . . . . . . . . . .

96
97
98
99

6.5.1

Traceable Anonymous Credentials . . . . . . . . . . . . . . . . . . . . .

99

6.5.2

Traceable SqDH-based Anonymous Credentials . . . . . . . . . . . . . . 100

6.5.3

Groth-Sahai Proof for Square Diffie-Hellman Tracing . . . . . . . . . . . 100

Related Work . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 100

The most recent papers on attribute-based anonymous credential schemes are [FHS19, San20].
The former proposes the first constant-size credential to prove k-of-N attributes, with computational complexity in O(N − k) for the prover and in O(k) for the verifier. However, it only
works for one credential issuer (K = 1). The latter one improves this result by enabling multiple
showings of relations (r) of attributes. All the other known constructions allow, at best, selective
(s) disclosures of attributes.
In [CL11], Canard and Lescuyer use aggregate signatures to construct an ABC system. It
is thus the closest to our approach. Instead of having tags, their signatures take indices as
input. We follow a similar path but we completely formalize this notion of tag/index with
an EphemerId scheme. To our knowledge, aggregate signatures are the only way to deal with
multiple credential issuers but still allowing to show a unique compact credential for the proof of
possession of attributes coming from different credential issuers. However, the time-complexity
of a prover during a verification depends on the number k of shown attributes. We solve this issue
at the cost of a larger key for the credential issuers (but still in the same order as [FHS19, San20])
and a significantly better showing cost for the prover (also better than [FHS19, San20]).



82

6 - Anonymous Credentials

After precising some notations and reviewing classical definitions in Section 2.1, we informally
describe, in Section 6.1, the two important primitives that we will use in our construction of
anonymous credentials: the EphemerId and ART-Sign schemes. In Section 6.2, we provide their
full definitions and a concrete instantiation. From there, we will be able to define and construct,
in Section 6.3, our ABC scheme from EphemerId and ART-Sign schemes. The full instantiation
is given in Section 6.4. Traceability is defined and instantiated in Section 6.5. Finally, related
work is discussed in Section 6.6.

6.1

Overview of our New Primitives

The usual way to perform authentication is by presenting a certified public key and proving
ownership of the associated private key with a zero-knowledge proof of knowledge. The certified
public key is essentially the signature by a Certification Authority (CA) on a public key and
an identity pair, with a standard signature scheme. In case of attribute-based authentication,
the attribute is signed together with the public key in the certificate. The latter thus signs two
objects, with different purpose, the public key associated to a private key, and the identity or
an attribute.
In the same vein as labelled encryption schemes, we define tag-based signatures to dissociate
the user-key which will be a provable tag and Attr which will be the signed message (attribute or
identity). This flexibility will allow randomizability of one without affecting the other, leading
to anonymous credentials.
Notations. In this chapter, vectors will be denoted between brackets [. . .] and unions will be
concatenations: [a, b] ∪ [a, c] = [a, b, a, c], keeping the ordering. On the other hand, sets will be
denoted between braces {. . .}, with possible repetitions: {a, b}∪{a, c} = {a, a, b, c} as in [San20],
but without ordering.

6.1.1

Tag-based Signatures

For a pair (τ̃ , τ ), where τ is a tag and τ̃ corresponds to the secret part of the tag, one can define a
new primitive called tag-based signature, where we assume all the used tags τ to be valid (either
because they are all valid, or their validity can be checked):
Tag-based Signatures
A tag-based signatures consists of the algorithms:
Setup(1κ ): Given a security parameter κ, it outputs the global parameter param, which
includes the message space M and the tag space T ;
Keygen(param): Given a public parameter param, it outputs a key pair (sk, vk);
GenTag(param): Given a public parameter param, it generates a witness-word pair (τ̃ , τ );
Sign(sk, τ, m): Given a signing key sk, a tag τ , and a message m, it outputs the signature
σ under the tag τ ;
VerifSign(vk, τ, m, σ): Given a verification key vk, a tag τ , a message m and a signature
σ, it outputs 1 if σ is valid relative to vk and τ , and 0 otherwise.
The security notion would expect no adversary able to forge, for any honest pair (sk, vk), a
new signature for a pair (τ, m), for a valid tag τ , if the signature has not been generated using
sk and the tag τ on the message m. Generically, τ̃ can be sk and τ can be vk, then this is just



6.1 - Overview of our New Primitives

83

a classical signature of m. Another case is when τ̃ = τ , and then this can just be a classical
signature of the message-pair (τ, m).
However more subtil situations can be handled: in our use-cases, τ will be a word for some
language L representing the authorized users and τ̃ a witness (for τ ∈ L). According to the
language L, which can be a strict subset of the whole set T , one may have to prove the actual
membership τ ∈ L (the validity of the tag) for the validity of the signature. It might be
important in the unforgeability security notion. On the other hand, one may also have to prove
the knowledge of the witness τ̃ , in an interactive and zero-knowledge way for authentication.
The latter can be performed, using the interactive protocol (ProveKTag(τ̃ ), VerifKTag(τ )).
This will be useful for the freshness in the authentication process. The former can also be proven
using an interactive protocol (ProveVTag(τ̃ ), VerifVTag(τ )). However this verification can also
be non-interactive or even public, without needing any private witness. The only requirement
is that this proof or verification of membership should not reveal the private witness involved
in the proof of knowledge, as the witness will be used for authentication.
Now the tag and the message are two distinct elements in the signature, we will introduce
new properties for each of them:
• randomizable tags: if τ can be randomized, but still with an appropriate zero-knowledge
proof of knowledge of τ̃ , one can get anonymous credentials, where τ is a randomizable
public key and an attribute is signed;
• aggregate signatures: one can aggregate signatures generated for different messages (attributes), even different keys (multi-authority) but all on the same tag τ .
By combining both properties, we will provide a compact scheme of attribute-based anonymous
credentials. When a trapdoor allows to link randomized tags, one gets traceability.

6.1.2

Signatures with Randomizable Tags

As tags are seen as words in some language L, randomizable tags will make sense for random-self
reducible languages [TW87]: the word τ defined by a witness τ̃ and some additional randomness
r can be derived into another word τ̃ 0 associated to τ̃ 0 and r0 (either r0 only or both τ̃ 0 and r0
are uniformly random). When randomizing τ into τ 0 , one must be able to keep track of the
change from to update τ̃ to τ̃ 0 and the signatures. Formally, we will require to have the three
algorithms:
RandTag(τ ): Given a tag τ as input, it outputs a new tag τ 0 and the randomization link
ρτ →τ 0 ;
DerivWitness(τ̃ , ρτ →τ 0 ): Given a witness τ̃ (associated to the tag τ ) and a randomization
link between τ and a tag τ 0 as input, it outputs a witness τ̃ 0 for the tag τ 0 ;
DerivSign(vk, τ, m, σ, ρτ →τ 0 ): Given a valid signature σ on tag τ and message m, and ρτ →τ 0
the randomization link between τ and another tag τ 0 , it outputs a new signature σ 0
on the message m and the new tag τ 0 . Both signatures are under the same key vk.
From a valid witness-word pair (τ̃ , τ ) ← GenTag(param), if (τ 0 , ρ) ← RandTag(τ ) and τ̃ 0 ←
DerivWitness(τ̃ , ρ) then (τ̃ 0 , τ 0 ) should also be a valid witness-word pair.
In addition, for compatibility with the tag and correctness of the signature scheme, we
require that for all honestly generated keys (sk, vk) ← Keygen(param), all messages m, and
all tags (τ̃ , τ ) ← GenTag(param), if σ ← Sign(sk, τ, m), (τ 0 , ρ) ← RandTag(τ ) and σ 0 ←
DerivSign(vk, τ, m, σ, ρ), then the algorithm VerifSign(vk, τ 0, m, σ 0 ) should output 1.



84

6 - Anonymous Credentials

For privacy reasons, in case of probabilistic signatures, it will not be enough to just randomize
the tag, but the random coins too:
RandSign(vk, τ, m, σ): Given a valid signature σ on tag τ and message m, it outputs a
new signature σ 0 on the same message m and tag τ .
Correctness extends the above one, where the algorithm VerifSign(vk, τ 0 , m, σ 00 ) should output
1 with σ 00 ← RandSign(vk, τ 0 , m, σ 0 ). One additionally expects unlinkability: the following distributions are (computationally) indistinguishable, for any vk and m (possibly chosen by the adversary), where for i = 0, 1, (τ̃i , τi ) ← GenTag(1κ ), σi ← Sign(sk, τi , m), (τi0 , ρi ) ← RandTag(τi ),
σi0 ← DerivSign(vk, τi , m, σi , ρi ) and σi00 ← RandSign(vk, τi0 , m, σi0 ):
D0 = {(m, vk, τ0 , σ0 , τ00 , σ000 , τ1 , σ1 , τ10 , σ100 )}

6.1.3

D1 = {(m, vk, τ0 , σ0 , τ10 , σ100 , τ1 , σ1 , τ00 , σ000 )}.

Aggregate Signatures

Boneh et al. [BGLS03] remarked it was possible to aggregate the BLS signature [BLS01], we will
follow this path, but for tag-based signatures, with possible aggregation only between signatures
with the same tag, in a similar way as the indexed aggregated signatures [CL11]. We will even
consider aggregation of public keys, which can either be a simple concatenation or a more evolved
combination as in [BDN18]. Hence, an aggregate (tag-based) signature scheme (Aggr-Sign) is a
signature scheme with the algorithms:
Aggregate Signature Scheme
An aggregate (tag-based) signature scheme (Aggr-Sign) is a signature scheme with the
algorithms:
AggrKey({vkj }`j=1 ): Given ` verification keys vkj , it outputs an aggregated verification
key avk;
AggrSign(τ, (vkj , mj , σj )`j=1 ): Given ` signed messages mj in σj under vkj and the same
tag τ , it outputs a signature σ on the message-set M = {mj }`j=1 under the tag τ
and aggregated verification key avk.
We remark that keys can evolve (either in a simple concatenation or a more compact way)
but messages also become sets. While we will still focus on signing algorithm of a single message
with a single key, we have to consider verification algorithms on message-sets and for aggregated
verification keys. In the next section, we combine aggregation with randomizable tags, and we
will handle verification for message-sets.
Correctness of an aggregate (tag-based) signature scheme requires that for any valid tagpair (τ̃ , τ ) and honestly generated keys (skj , vkj ) ← Keygen(param), if σj = Sign(skj , τ, mj ) are
valid signatures for j = 1, · · · , `, then for both key avk ← AggrKey({vkj }`j=1 ) and signature
σ = AggrSign(τ, (vkj , mj , σj )`j=1 ), the verification VerifSign(avk, τ, {mj }`j=1 , σ) should output 1.

6.2

Aggregate Signatures with Randomizable Tags

After the informal presentation of our new primitive, we describe the full definition of aggregate
signature scheme with randomizable tags. We will then provide a concrete construction that we
will extend to attribute-based anonymous credentials. While the compactness of the credentials
will exploit the aggregation of signature, as in [CL11], privacy will rely on the randomizability
of the tags. However, their specific format will allow more compact anonymous credentials.



6.2 - Aggregate Signatures with Randomizable Tags

6.2.1

85

Anonymous Ephemeral Identities

As our randomizable tags will be used as ephemeral identities (ephemeral key pairs), we denote
them EphemerId:
Definition 46 — EphemerId Scheme
An EphemerId scheme consists of the algorithms:
Setup(1κ ): Given a security parameter κ, it outputs the global parameter param, which
includes the tag space T ;
GenTag(param): Given a public parameter param, it outputs a tag τ and its secret part τ̃ ;
(ProveVTag(τ̃ ), VerifVTag(τ )): This (possibly interactive) protocol corresponds to the verification of the tag τ . At the end of the protocol, the verifier outputs 1 if it accepts
τ as a valid tag and 0 otherwise;
RandTag(τ ): Given a tag τ as input, it outputs a new tag τ 0 and the randomization link
ρτ →τ 0 between τ and τ 0 ;
DerivWitness(τ̃ , ρτ →τ 0 ): Given a witness τ̃ (associated to the tag τ ) and a link between
the tags τ and τ 0 as input, it outputs a witness τ̃ 0 for the tag τ 0 ;
(ProveKTag(τ̃ ), VerifKTag(τ )): This optional interactive protocol corresponds to the proof
of knowledge of τ̃ . At the end of the protocol, the verifier outputs 1 if it accepts the
proof and 0 otherwise.
The security notions are the usual properties of zero-knowledge proofs for the two protocols (ProveKTag(τ̃ ), VerifKTag(τ )) and (ProveVTag(τ̃ ), VerifVTag(τ )), with zero-knowledge and
soundness. But the RandTag must also randomize the tag τ within an equivalence class, in an
unlinkable way:
• Correctness: the language L ⊂ T might be split in equivalence classes (denoted ∼, with
possibly a unique huge class), then for any τ issued from GenTag and τ 0 ← RandTag(τ ),
we must have τ 0 ∼ τ ;
• Soundness: the verification process for the validity of the tag should not accept an invalid
tag (not in the language);
• Knowledge Soundness: in case of the optional proof of knowledge, extraction of the witness
should be possible when the verifier accepts the proof with non-negligible probability;
• Zero-knowledge: the proof of validity and the proof of knowledge should not reveal any
information about the witness;
• Unlinkability: for any pair (τ1 , τ2 ) issued from GenTag, the two distributions {(τ1 , τ2 , τ10 , τ20 )}
and {(τ1 , τ2 , τ20 , τ10 )}, where τ10 ← RandTag(τ1 ) and τ20 ← RandTag(τ2 ), must be (computationally) indistinguishable.
In the case of unique equivalence class for τ , one can expect perfect unlinkability. In case of
multiple equivalence classes for τ , these classes should be computationally indistinguishable to
provide unlinkability.

6.2.2

Aggregate Signatures with Randomizable Tags

We can now provide the formal definition of an aggregate signature scheme with randomizable tags, where some algorithms exploit compatibility between the EphemerId scheme and the
signature scheme:



86

6 - Anonymous Credentials
Definition 47 — Aggregate Signatures with randomizable tags (ART-Sign)
An ART-Sign scheme, associated to an EphemerId scheme E = (Setup, GenTag, (ProveVTag,
VerifVTag), RandTag, DerivWitness) consists of the algorithms (Setup, Keygen, Sign,
AggrKey, AggrSign, DerivSign, RandSign, VerifSign):
Setup(1κ ): Given a security parameter κ, it runs E.Setup and outputs the global parameter
param, which includes E.param with the tag space T , and extends it with the message
space M;
Keygen(param): Given a public parameter param, it outputs a key-pair (sk,vk);
Sign(sk, τ, m): Given a signing key, a valid tag τ , and a message m ∈ M, it outputs the
signature σ;
AggrKey({vkj }`j=1 ): Given ` verification keys vkj , it outputs an aggregated verification
key avk;
AggrSign(τ, (vkj , mj , σj )`j=1 ): Given ` signed messages mj in σj under vkj and the same
valid tag τ , it outputs a signature σ on the message-set M = {mj }`j=1 under the
tag τ and aggregated verification key avk;
VerifSign(avk, τ, M , σ): Given a verification key avk, a valid tag τ, a message-set M and
a signature σ, it outputs 1 if σ is valid relative to avk and τ , and 0 otherwise;
DerivSign(avk, τ, M , σ, ρτ →τ 0 ): Given a signature σ on a message-set M under a valid tag
τ and aggregated verification key avk, and the randomization link ρτ →τ 0 between τ
and another tag τ 0 , it outputs a signature σ 0 on the message-set M under the new
tag τ 0 and the same key avk;
RandSign(avk, τ, M , σ): Given a signature σ on a message-set M under a valid tag τ and
aggregated verification key avk, it outputs a new signature σ 0 on the message-set M
and the same tag τ .

We stress that all the tags must be valid. Moreover, using algorithms from E, tags are
randomizable at any time, and signatures adapted and randomized, even after an aggregation:
avk and M can either be single key and message or aggregations of keys and messages. One can
remark that only protocol (ProveVTag, VerifVTag) from E is involved in the ART-Sign scheme,
as one just needs to check the validity of the tag, not the ownership. The latter will be useful
in anonymous credentials with fresh proof of ownership.
Unforgeability.
In the Chosen-Message Unforgeability security game, the adversary has unlimited access to the
following oracles, with lists KList and TList initially empty:
• OGenTag() outputs the tag τ and keeps track of the associated witness τ̃ , with (τ̃ , τ )
appended to TList;
• OKeygen() outputs the verification key vk and keeps track of the associated signing key
sk, with (sk, vk) appended to KList;
• OSign(τ, vk, m), for (τ̃, τ ) ∈ TList and (sk, vk) ∈ KList, outputs Sign(sk, τ, m).
It should not be possible to generate a signature that falls outside the range of DerivSign,
RandSign, or AggrSign:



6.2 - Aggregate Signatures with Randomizable Tags

87

Definition 48 (Unforgeability for ART-Sign). An ART-Sign scheme is said unforgeable if, for
any adversary A that, given signatures σi for tuples (τi ,vki , mi ) of its choice but for τi and
vki issued from the GenTag and Keygen algorithms respectively (for Chosen-Message Attacks),
outputs a tuple (avk, τ, M , σ) where both τ is a valid tag and σ is a valid signature w.r.t.
(avk, τ, M ), there exists a subset J of the signing queries with a common tag τ 0 ∈ {τi }i such
that τ ∼ τ 0 , ∀j ∈ J, τj = τ 0 , avk is an aggregated key of {vkj }j∈J , and M = {mj }j∈J , with
overwhelming probability.
Since there are multiple secrets, we can consider corruptions of some of them:
• OCorruptTag(τ ), for (τ̃ , τ ) ∈ TList, outputs τ̃ ;
• OCorrupt(vk), for (sk, vk) ∈ KList, outputs sk.
The forgery should not involve a corrupted key (but corrupted tags are allowed). Note again
that all the tags are valid (either issued from GenTag or verified). In the unforgeability security
notion, some limitations might be applied to the signing queries: one-time queries (for a given
tag-key pair) or a bounded number of queries.
Unlinkability.
Randomizability of both the tag and the signature are expected to provide anonymity, with
some unlinkability property:
Definition 49 (Unlinkability for ART-Sign). An ART-Sign scheme is said unlinkable if, for any
avk and M , no adversary A can distinguish the distributions D0 and D1 , where for i = 0, 1, we
have (τ̃i , τi ) ← GenTag(1κ ), (τi0 , ρi ) ← RandTag(τi ), σi is any valid signature of M under τi and
vk, σi0 ← DerivSign(avk, τi , M , σi , ρi ) and σi00 ← RandSign(avk, τi0 , M , σi0 ):
D0 = {(M , avk, τ0 , σ0 , τ00 , σ000 , τ1 , σ1 , τ10 , σ100 )}

6.2.3

D1 = {(M , avk, τ0 , σ0 , τ10 , σ100 , τ1 , σ1 , τ00 , σ000 )}.

One-Time ART-Sign Scheme with Square Diffie-Hellman Tags (SqDH)

Our construction will provide an aggregate signature with randomizable tags based on the second
linearly homomorphic signature scheme of 4.5.2.
Description of the EphemerId Scheme.
With tags in T = G31 , in an asymmetric bilinear setting (G1 , G2 , GT , p, g, g, e), and τ is a Square
2
Diffie-Hellman tuple (h, hτ̃ , hτ̃ ), one can define the SqDH EphemerId scheme:
EphemerId Scheme
Given a security parameter κ, let (G1 , G2 , GT , p, g, g, e) be an asymmetric bilinear setting, where g and g are random generators of G1 and G2 respectively. The
set of tags is T = G31 . We then define param = (G1 , G2 , GT , p, g, g, e; T );

Setup(1κ ):

$
GenTag(param): Given a public parameter param, it randomly chooses a generator h ←
G∗1
2
$
and outputs τ̃ ←
Z∗p and τ = (h, hτ̃ , hτ̃ ) ∈ G31 .

ProveVTag(τ̃ ), VerifVTag(τ ): The prover constructs the proof π = proof(τ̃ : τ =
2
(h, hτ̃ , hτ̃ )) (see 4.4 for the Groth-Sahai [GS08] proof). The verifier outputs 1 if
it accepts the proof and 0 otherwise.
$
RandTag(τ ): Given a tag τ as input, it chooses ρτ →τ 0 ←
Zp and constructs τ 0 = τ ρτ →τ 0
the derived tag. It outputs (τ 0 , ρτ →τ 0 ).



88

6 - Anonymous Credentials
DerivWitness(τ̃ , ρτ →τ 0 ): The derived witness remains unchanged: τ̃ 0 = τ̃ .
Valid tags are Square Diffie-Hellman pairs in G1 :
2

L = {(h, hx , hx ), h ∈ G∗1 , x ∈ Z∗p } = ∪x∈Z∗p Lx

2

Lx = {(h, hx , hx ), h ∈ G∗1 }

The randomization does not affect the exponents, hence there are p − 1 different equivalence
classes Lx , for all the non-zero exponents x ∈ Z∗p , and correctness is clearly satisfied within
equivalence classes. The validity check (see 4.4) is sound as the Groth-Sahai commitment is in
the perfectly binding setting. Such tags also admit an interactive Schnorr-like zero-knowledge
proof of knowledge of the exponent τ̃ for (ProveKTag(τ̃ ), VerifKTag(τ )) which also provides
extractability (knowledge soundness). Under the DSqDH and DL assumptions, given the tag τ ,
it is hard to recover the exponent τ̃ = x. The tags, after randomization, are uniformly distributed
in the equivalence class, and under the DSqDH-assumption, each class is indistinguishable from
G31 , and thus one has unlinkability.
Description of the One-Time SqDH-based ART-Sign Scheme.
The above EphemerId scheme can be extended into an ART-Sign scheme where implicit vector
messages are signed. As the aggregation can be made on signatures of messages under the same
tag but from various signers, the description is given for signers indexed by j and one-component
messages indexed by (j, i). However, the scheme needs to be state-full as there is the limitation
for a signer j not to sign more than one message by index (j, i) for a given tag: a signer must
use two different indices to sign two messages for one tag.
One-Time SqDH-based ART-Sign Scheme
Setup(1κ ): It extends the above setup with the set of messages M = Zp ;
Keygen(param): Given the public parameters param, it outputs the signing and verification
keys
skj,i = ( SKj = [ t, u, v ], SK0j,i = [ ri , si
vkj,i = ( VKj = [ gt , gu , gv ], VK0j,i = [ gri , gsi

$
] )←
Z5p ,
] ) ∈ G52 .

Note that one could dynamically add new SK0j,i and VK0j,i to sign implicit vector
messages: skj = SKj ∪ [SK0j,i ]i , vkj = VKj ∪ [VK0j,i ]i ;
Sign(skj,i , τ, m): Given a signing key skj,i = [t, u, v, r, s], a message m ∈ Zp and a public
tag τ = (τ1 , τ2 , τ3 ), it outputs the signature
σ = τ1t+r+ms × τ2u × τ3v .
AggrKey({vkj,i }j,i ): Given verification keys vkj,i , it outputs the aggregated verification key
avk = [avkj ]j , with avkj = VKj ∪ [VK0j,i ]i for each j;
AggrSign(τ, (vkj,i , mj,i , σj,i )j,i ): Given tuples of verification key vkj,i , message mj,i and
Q
signature σj,i all under the same tag τ , it outputs the signature σ = j,i σj,i of the
concatenation of the messages verifiable with avk ← AggrKey({vkj,i }j,i );
DerivSign(avk, τ, M , σ, ρτ →τ 0 ): Given a signature σ on tag τ and a message-set M , and
ρτ →τ 0 the randomization link between τ and another tag τ 0 , it outputs σ 0 = σ ρτ →τ 0 ;
RandSign(avk, τ, M , σ): The scheme being deterministic, it returns σ;



6.2 - Aggregate Signatures with Randomizable Tags

89

VerifSign(avk, τ, M , σ): Given a valid tag τ = (τ1 , τ2 , τ3 ), an aggregated verification key
avk = [avkj ] and a message-set M = [mj ], with both for each j, avkj = VKj ∪[VK0j,i ]i
and mj = [mj,i ]i , and a signature σ, one checks if the following equality holds or
not, where nj = #{VK0j,i }:




e(σ, g) = e τ1 ,

Y

VKj,1 nj ×

Y

j



× e τ2 ,

mj,i 

i


Y

VK0j,i,1 · VK0j,i,2


VKj,2 nj  × e τ3 ,

j


Y

VKj,3 nj  .

j

In case of similar public keys in the aggregation (a unique index j), avk = VK ∪ [VK0i ]i and
verification becomes, where n = #{VK0i },
e(σ, g) = e τ1 , VK1 ×
n

n
Y

VK0i,1

·

M
VK0i,2 i

!

× e (τ2 , VK2 n ) × e (τ3 , VK3 n ) .

i=1

Recall that the validity of the tag has to be verified, either with a proof of knowledge of the
2
witness (as it will be the case in the ABC scheme, or with the proof π = proof(τ̃ : τ = (h, hτ̃ , hτ̃ ))
(see 4.4 for the Groth-Sahai [GS08] proof).
Security of the One-Time SqDH-based ART-Sign Scheme.
As argued in [HPP20], the signature scheme defined above is unforgeable in the generic group
model [Sho97], if signing queries are asked at most once per tag-index pair:
Theorem 50. The One-Time SqDH-based ART-Sign is unforgeable with one signature only per
index, for a given tag, even with adaptive corruptions of keys and tags, in the generic group
model.
Proof. As argued in [HPP20], when the bases of the tags are random, even if the exponents
are known, the signature that would have signed messages M = (g, g m1 , . . . , g, g mn ) is an unforgeable linearly-homomorphic signature. This means it is only possible to linearly combine
signatures with the same tag. As issued signatures are on pairs (g, g mi ), under a different pair
of keys for each such signed pair (whether they are from the same global signing key SK or not,
as we exclude repetitions for an index), which can be seen as tuples (1, 1, . . . , g, g mi , . . . , 1, 1),
completed with 1’s, the invariant generators g imply coefficients 0 and 1 in the linear combination: all the pairs (g, g mi ) have been signed under the same tag. This proves unforgeability,
even with corruptions of the tags, but without repetitions of tag-index. One can also consider
corruptions of the signing keys, as they are all independent: one just needs to guess under which
key will be generated the forgery.
About unlinkability, it relies on the DSqDH assumption, but between credentials that contain
the same messages at the same shown indices (the same message-vector M ):
Theorem 51. The One-Time SqDH-based ART-Sign, with message-vectors, is unlinkable under
the DSqDH assumption.
Proof. As already noticed, the tags are randomizable among all the square Diffie-Hellman triples
with the same exponent, which are indistinguishable from random triples in G31 , so for any pair
of tags (τ̃i , τi ) ← GenTag(1κ ), for i = 0, 1, when randomized into τi0 respectively, the distributions
(τ0 , τ1 , τ00 , τ10 ) and (τ0 , τ1 , τ10 , τ00 ) are indistinguishable under the DSqDH assumption. For any avk
and M , the signatures are deterministic and unique for a tag τ , so they are functions (even if



90

6 - Anonymous Credentials

not efficiently computable) of (avk, τ, M ), so the distributions (M , avk, τ0 , σ0 , τ1 , σ1 , τ00 , σ00 , τ10 , σ1 )
and (M , avk, τ0 , σ0 , τ1 , σ1 , τ10 , σ10 , τ00 , σ0 ) are also indistinguishable under the DSqDH assumption.
No need of randomization of the signatures.

6.2.4

Bounded ART-Sign Scheme with Square Diffie-Hellman Tags (SqDH)

The above signature scheme limits to one-time signatures: only one signature can be generated
for a given tag-index, otherwise signatures can be later forged on any message for this index, by
linearity: the vector space spanned by (g, g m ) (in case of just one signature issued for one index)
is just (g α , g αm ) and the constraint of g for the first component implies α = 1; on the other
0
hand, the vector space spanned by (g, g m ) and (g, g m ) (in case of two signatures issued for one
index) is G × G, and even the constraint of g for the first component does not limit anything
for the second component.
This will be enough for our ABC application, as one usually has one attribute value for a
specific kind of information (age, city, diploma, etc), but in practice this implies the signer to
either keep track of all the indices already signed for one tag or to sign all the messages at once.
We provide another kind of combinations, that could be applied on our SqDH signature scheme
that will have interesting application to an ABC scheme.
Description of the Bounded SqDH-based ART-Sign Scheme.
We propose here an alternative where the limitation is on the total number n of messages signed
for each tag by each signer:
Setup(1κ ):

Bounded SqDH-based ART-Sign Scheme
It extends the above EphemerId-setup with the set of messages M = Zp ;

Keygen(param, n): Given the public parameters param and a length n, it outputs the
signing and verification keys
skj
vkj = gskj

$
= [ t, u, v, s1 , . . . , s2n−1 ] ←
Zp2n+2 ,
= [ T, U, V, S1 , . . . , S2n−1 ] ∈ G22n+2 .

Sign(skj , τ, m): Given a signing key skj = [t, u, v, s1 , . . . , s2n−1 ], a message m ∈ Zp and a
public tag τ = (τ1 , τ2 , τ3 ), it outputs the signature
σ=

P2n−1

t+
τ1

1

s` m`

× τ2u × τ3v .

AggrKey({vkj }j ): Given verification keys vkj , it outputs the aggregated verification key
avk = [vkj ]j ;
AggrSign(τ, (vkj , mj,i , σj,i )j,i ): Given tuples of verification key vkj , message mj,i and sigQ
nature σj,i all under the same tag τ , it outputs the signature σ = j,i σj,i of the
concatenation of the messages verifiable with avk ← AggrKey({vkj }j );
DerivSign(avk, τ, M , σ, ρτ →τ 0 ): Given a signature σ on tag τ and a message-set M , and
ρτ →τ 0 the randomization link between τ and another tag τ 0 , it outputs σ 0 = σ ρτ →τ 0 ;
RandSign(avk, τ, M , σ): The scheme being deterministic, it returns σ;
VerifSign(avk, τ, M , σ): Given a valid tag τ = (τ1 , τ2 , τ3 ), an aggregated verification key
avk = [vkj ]j and a message-set M = [mj ]j , with for each j, mj = [mj,i ]i , and a



6.2 - Aggregate Signatures with Randomizable Tags

91

signature σ, one checks if the following equality holds or not, where nj = #{mj,i }:


e(σ, g) = e τ1 ,

Y nj

Tj ×

j

2n−1
Y
`=1

P

Sj,`

m`j,i
i





 × e τ2 ,


Y



n

Uj j  × e τ3 ,

j


Y

n
Vj j 

j

Recall that the validity of the tag has to be verified, as for the other version.
Security of the Bounded SqDH-based ART-Sign Scheme.
The linear homomorphism of the signature from [HPP20] still allows combinations. But when
the number of signing queries is at most 2n per tag, the verification of the signature implies 0/1
coefficients only:
Theorem 52. The bounded SqDH-based ART-Sign is unforgeable with a bounded number of
signing queries per tag, even with adaptive corruptions of keys and tags, in both the generic
group model and the random oracle model.
Proof. As argued in [HPP20] and recalled in Theorem 35, when the bases of the tags are
random, even if the exponents are known, the signature that would have signed messages
1
2n−1
M = (g m , . . . , g m
), for m ∈ Zp , is an unforgeable linearly-homomorphic signature. This
means it is only possible to linearly combine signatures with the same tag. We fix the limit
to n signatures σi queried ondistinct
messages
for i = 1, . . . , n under vkj : one can derive
P
P mi ,2n−1
Q αi
αi m1i
αi mi
i
i
the signature σ = σi on g
,...,g
. Whereas the forger claims this is a
 P

P

1

n



signature on g i ai , . . . , g i αi ai , on nj ≤ n values a1 , . . . , anj , as one cannot combine more
P
than n attributes. Because of the constraint on τ2 , we additionally have αi = nj mod p:
n
X

αi m`i

=

nj
X

a`i mod p

for ` = 0, . . . , 2n − 1

i=1

i=1

Let us first move on the left hand side the elements ak ∈ {mi }, with only n0 ≤ nj new elements,
we assume to be the first ones, and we note βi = αi if mi ∈
6 {ak } and βi = αi − 1 if mi ∈ {ak }:
n
X

0

βi m`i

i=1

=

n
X

a`i mod p

for ` = 0, . . . , 2n − 1

i=1

We thus have the system
n
X
i=1

0

βi m`i

+

n
X

γi a`i = 0 mod p

for ` = 0, . . . , 2n − 1, with γi = −1

i=1

This is a system of 2n equations with at most n + n0 ≤ 2n unknown values βi ’s and γi ’s, and
the Vandermonde matrix is invertible: βi = 0 and γi = 0 for all index i. As a consequence, the
vector (αi )i only contains 0 or 1 components.
This proves unforgeability, even with corruptions of the tags, but with a number of signed
messages bounded by n. One can also consider corruptions of the signing keys, as they are all
independent: one just needs to guess under which key will be generated the forgery.
About unlinkability, it relies on the DSqDH assumption, with the same proof as the previous
one-time scheme, except we can consider un-ordered message-sets M :
Theorem 53. The bounded SqDH-based ART-Sign, with message-sets, is unlinkable.
A slightly more compact scheme is described in Appendix B.



92

6 - Anonymous Credentials

6.3

Multi-Authority Anonymous Crendentials

In this section, we first define an anonymous attribute-based credential scheme, in the certified
key setting (we assume a Certification Authority that first checks the knowledge of the secret
keys before certifying public keys. The latter are then always checked before used by any players
in the system). We assume that an identity id is associated (and included) to any vk, which is
in turn included in sk. Then, we will show how to construct such a scheme based on EphemerId
and ART-Sign schemes.

6.3.1

Definition

Our general definition supports multiple users (Ui )i and multiple credential issuers (CIj )j :
Definition 54 — Anonymous Credential
An anonymous credential system is defined by the following algorithms:
Setup(1κ ): It takes as input a security parameter and outputs the public parameters
param;
CIKeyGen(ID): It generates the key pair (sk, vk) for the credential issuer with identity ID;
UKeyGen(id): It generates the key pair (usk, uvk) for the user with identity id;
(CredObtain(usk, vk, a), CredIssue(uvk, sk, a)): A user with identity id (associated to
(usk, uvk)) runs CredObtain to obtain a credential on the attribute a from the credential issuer ID (associated to (sk, vk)) running CredIssue. At the end of the protocol,
the user receives a credential σ;
CredAggr(usk, {(vkj , aj , σj )}j ): It takes as input a secret key usk of a user and a list of credentials (vkj , aj , σj ) and outputs a credential σ of the aggregation of the attributes;
(CredShow(usk, {(vkj ,aj )}j , σ),CredVerify({(vkj ,aj )}j ): In this two-party protocol, a user
with identity id (associated to (usk, uvk)) runs CredShow and interacts with a verifier running CredVerify to prove that he owns a valid credential σ on {aj }j issued
respectively by credential issuers IDj (associated to (skj , vkj )).

6.3.2

Security Model

The security model of anonymous credentials was already defined in various papers. We follow [FHS19, San20], with multi-show unlinkable credentials, but considering multiple credential
issuers. Informally, the scheme needs to have the three properties:
• Correctness: the verifier must accept any credential obtained by an aggregation of honestly
issued credentials on attributes;
• Unforgeability: the verifier should not accept a credential on a set of attributes for which
the user did not obtain all the individual credentials for himself;
• Anonymity: credentials shown multiple times by a user should be unlinkable, even for
the credential issuers. This furthermore implies that credentials cannot be linked to their
owners.
For the two above security notions of unforgeability and anonymity, one can consider malicious
adversaries able to corrupt some parties. We thus define the following lists: HU the list of
honest user identities, CU the list of corrupted user identities, similarly we define HCI and CCI



6.3 - Multi-Authority Anonymous Crendentials

93

for the honest/corrupted credential issuers. For a user identity id, we define Att[id] the list of
the attributes of id and Cred[id] the list of his individual credentials obtained from the credential
issuers. All these lists are initialized to the empty set. For both unforgeability and anonymity,
the adversary has unlimited access to the oracles:
• OHCI(ID) corresponds to the creation of an honest credential issuer with identity ID. If he
already exists (i.e. ID ∈ HCI ∪ CCI), it outputs ⊥. Otherwise, it adds ID ∈ HCI and runs
(sk, vk) ← CIKeyGen(ID) and returns vk;
• OCCI(ID, vk) corresponds to the corruption of a credential issuer with identity ID and
optionally public key vk. If he does not exist yet (i.e. ID ∈
/ HCI ∪ CCI), it creates a new
corrupted credential issuer with public key vk by adding ID to CCI. Otherwise, if ID ∈ HCI,
it removes ID from HCI and adds it to CCI and outputs sk;
• OHU(id) corresponds to the creation of an honest user with identity id. If the user already
exists (i.e. id ∈ HU∪CU), it outputs ⊥. Otherwise, it creates a new user by adding id ∈ HU
and running (usk, uvk) ← UKeyGen(id). It initializes Att[id] = {} and Cred[id] = {} and
returns uvk;
• OCU(id, uvk) corresponds to the corruption of a user with identity id and optionally public
key uvk. If the user does not exist yet (i.e. id ∈
/ HU ∪ CU), it creates a new corrupted user
with public key uvk by adding id to CU. Otherwise, if id ∈ HU, it removes id from HU and
adds it to CU and outputs usk and all the associated credentials Cred[id];
• OObtIss(id, ID, a) corresponds to the issuing of a credential from a credential issuer with
identity ID (associated to (sk, vk)) to a user with identity id (associated to (usk, uvk))
on the attribute a. If id ∈
/ HU or ID ∈
/ HCI, it outputs ⊥. Otherwise, it runs σ ←
(CredObtain(usk, id),CredIssue(uvk, sk, a)) and adds (ID,a) to Att[id] and (ID,a,σ) to Cred[id];
• OObtain(id, ID, a) corresponds to the issuing of a credential from the adversary playing the
role of a malicious credential issuer with identity ID (associated to vk) to an honest user
with identity id (associated to (usk, uvk)) on the attribute a. If id ∈
/ HU or ID ∈
/ CCI, it
outputs ⊥. Otherwise, it runs CredObtain(usk, a) and adds (ID, a) to Att[id] and (ID, a, σ)
to Cred[id];
• OIssue(id, ID, a) corresponds to the issuing of a credential from an honest credential issuer
with identity ID (associated to (sk, vk)) to the adversary playing the role of a malicious
user with identity id (associated to uvk) on the attribute a. If id ∈
/ CU or ID ∈
/ HCI, it
outputs ⊥. Otherwise, it runs CredIssue(uvk, sk, a) and adds (ID, a) to Att[id] and (ID, a, σ)
to Cred[id];
• OShow(id, {(IDj , aj )}j ) corresponds to the showing by an honest user with identity id
(associated to (usk,uvk)) of a credential on the set {(IDj , aj )}j ⊂ Att[id]. If id ∈
/ HU, it
outputs ⊥. Otherwise, it runs CredShow(usk,{(vkj , aj )}j, σ) with the adversary playing
the role of a malicious verifier.
Definition 55 (Unforgeability). An anonymous credential scheme is said unforgeable if, for
any polynomial time adversary adversary A having access to O = {OHCI, OCCI, OHU, OCU,
κ
OObtIss, OIssue, OShow}, Advunf (A) = | Pr[Expunf
A (1 ) = 1]| is negligible where
κ
Expunf
A (1 ):
param ← Setup(1κ )
{(IDj , aj )}j ← AO (param)
b ← (A(), CredVerify({(vkj , aj )}j ))
If ∃id ∈ CU, ∀j, either IDj ∈ CCI, or IDj ∈ HCI and (IDj , aj ) ∈ Att[id],
then return 0
Return b



94

6 - Anonymous Credentials

Intuitively, the adversary wins the security game if it manages to prove its ownership of a
credential, on behalf of a corrupted user id ∈ CU whereas this user did not ask the attributes to
the honest credential issuers. Note that attributes from the corrupted credential issuers can be
generated by the adversary itself, using the secret keys.
Definition 56 (Anonymity). An anonymous credential scheme is said anonymous if, for any
polynomial time adversary A having access to O = {OHCI, OCCI, OHU, OCU, OObtain,
OShow}, Advano (A) = | Pr[Expano−1
(1κ ) = 1] − Pr[Expano−0
(1κ ) = 1]| is negligible where
A
A
ano−b κ
ExpA
(1 ):
param ← Setup(1κ )
(id0 , id1 , {(IDj , aj )}j ) ← AO (param)
If for some IDj , (IDj , aj ) 6∈ Att[id0 ] ∩ Att[id1 ], then return 0
(CredShow(uskb , {aj }j , σ), A())
b∗ ← AO ()
If id0 ∈ CU or id1 ∈ CU, then return 0
Return b∗

First, note that we do not hide the attributes nor the issuers during the showing, but just
the user, as we want to prove their ownership by the anonymous user. Intuitively, the adversary
wins the security game if it can distinguish showings from users id0 and id1 of its choice, on the
same set of attributes {(IDj , aj )}j , even after having verified credentials from the two identities,
as it has access to the oracle OShow. Note that contrarily to [San20], unless the attributes
contain explicit ordering (as it will be the case with our first construction), we are dealing with
unlinkability as soon as the sets of attributes are the same for the two players (with the second
construction).

6.3.3

Anonymous Credential from EphemerId and ART-Sign Scheme

Let E be an EphemerId scheme and Sart an ART-Sign scheme, one can construct an anonymous
attribute-based credential scheme. The user’s keys will be tag pairs and the credentials will be
ART-Sign signatures on both the tags and the attributes. Since the signature is aggregatable
and the tag is randomizable, the user can anonymously show any aggregation of credentials:
Anonymous Credential from EphemerId and ART-Sign Scheme
Setup(1κ ): Given a security parameter κ, it runs Sart .Setup and outputs the public parameters param which includes all the parameters;
CIKeyGen(ID): Credential issuer CI with identity ID, runs Sart .Keygen(param) to obtain
his key pair (sk, vk);
UKeyGen(id): User U with identity id, runs E.GenTag(param) to obtain his key pair
(usk, uvk). In the case witnesses are required for the signatures, (usk, uvk) are provided to the credential issuers;
(CredObtain(usk, a), CredIssue(uvk, sk, a)): User U with identity id and key-pair (usk, uvk)
asks the credential issuer CI for a credential on attribute a: σ = Sart .Sign(sk, uvk, a);
CredAggr(usk, {(vkj , aj , σj )}j ): Given credentials σj on attributes (IDj , aj ) under the same
user key uvk, it outputs the signature
σ = Sart .AggrSign(uvk, {(vkj , aj , σj )}j ) on the set of attributes {aj }j under uvk and
the aggregated verification key avk of all the vkj ;
(CredShow(usk, {(vkj , aj )}j , σ), CredVerify({(vkj , aj )}j ): User U randomizes his public key
(uvk0 , ρ) = E.RandTag(uvk) and computes the aggregated key avk =



6.3 - Multi-Authority Anonymous Crendentials

95

Sart .AggrKey({vkj }j ). Then, it adapts the secret key usk0 = E.DerivWitness(usk, ρ)
as well as the aggregated signature σ 0 = Sart .DerivSign(avk, uvk, {aj }j , σ, ρ) and randomizes it:
σ 00 = Sart .RandSign(avk, uvk0 , {aj }j , σ 0 ). Finally, it sends to the verifier V the
anonymous credential (avk, {aj }j , uvk0 , σ 00 ). The verifier first checks the freshness
of the credential with a proof of ownership of uvk0 using the interactive protocol
(E.ProveKTag(usk0 ), E.VerifKTag(uvk0 )) and then verifies the validity of the credential with
Sart .VerifSign(avk, uvk0 , {aj }j , σ 00 ).
If one considers corruptions, when one corrupts a user, his secret key is provided, when one
corrupts a credential issuer, his secret key is provided.
By replacing all the algorithms by their instantiations for the proposed constructions of
EphemerId and ART-Sign schemes, we obtain our constructions of anonymous attribute-based
credential schemes. The SqDH construction uses an aggregate signature with (public) randomizable tag, and unforgeability holds even if the witnesses are known. As a consequence, this
construction allows corruption of the Credential Issuers and of the users.
Theorem 57. Assuming EphemerId achieves knowledge soundness and ART-Sign is unforgeable,
the generic construction is an unforgeable attribute-based credential scheme, in the certified key
model.
Proof. Let A be an adversary against the unforgeability of our anonymous credential scheme.
We build an adversary B against the unforgeability of the ART-Sign. As we are in the certified
key model, even for the corrupted players, the simulator knows the secret keys, as they can be
extracted at the certification time. Our adversary B runs the unforgeability security game of
the ART-Sign, and answers the oracle queries asked by A as follows:
• OHCI(ID): If ID ∈ HCI ∪ CCI, B outputs ⊥. Otherwise, it adds ID ∈ HCI, asks the query
OKeygen() and forwards the answer to A;
• OCCI(ID, vk): If ID ∈
/ HCI ∪ CCI, B adds ID ∈ CCI. Otherwise, if ID ∈ HCI with keys
(sk, vk), it moves ID from HCI to CCI. It then asks the query OCorrupt(vk) and forwards
the answer to A;
• OHU(id): If id ∈ HU ∪ CU, B outputs ⊥. Otherwise, it adds id ∈ HU, asks the query
OGenTag() and forwards the answer to A;
• OCU(id, uvk): If id ∈
/ HU ∪ CU, B adds id ∈ CU. Otherwise, if id ∈ HU with keys (usk, uvk),
it moves id from HU to CU, asks the query OCorruptTag(uvk) and forwards the answer to
A;
• OObtIss(id, ID, a): If id ∈
/ HU or ID ∈
/ HCI, B outputs ⊥. Otherwise, id is associated to
(usk, uvk) and ID is associated to (sk, vk). Then B asks the query OSign(vk, uvk, a), adds
(ID, a) to Att[id] and (ID, a, σ) to Cred[id] and outputs σ.
• OObtain(id, ID, a): If id ∈
/ HU or ID ∈
/ CCI, B outputs ⊥. Otherwise, id is associated to
(usk, uvk) and ID is associated to (sk, vk). Then B runs σ = Sign(sk, uvk, a) and adds (ID, a)
to Att[id] and (ID, a, σ) to Cred[id];
• OIssue(id, ID, a): If id ∈
/ CU or ID ∈
/ HCI, B outputs ⊥. Otherwise, id is associated to
(usk, uvk) and ID is associated to (sk, vk). Then B runs σ = Sign(sk, uvk, a) and adds
(ID, a) to Att[id] and (ID, a, σ) to Cred[id];



96

6 - Anonymous Credentials
• OShow(id, {(IDj , aj )}j ): If id ∈
/ HU or {(IDj , aj )}j ) 6⊂ Att[id], B outputs ⊥. Otherwise, id
is associated to (usk, uvk) and each IDj is associated to (skj , vkj ). Furthermore, for each
(IDj , aj ), there is σj such that (IDj , aj , σj ) ∈ Cred[id]. Then B first randomizes the key uvk
with (uvk0, ρ) = E.RandTag(uvk), computes the aggregated key avk = Sart .AggrKey({vkj }j )
and adapts the secret key usk0 = E.DerivWitness(usk, ρ). From the obtained credentials
σj , it computes the aggregated signature σ = Sart .AggrSign(uvk, {(vkj , aj , σj )}j ), adapts
it: σ 0 = Sart .DerivSign(avk, uvk, {aj }j , σ, ρ), and randomizes it:
σ 00 = Sart .RandSign(avk, uvk0 , {aj }j , σ 0 ). B outputs (avk, {aj }j , uvk0 , σ 00 ) and makes the
E.ProveKTag(usk0 ) part of the interactive proof of ownership.

Eventually, the adversary A runs a showing for {(vkj , aj )}j , with a credential (avk, {aj }j , uvk∗ , σ ∗ )
and a proof of knowledge of usk∗ associated to uvk∗ : in case of success, B outputs the signature
(avk, {aj }j , uvk∗ , σ ∗ ).
In case of validity of the showing, except with negligible probability,
• from the knowledge soundness of the EphemerId scheme, this means there is id ∈ CU,
associated to (usk, uvk), with uvk ∼ uvk∗ ;
• from the unforgeability of the aggregate signature with randomizable tags, all the tags aj ’s
have been signed for uvk and vk. These individual credentials have thus been issued either
by the adversary on behalf of a corrupted credential issuer IDj ∈ CCI or from an oracle
query to IDj for id.
This is thus a legitimate showing with overwhelming probability: B win with negligible probability. Hence, the adversary A can only win with negligible probability.
As explained above, the security relies on both the soundness of the EphemerId scheme and
the unforgeability of the aggregate signature with randomizable tags. In our construction, the
witness is not needed for signing, and unforgeability of the ART-Sign holds even if the witnesses
are all known to the adversary. Hence, corruption of users would just help to run the proof of
knowledge of the witnesses, and corruption of credential issuers for the issuing of credentials,
which would not help for forgeries (in the above security model). Of course, we also have to take
care of the way keys are generated and the number of signatures that will be issued to guarantee
the unforgeability.
Theorem 58. Assuming EphemerId is zero-knowledge and ART-Sign is unlinkable, the generic
construction is an anonymous attribute-based credential scheme, in the certified key model.
Proof. From the unlinkability of the ART-Sign, the tuple (avk, M , τ 0 , σ 00 ) does not leak any
information about the initial tag τ . Hence, a credential does not leak any information about
uvkb . In addition, if the proof of knowledge of the witness is zero-knowledge, it does not leak
any information about uvkb either.

6.4

SqDH-based Anonymous Credentials

Thanks to our aggregated signatures that tolerate corruptions of users and signers, we will be
able to consider corruptions of users and credential issuers, and even possible collusions. In
the first construction, we consider attributes where the index i determines the topic (age, city,
diploma) and the exact value is encoded in ai ∈ Z∗p (possibly H(m) ∈ Z∗p if the value is a large
bitstring), or 0 when empty. The second construction will not require any such ordering on the
attributes. Free text will be possible.



6.4 - SqDH-based Anonymous Credentials

6.4.1

97

The Basic SqDH-based Anonymous Credential Scheme

The basic construction directly follows the instantiation of the above construction with the
SqDH-based ART-Sign:
Basic SqDH-based ART-Sign Scheme
Setup(1κ ): Given a security parameter κ, let (G1 , G2 , GT , p, g, g, e) be an asymmetric bilinear setting, where g and g are random generators of G1 and G2 respectively. We
then define param = (G1 , G2 , GT , p, g, g, e, H), where H is an hash function in G1 ;
CIKeyGen(ID): Credential issuer CI with identity ID, generates its keys for n kinds of
attributes
skj = ( SKj = [ t, u, v ], SK0j,i = [ ri , si
vkj = ( VKj = [ gt , gu , gv ], VK0j,i = [ gri , gsi

$
]i ) ←
Z3+2n
,
p
]i ) ∈ G3+2n
.
2

More keys for new attributes can be generated on-demand: by adding the pair
$
[r, s] ←
Z2p to the secret key and [gr , gs ] to the verification key, the keys can works
on n + 1 kinds of attributes;
UKeyGen(id): User U with identity id, sets h = H(id) ∈ G∗1 , generates its secret tag
2
$
τ̃ ←
Z∗p jointly with CA and computes τ = (h, hτ̃ , hτ̃ ) ∈ G31 : usk = τ̃ and uvk =
2
τ = (h, hτ̃ , hτ̃ );
(CredObtain(usk, ai ), CredIssue(uvk, sk, ai )): User U with identity id and uvk = (τ1 , τ2 , τ3 )
asks to the credential issuer CI for a credential on the attribute ai : σ = τ1t+ri +ai si ×
τ2u × τ3v . The credential issuer uses the appropriate index i, making sure this is the
first signature for this index;
CredAggr(usk, {(VKj , VK0j,i , aj,i , σj,i )}j,i ): Given credentials σj,i on attributes (IDj , aj,i ) unQ
der the same user key uvk, it outputs the signature σ = j,i σj,i ;
(CredShow(usk, {(VKj , VK0j,i , aj,i )}j,i , σ), CredVerify({(VKj , VK0j,i , aj,i )}j,i ):
$
First, user U randomizes his public key with a random ρ ←
Z∗p into uvk0 =
(τ1ρ , τ2ρ , τ3ρ ), concatenates the keys avk = ∪j ([VKj ] ∪ [VK0j,i ]i ), and adapts the signature σ 0 = σ ρ . Then it sends the anonymous credential (avk, {aj,i }j,i , uvk0 , σ 0 ) to
the verifier. The latter first checks the freshness of the credential with a proof of
ownership and validity of uvk0 using a Schnorr-like interactive proof and then verifies
the validity of the credential: with nj = #{VK0j,i }:




e(σ, g) = e τ1 ,

Y

VKj,1 nj ×

j

VK0j,i,1 · VK0j,i,2

aj,i 

i



× e τ2 ,

Y


Y
j



VKj,2 nj  × e τ3 ,


Y

VKj,3 nj  .

j

We stress that for the unforgeability of the signature, generator h for each tag must be
random, and so it is generated as H(id), with a hash function H in G1 that we model as a
random oracle in the security proof. This way, the credential issuers will automatically know
the basis for each user. There is no privacy issue as this basis is randomized when used in an
anonymous credential. Moreover, the user needs his secret key τ̃ to be random. Therefore, he
jointly generates τ̃ with the Certification Authority (see Appendix A). During the showing of a
credential, the user has to prove the knowledge of the witness for the validity of the tag. This



98

6 - Anonymous Credentials

is thus an interactive protocol. In this construction, we can consider a polynomial number n
of attributes per credential issuer, where ai is associated to key vkj,i of the Credential Issuer
CIj . Again, to keep the unforgeability of the signature, the credential issuer should provide
at most one attribute per key vkj,i for a given tag. At the showing time, for proving the
ownership of k attributes (possibly from K different credential issuers), the users has to perform
k − 1 multiplications in G1 to aggregate the credentials into one, and 4 exponentiations in G1
for randomization, but just one element from G1 is sent, as anonymous credential, plus an
interactive Schnorr-like proof of SqDH-tuple with knowledge of usk (see 4.4: 2 exponentiations
in G1 , 2 group elements from G1 , and a scalar in Zp ); whereas the verifier first has to perform
4 exponentiations and 2 multiplications in G1 for the proof of validity/knowledge of usk, and
less than 3k multiplications and k exponentiations in G2 , and 3 pairings to check the credential.
While this is already better than [CL11], we can get a better construction.

6.4.2

A Compact SqDH-based Anonymous Credential Scheme

Instead of having a specific key VK0j,i for each family of attributes aj,i , and thus limiting to one
issuing per family of attributes for each user, we can use the bounded SqDH-based ART-Sign,
with free-text attributes: we consider 2n − 1 keys, where n is the maximum number of attributes
issued for one user by a credential issuer, whatever the attributes are:
Bounded SqDH-based ART-Sign Scheme
Setup(1κ ): Given a security parameter κ, let (G1 , G2 , GT , p, g, g, e) be an asymmetric bilinear setting, where g and g are random generators of G1 and G2 respectively. We
then define param = (G1 , G2 , GT , p, g, g, e, H), where H is an hash function in G1 ;
CIKeyGen(ID): Credential issuer CI with identity ID, generates its keys for n maximum
attributes per user
$
= [ t, u, v, s1 , . . . , s2n−1 ] ←
Zp2n+2 ,
= [ T, U, V, S1 , . . . , S2n−1 ] ∈ G22n+2 .

skj
vkj = gskj

UKeyGen(id): User U with identity id, sets h = H(id) ∈ G∗1 , generates its random secret
2
$
tag τ̃ ←
Z∗p jointly with CA and computes τ = (h, hτ̃ , hτ̃ ) ∈ G31 : usk = τ̃ and
2
uvk = τ = (h, hτ̃ , hτ̃ );
(CredObtain(usk, a), CredIssue(uvk, sk, a)): User U with identity id and uvk =P(τ1 , τ2 , τ3 )
2n−1
t+ `=1 s` a`
asks to the credential issuer CI for a credential on the attribute a: σ = τ1
×
τ2u × τ3v . Note that a ∈ Z∗p , so it can be a hash value of the actual free-text attribute;
CredAggr(usk, {(vkj , aj,i , σj,i )}j,i ): Given credentials σj,i on attributes (IDj , aj,i ) under the
Q
same user key uvk, it outputs the signature σ = j,i σj,i ;
(CredShow(usk, {(vkj , aj,i )}j,i , σ), CredVerify({(vkj , aj,i )}j,i ): First, a user U randomizes
$
his public key with a random ρ ←
Z∗p , uvk0 = (τ1ρ , τ2ρ , τ3ρ ), concatenates the keys
avk = ∪j [vkj ], and adapts the signature σ 0 = σ ρ . Then it sends the anonymous
credential (avk, {aj,i }j,i , uvk0 , σ 0 ) to the verifier. The latter first checks the freshness
of the credential with a proof of ownership and validity of uvk0 using a Schnorr-like
interactive proof and then verifies the validity of the credential: with nj = #{aj,i }:







Y nj 2n−1
Y P a`j,i
Y nj
Y nj
e(σ, g) = e τ1 ,
Tj
Uj  × e τ3 ,
Vj 
Sj,` i  × e τ2 ,
j

`=1

j

j



6.5 - Traceable Anonymous Credentials

99

Again, we stress that for the unforgeability of the signature, generator h for each tag and τ̃
must be random. And the credential issuer should provide at most n attributes per user, even if
in this construction, we can consider an exponential number N of attributes per credential issuer,
as aj,i is any scalar in Z∗p . More concretely, aj,i can be given as the output of a hash function
into Zp from any bitstring. At the showing time, for proving the ownership of k attributes
(possibly from K different credential issuers), the users has to perform k − 1 multiplications in
G1 to aggregate the credentials into one, and 4 exponentiations in G1 for randomization, but
just one group element for G1 is sent, as anonymous credential, plus an interactive Schnorr-like
proof of SqDH-tuple with knowledge of usk (see 4.4: 2 exponentiations in G1 , 2 group elements
from G1 , and a scalar in Zp ); whereas the verifier first has to perform 4 exponentiations and
2 multiplications in G1 for the proof of validity/knowledge of usk, and less than 2n · (K + 3k)
multiplications in G2 , 2n · k exponentiations in G2 and 3 pairings to check the credential.
In the particular case of just one credential issuer with verification key vk = (T, U, V, [Si ]2n−1
i=1 ),
the verification of the credential σ on the k attributes {ai } just consists of
e(σ, g) = e τ1 , T k

2n−1
Y

P

S`

a`
i i

!









× e τ2 , U k × e τ3 , V k .

`=1

The communication is of constant size (one group element in G1 ). We stress that n is just a
limit of the maximal number of attributes issued by the credential issuer for one user but the
universe of the possible attributes is exponentially large, and there is no distinction between the
families of attributes.

6.5

Traceable Anonymous Credentials

As the SqDH-based ART-Sign schemes provide computational unlinkability only, it opens the
door for possible traceability in case of abuse, with anonymous but traceable tags:
Definition 59 — Traceable EphemerId
This is an extension of an EphemerId scheme with a modified GenTag algorithm and an
additional TraceId one:
GenTag(1κ ): Given a security parameter 1κ , it outputs the user-key pair (usk,uvk) and
the tracing key utk;
TraceId(utk, uvk0 ): Given the tracing key utk associated to uvk and a public key uvk0 , it
outputs a proof π of whether uvk ∼ uvk0 or not.
JudgeId(uvk, uvk0 , π): two public keys and a proof, the judge checks the proof π and outputs 1 if it is correct.
Providing the tracing keys to a tracing authority during the key generation for the users will
allow traceability.

6.5.1

Traceable Anonymous Credentials

For traceability, we need an additional player: the tracing authority. During the user’s key
generation, this tracing authority will either be the certification authority, or a second authority,
that also has to certify user’s key uvk once it has received the tracing key utk.
In case of abuse of a credential σ under anonymous key uvk0 , a tracing algorithm outputs
the initial uvk and id, with a proof a correct tracing. A new security notion is quite important:
non-frameability, which means that the tracing authority should not be able to declare guilty
a wrong user: only correct proofs are accepted by the judge. We consider a non-interactive



100

6 - Anonymous Credentials

proof of tracing, produced by the TraceId algorithm and verified by anybody using the JudgeId
algorithm. This proof could be interactive.

6.5.2

Traceable SqDH-based Anonymous Credentials
2

With our Square Diffie-Hellman based EphemerId scheme where uvk = τ = (h, hτ̃ , hτ̃ ) in an
asymmetric bilinear setting (G1 , G2 , GT , p, g, g, e) where g and g are random generators of G1
and G2 respectively, usk = τ̃ and utk = gτ̃ . The latter tracing key indeed allows to check whether
τ 0 ∼ τ or not: e(τ10 , utk) = e(τ20 , g) and e(τ20 , utk) = e(τ30 , g). If one already knows the tags are
valid (SqDH tuples), this is enough to verify whether e(τ10 , utk) = e(τ20 , g) holds or not. But
we provide the complete proof, as it is already quite efficient: in order to prove it, the TraceId
algorithm can use a Groth-Sahai proof as shown in 6.5.3 that proves, in a zero-knowledge way,
the existence of utk such that
e(τ1 , utk) = e(τ2 , g)

e(τ2 , utk) = e(τ3 , g)

e(τ10 , utk)

e(τ20 , utk) = e(τ30 , g).

=

e(τ20 , g)

The first line proves that utk is the good tracing key for uvk = τ , and the second line shows it
applies to uvk0 = τ 0 too. These are the equations verified by JudgeId algorithm. This can also
be a proof of innocence of id with key uvk if the first line is satisfied while the second one is not.
With such a proof, the tracing authority cannot frame a user. We thus have a secure traceable
anonymous credential scheme. Note however that, since we let the user choose the secret key τ̃ in
GenTag, one user could decide to use the same as another user. Either the tracing authority first
checks that, using the new tracing key on all the previous tags, and reject, or this is considered
a collusion of users, and at the tracing time, both users will be accused.

6.5.3

Groth-Sahai Proof for Square Diffie-Hellman Tracing

For the proof of tracing, one wants to show τ 0 ∼ τ , where τ is the reference tag for a user
(certified at the registration time). With the tracing key utk = gτ̃ , one needs to show
e(τ1 , utk) = e(τ2 , g)

e(τ2 , utk) = e(τ3 , g)

e(τ10 , utk)

e(τ20 , utk) = e(τ30 , g)

=

e(τ20 , g)

$
but without revealing utk ∈ G2 . This is equivalent, for random α1 , α2 , α10 , α20 ←
Zp , to have:

e(T1 , utk) = e(T2 , g)

with

T1 = τ1 α1 · τ2 α2 · τ10

α01

· τ20

α02

T2 = τ2 α1 · τ3 α2 · τ20

α01

· τ20

α02

One can commit utk: as above, with the reference string (v1,1 , v1,2 , v2,1 , v2,2 ) ∈ G42 , such that
(v1,1 , v1,2 , v2,1 , v2,2 ) is a Diffie-Hellman tuple, one computes Com = (c = vλ2,1 vµ1,1 , d = vλ2,2 vµ1,2 ×
$
utk), for random λ, µ ←
Zp , and one sets π1 = T1λ and π2 = T1µ , which should satisfy

e(T1 , c) = e(π1 , v2,1 ) · e(π2 , v1,1 )

e(T1 , d) = e(T2 , g) · e(π1 , v2,2 ) · e(π2 , v1,2 )

The random values α1 , α2 , α10 , α20 can be either chosen by the verifier in case of interactive proof,
or set from H(τ1 , τ2 , τ3 , τ10 , τ20 , τ30 ).

6.6

Related Work

On Figure 6.1, we provide some comparisons with the most efficient ABC schemes, where the
column “P” (for policy) indicates whether the scheme just allows selective disclosure of attributes



6.6 - Related Work

Scheme
[CL11]
[FHS19]
[San20]
Sec. 6.4.1
Sec. 6.4.2
Scheme
[CL11]
[FHS19]
[San20]
Sec. 6.4.1
Sec. 6.4.2

101

k-of-N attributes from K = 1 credential issuer
P T
|CI key|
|Show|
Prover
Verifier
G1 , G2
G1 , G2 , (GT ), Zp
exp., pairings
exp., pairings
s 7
1, 1
16, 2, (4), 7
16G1 + 2G2 + 10GT ,
12G1 + 20GT ,
18 + k
18 + k
s 7
0, N
8, 1, 2
9G1 + 1G2 , 0
4G1 , k + 4
r 7 0, 2N + 1
2, 2, (1), 2
(2(N −k)+2)G1
(k+1)G1 + 1GT ,
+2G2 , 1
5
s 3
0, 2k + 3
3, 0, 1
6G1 , 0
4G1 + kG2 , 3
s 3 0, 2N + 2
3, 0, 1
6G1 , 0
4G1 + 2NG2 , 3
k = 1-of-N attribute from K credential issuers
|CI key|
|Show|
Prover
Verifier
G1 , G2
G1 , G2 , (GT ), Zp
exp., pairings
exp., pairings
K×(1, 1)
16, 2, (4), 7
16G1 + 2G2 + 10GT ,
12G1 + 20GT ,
18 + k
18 + k
K ×(0, N )
K ×(8, 1, 2)
K ×(9G1 + 1G2 , 0)
K ×(4G1 , k + 4)
K ×(0, 2N + 1) K ×(2, 2, (1), 2) K ×((2(N −k)+2)G1 K ×((k+1)G1 +
+2G2 , 1)
1GT , 5)
K ×(0, 2k + 3)
3, 0, 1
6G1 , 0
4G1 + kG2 , 3
K ×(0, 2N + 2)
3, 0, 1
6G1 , 0
4G1 + 2KNG2 , 3
Figure 6.1: Comparison of different ABC systems.

(s) or relations between attributes (r). The column “T” (for traceability) checks whether traceability is possible or not. Then, “|CI key|” gives the size of the keys (public keys of the credential
issuers) required to verify the credentials, “|Show|” is the communication bandwidth during a
show, while “Prover” and “Verifier” are the computational cost during a show, for the prover
and the verifier respectively. Bandwidths are in number of elements G1 , G2 , GT and Zp . Computations are in number of exponentiations in G1 , G2 and GT , and of pairings. We ignore
multiplications. We denote N the global number of attributes owned by a user, k the number
of attributes he wants to show and K the number of credential issuers involved in the issuing
of the credentials. In the first table, we focus on the particular case of proving a credential
with k attributes, among N attributes issued from 1 credential issuer. Our first scheme, from
Section 6.4.1, is already the most efficient, but this is even better for a larger K, as shown
in the second table. But this is for a limited number of attributes. Our second scheme, from
Section 6.4.2 has similar efficiency, but with less limitations on the attributes. Note that both
schemes have a constant-size communication for the showing of any number of attributes, and
the computation cost for the prover is almost constant too (as we ignore multiplications).
Canard-Lescuyer Scheme. In 2013, Canard and Lescuyer proposed a traceable attributebased anonymous credential scheme [CL13], based on sanitizable signatures: “Protecting privacy
by sanitizing personal data: a new approach to anonymous credentials”.
The intuition consists in allowing the user to “sanitize” the global credentials issued by the
credential issuer, in order to keep visible only the required attributes. Then for unlinkability,
the signatures are encrypted under an ElGamal encryption scheme.
$
Unfortunately, we found an attack in their scheme. The public key contains g ←
G1 and
$
$
g ← G2 , and the ElGamal secret key is α ← Zp , the tracing key. The public encryption key is
h = g α , but they also need h = gα to be published for some verifications.
With this value h, anybody can break the semantic security of the ElGamal encryption, and
then break the privacy of the anonymous credential.



102

6 - Anonymous Credentials



Chapter

7

Conclusion

This thesis proposed new protocols integrating privacy by design and made its contribution to
decentralization, electronic voting and anonymous authentication.
We have first presented in chapter 3 a new decentralized encryption scheme. It makes possible
for a company to study encrypted databases of users by authorizing evaluations of quadratic
polynomials on them, while at the same time, maintaining a level of security by controlling the
computations. Hence, the company is forced by the system to recover only the result of the
evaluation and nothing more.
Then, we studied in chapter 4 the linearly homomorphic signatures with two particular
schemes. They feature tag randomizability, a property of great interest in our use-cases. While
the first scheme only has one class of equivalence for tags and thus, ensures perfect anonymity,
we proposed a second one with multiple classes so that a user can be anonymous within it. Both
are proven secure in the Generic Bilinear Group Model and building such a scheme remains an
issue in the standard model. Without the tag randomizability property, linearly homomorphic
signature constructions are already known but the tag is usually hashed which is not compatible
with randomizability.
Thanks to the LH-Sign scheme with randomizable tags, we constructed two schemes:
• A new method to build mix-networks,
• A new traceable multi-authority anonymous credential protocol.
The mix-networks scheme presented in chapter 5 followed a totally new approach compared
to the previously known solutions. We avoided the proof of an explicit permutation on all
the ciphertexts (per mixing step) extensively using the linearly-homomorphic signature schemes
with tag randomizability. That made the proof of correctness implicit.
The computational complexity for each mix-server is linear in the number of ballots. The
final proof implies just a constant-size overhead and the verification is also linear in the number
of ballots, but independent of the number of rounds of mixing. This led to a highly scalable
technique.
Finally, the anonymous credential protocol presented in chapter 6 is multi-user - a user can
anonymously show a constant-size credential coming from several credential issuers - and for the
first time traceable: the anonymity may be revoked by a judge in case of abuse.
While we optimized the size of a credential for a showing, the credential issuers needs to
send the attributes individually. Whereas with redactable signatures it is possible to send one
signature on all the attributes and then, redact some of them. One open problem is then to find
a signature scheme including both properties: aggregatable and redactable. This could lead to
more efficient scheme by improving the memory cost of a user.
All of the studied scenarios required new and more complex security concepts than the
already existing ones. We used the homomorphic property of encryptions a lot, signatures and
even zero-knowledge proofs but each time the malleability needed to be controlled.



104

7 - Conclusion



Appendix

A

Joint Generation of Square
Diffie-Hellman Tuples

As already explained, for the unlinkability property to hold in the anonymous credential protocol,
we need the user secret key usk = τ̃ random. Of course, this could be done with generic two-party
computation, between the user and the Certification Authority.
$
Zp and computes (A1 = hτ̃1 , B1 = Aτ̃11 ).
• The user chooses τ̃1 ←
$
Zp and computes
• On its side, the Certification Authority chooses τ̃2 ←

A = A1 · hτ̃2 = hτ̃1 +τ̃2

2

2

B = B1 · (A21 · hτ̃2 )τ̃2 = Aτ̃11 · A12τ̃2 hτ̃2 = h(τ̃1 +τ̃2 ) .

It then sends and certifies τ = (h, A, B) together with τ̃2 so that the user can compute
τ̃ = τ̃1 + τ̃2 .



106

A - Joint Generation of Square Diffie-Hellman Tuples



Appendix

B

Another Bounded SqDH-Based
ART-Sign

We can slightly reduce the parameters of the bounded SqDH-based ART-Sign, but with some
limitations on the number of attributed to be signed. It relies on a hash function, modelled as
a random oracle in the security analysis.
Description of the Bounded SqDH-based ART-Sign Scheme 2.
We thus propose here a second version, still with the limitation on the total number of messages
signed for each tag, but the public keys are twice smaller:
Bounded SqDH-based ART-Sign Scheme 2
It extends the above EphemerId-setup with the set of messages M = {0, 1}∗ ,
but also a hash function H into Zp ;

Setup(1κ ):

Keygen(param, n): Given the public parameters param and a length n, it outputs the
signing and verification keys
skj
vkj = gskj

$
= [ t, u, v, s1 , . . . , sn ] ←
Zn+3
,
p
n+3
= [ T, U, V, S1 , . . . , Sn ] ∈ G2 .

Sign(skj , τ, m): Given a signing key skj = [t, u, v, s1 , . . . , sn ], a message m ∈ Zp and a
public tag τ = (τ1 , τ2 , τ3 ), it outputs the signature
Pn

t+

σ = τ1

s H(m)`
`=1 `

× τ2u × τ3v .

AggrKey({vkj }j ): Given verification keys vkj , it outputs the aggregated verification key
avk = [vkj ]j ;
AggrSign(τ, (vkj , mj,i , σj,i )j,i ): Given tuples of verification key vkj , message mj,i and sigQ
nature σj,i all under the same tag τ , it outputs the signature σ = j,i σj,i of the
concatenation of the messages verifiable with avk ← AggrKey({vkj }j );
DerivSign(avk, τ, M , σ, ρτ →τ 0 ): Given a signature σ on tag τ and a message-set M , and
ρτ →τ 0 the randomization link between τ and another tag τ 0 , it outputs σ 0 = σ ρτ →τ 0 ;
RandSign(avk, τ, M , σ): The scheme being deterministic, it returns σ;
VerifSign(avk, τ, M , σ): Given a valid tag τ = (τ1 , τ2 , τ3 ), an aggregated verification key
avk = [vkj ]j and a message-set M = [mj ]j , with for each j, mj = [mj,i ]i , and a
signature σ, one checks if the following equality holds or not, where nj = #{mj,i }:


e(σ, g) = eτ1 ,

Y nj

Tj ×

j


P
n
`
Y
H(mj,i )
i


Sj,`

`=1



× eτ2 ,


Y
j

n



Uj,2j  × eτ3 ,


Y
j

n

Vj,3j 



108

B - Another Bounded SqDH-Based ART-Sign

We also recall that the validity of the tag has to be verified, as before, for the signature to
be considered valid.
Security of the Bounded SqDH-based ART-Sign Scheme 2.
The linear homomorphism of the signature from [HPP20] still allows combinations. But when
the number of signing queries is at most n per tag, the verification of the signature implies 0/1
coefficients only, with overwhelming probability:
Theorem 60. The bounded SqDH-based ART-Sign defined above is unforgeable with a bounded
number of signing queries per tag, even with adaptive corruptions of keys and tags, in both the
n  p, where q is the number
generic group model and the random oracle model, as soon as qH
H
of hash queries and p the order of the group (the output of the hash function).
Proof. As argued in [HPP20], when the bases of the tags are random, even if the exponents
1
n
are known, the signature that would have signed messages M = (g m , . . . , g m ), for m ∈ Zp ,
is an unforgeable linearly-homomorphic signature. This means it is only possible to linearly
combine signatures with the same tag: from up to n signatures σi ondistinct
messages
P
P mi , nfor

Q αi
1
α
m
αm
i
i,...,g
i i i .
i = 1, . . . , n under vkj , one can derive the signature σ = σi on g i
 P

1

Whereas the forger claims this is a signature on g i ai , . . . , g
P
Because of the constraint on τ2 , we have αi = nj mod p:
n
X

αi m`i =

i=1

nc
X

a`i mod p

P
i

αi an
i



, on nj values a1 , . . . , anj .

for ` = 0, . . . , n

i=1

Let us first move on the left hand side the elements ak ∈ {mi }, with only n0 ≤ nj new elements,
we assume to be the first ones, and we note βi = αi if mi 6∈ {ak } and or βi = αi − 1 if mi ∈ {ak }:
n
X

0

βi m`i =

i=1

n
X

a`i mod p

for ` = 0, . . . , n

i=1

Our goal is to prove that n0 = 0 and the αi ’s are only 0 or 1.
So, first, let us assume that n0 = 0: there is no new element. The matrix (m`i )i,` , for
i = 1, . . . , n and ` = 0, . . . , n − 1 is a Vandermonde matrix, that is invertible: hence the unique
possible vector (βi ) is the zero-vector. As a consequence, the vector (αi )i only contains 0 or 1
components.
Now, we assume n0 = 1: there is exactly one element a1 6∈ {mi }. We can move it on the left
side:
β0 a`1 +

n
X

βm`i = 0 mod p

for ` = 0, . . . , n, with β0 = −1

i=1

Again, the matrix (m`i )i,` , for i = 0, . . . , n where we denote m0 = a1 , and ` = 0, . . . , n, is a
Vandermonde matrix, that is invertible: hence the unique possible vector (βi ) is the zero-vector,
which contradicts the fact that β0 = −1.
Eventually, we assume n0 > 1: there are at least two elements ak 6∈ {mi }. We can move a1 on
the left side:
β0 a`1

+

n
X
i=1

0

βm`i

=

n
X

a`i mod p

for ` = 0, . . . , n, with β0 = −1

i=2

Again, because of the invertible matrix, for the n0 − 1 elements on the right hand side, there is
a unique possible vector (βi ), and the probability for β0 = −1 is negligible, as the new elements



109
ak are random (if they are issued from a hash value): probability 1/p for each possible choice
n  p, the probability
on the n0 − 1 < n attributes on the right hand side. Hence, as soon as qH
for a combination to allow β0 = −1 is negligible.
As a conclusion, one can only combine initial messages with a weight 1 (or 0). This proves
unforgeability, even with corruptions of the tags, but with a number of signed messages bounded
by n, and random messages (issued from a hash function). One can also consider corruptions of
the signing keys, as they are all independent: one just needs to guess under which key will be
generated the forgery.
Unlinkability remains unchanged.



110

B - Another Bounded SqDH-Based ART-Sign



Bibliography
[ABC+ 12]

Jae Hyun Ahn, Dan Boneh, Jan Camenisch, Susan Hohenberger, abhi shelat, and
Brent Waters. Computing on authenticated data. In Ronald Cramer, editor,
TCC 2012, volume 7194 of LNCS, pages 1–20, Taormina, Sicily, Italy, March 19–21,
2012. Springer, Heidelberg, Germany.
Cited on pages 6 and 47.

[ABKW19] Michel Abdalla, Fabrice Benhamouda, Markulf Kolhweiss, and Hendrik Waldner.
Decentralizing inner-product functional encryption. Cryptology ePrint Archive,
Report 2019/020, 2019. https://eprint.iacr.org/2019/020. Cited on page 4.
[AFG+ 10]

Masayuki Abe, Georg Fuchsbauer, Jens Groth, Kristiyan Haralambiev, and Miyako
Ohkubo. Structure-preserving signatures and commitments to group elements. In
Tal Rabin, editor, CRYPTO 2010, volume 6223 of LNCS, pages 209–236, Santa
Barbara, CA, USA, August 15–19, 2010. Springer, Heidelberg, Germany. Cited on
page 20.

[AHM+ 18] Nuttapong Attrapadung, Goichiro Hanaoka, Shigeo Mitsunari, Yusuke Sakai, Kana
Shimizu, and Tadanori Teruya. Efficient two-level homomorphic encryption in
prime-order bilinear groups and A fast implementation in WebAssembly. In Jong
Kim, Gail-Joon Ahn, Seungjoo Kim, Yongdae Kim, Javier López, and Taesoo Kim,
editors, ASIACCS 18, pages 685–697, Incheon, Republic of Korea, April 2–6, 2018.
ACM Press.
Cited on page 26.
[BBG05]

Dan Boneh, Xavier Boyen, and Eu-Jin Goh. Hierarchical identity based encryption
with constant size ciphertext. In Ronald Cramer, editor, EUROCRYPT 2005, volume 3494 of LNCS, pages 440–456, Aarhus, Denmark, May 22–26, 2005. Springer,
Heidelberg, Germany.
Cited on page 49.

[BBP19]

Olivier Blazy, Laura Brouilhet, and Duong Hieu Phan. Anonymous identity based
encryption with traceable identities. 2019.
Cited on page 5.

[BBS98]

Matt Blaze, Gerrit Bleumer, and Martin Strauss. Divertible protocols and atomic
proxy cryptography. In Kaisa Nyberg, editor, EUROCRYPT’98, volume 1403 of
LNCS, pages 127–144, Espoo, Finland, May 31 – June 4, 1998. Springer, Heidelberg,
Germany.
Cited on page 32.

[BCC+ 09]

Mira Belenkiy, Jan Camenisch, Melissa Chase, Markulf Kohlweiss, Anna Lysyanskaya, and Hovav Shacham. Randomizable proofs and delegatable anonymous credentials. In Shai Halevi, editor, CRYPTO 2009, volume 5677 of LNCS, pages
108–125, Santa Barbara, CA, USA, August 16–20, 2009. Springer, Heidelberg, Germany.
Cited on
page 22.

[BCFG17]

Carmen Elisabetta Zaira Baltico, Dario Catalano, Dario Fiore, and Romain Gay.
Practical functional encryption for quadratic functions with applications to predicate encryption. In Jonathan Katz and Hovav Shacham, editors, CRYPTO 2017,



112

BIBLIOGRAPHY
Part I, volume 10401 of LNCS, pages 67–98, Santa Barbara, CA, USA, August 20–
24, 2017. Springer, Heidelberg, Germany.
Cited on
page 4.

[BDN18]

Dan Boneh, Manu Drijvers, and Gregory Neven. Compact multi-signatures for
smaller blockchains. In Thomas Peyrin and Steven Galbraith, editors, ASIACRYPT 2018, Part II, volume 11273 of LNCS, pages 435–464, Brisbane, Queensland, Australia, December 2–6, 2018. Springer, Heidelberg, Germany.
Cited on
pages 20, 21, 67, and 84.

[BF11a]

Dan Boneh and David Mandell Freeman. Homomorphic signatures for polynomial
functions. In Kenneth G. Paterson, editor, EUROCRYPT 2011, volume 6632 of
LNCS, pages 149–168, Tallinn, Estonia, May 15–19, 2011. Springer, Heidelberg,
Germany.
Cited on pages 6 and 47.

[BF11b]

Dan Boneh and David Mandell Freeman. Linearly homomorphic signatures over
binary fields and new tools for lattice-based signatures. In Dario Catalano, Nelly
Fazio, Rosario Gennaro, and Antonio Nicolosi, editors, PKC 2011, volume 6571
of LNCS, pages 1–16, Taormina, Italy, March 6–9, 2011. Springer, Heidelberg,
Germany.
Cited on pages 6 and 47.

[BFI+ 10]

Olivier Blazy, Georg Fuchsbauer, Malika Izabachène, Amandine Jambert, Hervé
Sibert, and Damien Vergnaud. Batch Groth-Sahai. In Jianying Zhou and Moti
Yung, editors, ACNS 10, volume 6123 of LNCS, pages 218–235, Beijing, China,
June 22–25, 2010. Springer, Heidelberg, Germany. Cited on pages 22, 54, and 67.

[BFKW09] Dan Boneh, David Freeman, Jonathan Katz, and Brent Waters. Signing a linear
subspace: Signature schemes for network coding. In Stanislaw Jarecki and Gene
Tsudik, editors, PKC 2009, volume 5443 of LNCS, pages 68–87, Irvine, CA, USA,
March 18–20, 2009. Springer, Heidelberg, Germany.
Cited on pages 6 and 47.
[BFPV11]

Olivier Blazy, Georg Fuchsbauer, David Pointcheval, and Damien Vergnaud. Signatures on randomizable ciphertexts. In Dario Catalano, Nelly Fazio, Rosario Gennaro, and Antonio Nicolosi, editors, PKC 2011, volume 6571 of LNCS, pages 403–
422, Taormina, Italy, March 6–9, 2011. Springer, Heidelberg, Germany. Cited on
page 8.

[BGLS03]

Dan Boneh, Craig Gentry, Ben Lynn, and Hovav Shacham. Aggregate and verifiably
encrypted signatures from bilinear maps. In Eli Biham, editor, EUROCRYPT 2003,
volume 2656 of LNCS, pages 416–432, Warsaw, Poland, May 4–8, 2003. Springer,
Heidelberg, Germany.
Cited on page 84.

[BGN05]

Dan Boneh, Eu-Jin Goh, and Kobbi Nissim. Evaluating 2-DNF formulas on ciphertexts. In Joe Kilian, editor, TCC 2005, volume 3378 of LNCS, pages 325–341,
Cambridge, MA, USA, February 10–12, 2005. Springer, Heidelberg, Germany. Cited
on pages 8, 17, 25, and 44.

[BLS01]

Dan Boneh, Ben Lynn, and Hovav Shacham. Short signatures from the Weil pairing.
In Colin Boyd, editor, ASIACRYPT 2001, volume 2248 of LNCS, pages 514–532,
Gold Coast, Australia, December 9–13, 2001. Springer, Heidelberg, Germany. Cited
on pages 20 and 84.

[BNN07]

Mihir Bellare, Chanathip Namprempre, and Gregory Neven. Unrestricted aggregate signatures. In Lars Arge, Christian Cachin, Tomasz Jurdzinski, and Andrzej
Tarlecki, editors, ICALP 2007, volume 4596 of LNCS, pages 411–422, Wroclaw,
Poland, July 9–13, 2007. Springer, Heidelberg, Germany.
Cited on page 20.



BIBLIOGRAPHY

113

[Boy08]

Xavier Boyen. The uber-assumption family (invited talk). In Steven D. Galbraith
and Kenneth G. Paterson, editors, PAIRING 2008, volume 5209 of LNCS, pages
39–56, Egham, UK, September 1–3, 2008. Springer, Heidelberg, Germany. Cited
on page 49.

[BR93]

Mihir Bellare and Phillip Rogaway. Random oracles are practical: A paradigm for
designing efficient protocols. In Dorothy E. Denning, Raymond Pyle, Ravi Ganesan,
Ravi S. Sandhu, and Victoria Ashby, editors, ACM CCS 93, pages 62–73, Fairfax,
Virginia, USA, November 3–5, 1993. ACM Press.
Cited on page 13.

[BSW11]

Dan Boneh, Amit Sahai, and Brent Waters. Functional encryption: Definitions and
challenges. In Yuval Ishai, editor, TCC 2011, volume 6597 of LNCS, pages 253–273,
Providence, RI, USA, March 28–30, 2011. Springer, Heidelberg, Germany. Cited
on page 4.

[CC09]

Melissa Chase and Sherman S. M. Chow. Improving privacy and security in multiauthority attribute-based encryption. In Ehab Al-Shaer, Somesh Jha, and Angelos D. Keromytis, editors, ACM CCS 2009, pages 121–130, Chicago, Illinois, USA,
November 9–13, 2009. ACM Press.
Cited on page 4.

[CDG+ 18a] Jérémy Chotard, Edouard Dufour Sans, Romain Gay, Duong Hieu Phan, and David
Pointcheval. Decentralized multi-client functional encryption for inner product. In
Thomas Peyrin and Steven Galbraith, editors, ASIACRYPT 2018, Part II, volume
11273 of LNCS, pages 703–732, Brisbane, Queensland, Australia, December 2–6,
2018. Springer, Heidelberg, Germany.
Cited on page 4.
[CDG+ 18b] Jérémy Chotard, Edouard Dufour Sans, Romain Gay, Duong Hieu Phan, and David
Pointcheval. Multi-client functional encryption with repetition for inner product.
Cryptology ePrint Archive, Report 2018/1021, 2018. https://eprint.iacr.org/
2018/1021.
Cited on page 4.
[CDHK15] Jan Camenisch, Maria Dubovitskaya, Kristiyan Haralambiev, and Markulf
Kohlweiss. Composable and modular anonymous credentials: Definitions and
practical constructions. In Tetsu Iwata and Jung Hee Cheon, editors, ASIACRYPT 2015, Part II, volume 9453 of LNCS, pages 262–288, Auckland, New
Zealand, November 30 – December 3, 2015. Springer, Heidelberg, Germany. Cited
on page 9.
[CF15]

Dario Catalano and Dario Fiore. Using linearly-homomorphic encryption to evaluate degree-2 functions on encrypted data. In Indrajit Ray, Ninghui Li, and Christopher Kruegel, editors, ACM CCS 2015, pages 1518–1529, Denver, CO, USA, October 12–16, 2015. ACM Press.
Cited on
page 25.

[CFN94]

Benny Chor, Amos Fiat, and Moni Naor. Tracing traitors. In Yvo Desmedt,
editor, CRYPTO’94, volume 839 of LNCS, pages 257–270, Santa Barbara, CA,
USA, August 21–25, 1994. Springer, Heidelberg, Germany.
Cited on page 5.

[CFN18]

Dario Catalano, Dario Fiore, and Luca Nizzardo. On the security notions for homomorphic signatures. In Bart Preneel and Frederik Vercauteren, editors, ACNS 18,
volume 10892 of LNCS, pages 183–201, Leuven, Belgium, July 2–4, 2018. Springer,
Heidelberg, Germany.
Cited on page 48.

[CFNP00]

Benny Chor, Amos Fiat, Moni Naor, and Benny Pinkas. Tracing traitors. IEEE
Transactions on Information Theory, 46(3):893–910, 2000.
Cited on page 5.



114

BIBLIOGRAPHY

[Cha81]

David L. Chaum. Untraceable electronic mail, return addresses, and digital
pseudonyms. Commun. ACM, 24(2):84–90, February 1981.
Cited on pages 4
and 5.

[CHP07]

Jan Camenisch, Susan Hohenberger, and Michael Østergaard Pedersen. Batch verification of short signatures. In Moni Naor, editor, EUROCRYPT 2007, volume
4515 of LNCS, pages 246–263, Barcelona, Spain, May 20–24, 2007. Springer, Heidelberg, Germany.
Cited on
page 67.

[CKLM12] Melissa Chase, Markulf Kohlweiss, Anna Lysyanskaya, and Sarah Meiklejohn. Malleable proof systems and applications. In David Pointcheval and Thomas Johansson,
editors, EUROCRYPT 2012, volume 7237 of LNCS, pages 281–300, Cambridge,
UK, April 15–19, 2012. Springer, Heidelberg, Germany.
Cited on page 67.
[CL11]

Sébastien Canard and Roch Lescuyer. Anonymous credentials from (indexed) aggregate signatures. In Abhilasha Bhargav-Spantzel and Thomas Groß, editors,
DIM’11, Proceedings of the 2013 ACM Workshop on Digital Identity Management,
Chicago, IL, USA - October 21, 2011, pages 53–62. ACM, 2011. Cited on pages 8,
81, 84, 98, and 101.

[CL13]

Sébastien Canard and Roch Lescuyer. Protecting privacy by sanitizing personal
data: a new approach to anonymous credentials. In Kefei Chen, Qi Xie, Weidong Qiu, Ninghui Li, and Wen-Guey Tzeng, editors, ASIACCS 13, pages 381–392,
Hangzhou, China, May 8–10, 2013. ACM Press.
Cited on pages 9 and 101.

[CPRT18]

Chris Culnane, Olivier Pereira, Kim Ramchen, and Vanessa Teague. Universally verifiable MPC with applications to IRV ballot counting. Cryptology ePrint
Archive, Report 2018/246, 2018. https://eprint.iacr.org/2018/246. Cited on
page 26.

[CS13]

Véronique Cortier and Ben Smyth. Attacking and fixing helios: An analysis of
ballot secrecy. J. Comput. Secur., 21(1):89–148, January 2013. Cited on pages 66
and 79.

[Dam92]

Ivan Damgård. Towards practical public key systems secure against chosen ciphertext attacks. In Joan Feigenbaum, editor, CRYPTO’91, volume 576 of LNCS, pages
445–456, Santa Barbara, CA, USA, August 11–15, 1992. Springer, Heidelberg, Germany.
Cited on
page 52.

[Dam00]

Ivan Damgård. Efficient concurrent zero-knowledge in the auxiliary string model.
In Bart Preneel, editor, EUROCRYPT 2000, volume 1807 of LNCS, pages 418–430,
Bruges, Belgium, May 14–18, 2000. Springer, Heidelberg, Germany.
Cited on
page 14.

[Des93]

Yvo Desmedt. Computer security by redefining what a computer is. In Proceedings on the 1992-1993 Workshop on New Security Paradigms, NSPW ’92-93, page
160–166, New York, NY, USA, 1993. Association for Computing Machinery. Cited
on page 19.

[DH76]

Whitfield Diffie and Martin E. Hellman. New directions in cryptography. IEEE
Transactions on Information Theory, 22(6):644–654, 1976.
Cited on pages 3
and 18.



BIBLIOGRAPHY

115

[Dor43]

Robert Dorfman. The detection of defective members of large populations. The
Annals of Mathematical Statistics, 14(4):436–440, 1943.
Cited on page 44.

[DPP20]

Xuan Thanh Do, Duong Hieu Phan, and David Pointcheval. Traceable inner product functional encryption. In Stanislaw Jarecki, editor, CT-RSA 2020, volume
12006 of LNCS, pages 564–585, San Francisco, CA, USA, February 24–28, 2020.
Springer, Heidelberg, Germany.
Cited on page 5.

[ElG84]

Taher ElGamal. A public key cryptosystem and a signature scheme based on discrete logarithms. In G. R. Blakley and David Chaum, editors, CRYPTO’84, volume
196 of LNCS, pages 10–18, Santa Barbara, CA, USA, August 19–23, 1984. Springer,
Heidelberg, Germany.
Cited on pages 3 and 15.

[FHS19]

Georg Fuchsbauer, Christian Hanser, and Daniel Slamanig. Structure-preserving
signatures on equivalence classes and constant-size anonymous credentials. Journal
of Cryptology, 32(2):498–546, April 2019.
Cited on pages 9, 51, 52, 81, 92,
and 101.

[FLSZ17]

Prastudy Fauzi, Helger Lipmaa, Janno Siim, and Michal Zajac. An efficient pairingbased shuffle argument. In Tsuyoshi Takagi and Thomas Peyrin, editors, ASIACRYPT 2017, Part II, volume 10625 of LNCS, pages 97–127, Hong Kong, China,
December 3–7, 2017. Springer, Heidelberg, Germany.
Cited on page 61.

[FN94]

Amos Fiat and Moni Naor. Broadcast encryption. In Douglas R. Stinson, editor,
CRYPTO’93, volume 773 of LNCS, pages 480–491, Santa Barbara, CA, USA, August 22–26, 1994. Springer, Heidelberg, Germany.
Cited on
page 4.

[Fre10]

David Mandell Freeman. Converting pairing-based cryptosystems from compositeorder groups to prime-order groups. In Henri Gilbert, editor, EUROCRYPT 2010,
volume 6110 of LNCS, pages 44–61, French Riviera, May 30 – June 3, 2010.
Springer, Heidelberg, Germany.
Cited on pages 8, 17, and 25.

[Fre12]

David Mandell Freeman. Improved security for linearly homomorphic signatures:
A generic framework. In Marc Fischlin, Johannes Buchmann, and Mark Manulis,
editors, PKC 2012, volume 7293 of LNCS, pages 697–714, Darmstadt, Germany,
May 21–23, 2012. Springer, Heidelberg, Germany.
Cited on page 47.

[FS01]

Jun Furukawa and Kazue Sako. An efficient scheme for proving a shuffle. In
Joe Kilian, editor, CRYPTO 2001, volume 2139 of LNCS, pages 368–387, Santa
Barbara, CA, USA, August 19–23, 2001. Springer, Heidelberg, Germany. Cited on
page 61.

[Gay16]

Romain Gay. Functional encryption for quadratic functions, and applications to
predicate encryption. Cryptology ePrint Archive, Report 2016/1106, 2016. https:
//eprint.iacr.org/2016/1106.
Cited on page 4.

[Gen09]

Craig Gentry. Fully homomorphic encryption using ideal lattices. In Michael
Mitzenmacher, editor, 41st ACM STOC, pages 169–178, Bethesda, MD, USA,
May 31 – June 2, 2009. ACM Press.
Cited on pages 4 and 6.

[GGG+ 14] Shafi Goldwasser, S. Dov Gordon, Vipul Goyal, Abhishek Jain, Jonathan Katz,
Feng-Hao Liu, Amit Sahai, Elaine Shi, and Hong-Sheng Zhou. Multi-input functional encryption. In Phong Q. Nguyen and Elisabeth Oswald, editors, EUROCRYPT 2014, volume 8441 of LNCS, pages 578–602, Copenhagen, Denmark,
May 11–15, 2014. Springer, Heidelberg, Germany.
Cited on page 4.



116

BIBLIOGRAPHY

[GGH+ 13]

Sanjam Garg, Craig Gentry, Shai Halevi, Mariana Raykova, Amit Sahai, and Brent
Waters. Candidate indistinguishability obfuscation and functional encryption for
all circuits. In 54th FOCS, pages 40–49, Berkeley, CA, USA, October 26–29, 2013.
IEEE Computer Society Press.
Cited on page 4.

[GGJS13]

Shafi Goldwasser, Vipul Goyal, Abhishek Jain, and Amit Sahai. Multi-input functional encryption. Cryptology ePrint Archive, Report 2013/727, 2013. https:
//eprint.iacr.org/2013/727.
Cited on page 4.

[GKL+ 13]

S. Dov Gordon, Jonathan Katz, Feng-Hao Liu, Elaine Shi, and Hong-Sheng Zhou.
Multi-input functional encryption. Cryptology ePrint Archive, Report 2013/774,
2013. https://eprint.iacr.org/2013/774.
Cited on page 4.

[GKP+ 13]

Shafi Goldwasser, Yael Tauman Kalai, Raluca A. Popa, Vinod Vaikuntanathan, and
Nickolai Zeldovich. Reusable garbled circuits and succinct functional encryption. In
Dan Boneh, Tim Roughgarden, and Joan Feigenbaum, editors, 45th ACM STOC,
pages 555–564, Palo Alto, CA, USA, June 1–4, 2013. ACM Press. Cited on page 4.

[GL07]

Jens Groth and Steve Lu. A non-interactive shuffle with pairing based verifiability.
In Kaoru Kurosawa, editor, ASIACRYPT 2007, volume 4833 of LNCS, pages 51–
67, Kuching, Malaysia, December 2–6, 2007. Springer, Heidelberg, Germany. Cited
on page 61.

[GMR85]

Shafi Goldwasser, Silvio Micali, and Charles Rackoff. The knowledge complexity of
interactive proof-systems (extended abstract). In 17th ACM STOC, pages 291–304,
Providence, RI, USA, May 6–8, 1985. ACM Press.
Cited on pages 7 and 21.

[GMR88]

Shafi Goldwasser, Silvio Micali, and Ronald L. Rivest. A digital signature scheme
secure against adaptive chosen-message attacks. SIAM Journal on Computing,
17(2):281–308, April 1988.
Cited on page 18.

[GMW87]

Oded Goldreich, Silvio Micali, and Avi Wigderson. How to prove all NP-statements
in zero-knowledge, and a methodology of cryptographic protocol design. In Andrew M. Odlyzko, editor, CRYPTO’86, volume 263 of LNCS, pages 171–185, Santa
Barbara, CA, USA, August 1987. Springer, Heidelberg, Germany. Cited on page 7.

[Gro10]

Jens Groth. Short pairing-based non-interactive zero-knowledge arguments. In
Masayuki Abe, editor, ASIACRYPT 2010, volume 6477 of LNCS, pages 321–340,
Singapore, December 5–9, 2010. Springer, Heidelberg, Germany. Cited on page 52.

[GS08]

Jens Groth and Amit Sahai. Efficient non-interactive proof systems for bilinear
groups. In Nigel P. Smart, editor, EUROCRYPT 2008, volume 4965 of LNCS,
pages 415–432, Istanbul, Turkey, April 13–17, 2008. Springer, Heidelberg, Germany.
Cited on pages 7, 8, 22, 54, 58, 61, 67, 87, and 89.

[GVW15]

Sergey Gorbunov, Vinod Vaikuntanathan, and Daniel Wichs. Leveled fully homomorphic signatures from standard lattices. In Rocco A. Servedio and Ronitt Rubinfeld, editors, 47th ACM STOC, pages 469–477, Portland, OR, USA, June 14–17,
2015. ACM Press.
Cited on page 48.

[HHK+ 17]

Gottfried Herold, Max Hoffmann, Michael Klooß, Carla Ràfols, and Andy Rupp.
New techniques for structural batch verification in bilinear groups with applications
to groth-sahai proofs. In Bhavani M. Thuraisingham, David Evans, Tal Malkin,
and Dongyan Xu, editors, ACM CCS 2017, pages 1547–1564, Dallas, TX, USA,
October 31 – November 2, 2017. ACM Press.
Cited on page 67.



BIBLIOGRAPHY

117

[HP20]

Chloé Hébant and David Pointcheval. Traceable constant-size multi-authority credentials. Cryptology ePrint Archive, Report 2020/657, 2020. https://eprint.
iacr.org/2020/657.
Cited on pages 8, 9, 47, and 81.

[HPP19]

Chloé Hébant, Duong Hieu Phan, and David Pointcheval. Decentralized evaluation
of quadratic polynomials on encrypted data. In Zhiqiang Lin, Charalampos Papamanthou, and Michalis Polychronakis, editors, ISC 2019, volume 11723 of LNCS,
pages 87–106, New York City, NY, USA, September 16–18, 2019. Springer, Heidelberg, Germany.
Cited on pages 8, 9,
and 25.

[HPP20]

Chloé Hébant, Duong Hieu Phan, and David Pointcheval. Linearly-homomorphic
signatures and scalable mix-nets. In Aggelos Kiayias, Markulf Kohlweiss, Petros
Wallden, and Vassilis Zikas, editors, PKC 2020, Part II, volume 12111 of LNCS,
pages 597–627, Edinburgh, UK, May 4–7, 2020. Springer, Heidelberg, Germany.
Cited on pages 8, 9, 47, 61, 89, 91, and 108.

[HT98]

Satoshi Hada and Toshiaki Tanaka. On the existence of 3-round zero-knowledge
protocols. In Hugo Krawczyk, editor, CRYPTO’98, volume 1462 of LNCS, pages
408–423, Santa Barbara, CA, USA, August 23–27, 1998. Springer, Heidelberg, Germany.
Cited on
page 52.

[JMSW02] Robert Johnson, David Molnar, Dawn Xiaodong Song, and David Wagner. Homomorphic signature schemes. In Bart Preneel, editor, CT-RSA 2002, volume 2271 of
LNCS, pages 244–262, San Jose, CA, USA, February 18–22, 2002. Springer, Heidelberg, Germany.
Cited on pages 6
and 47.
[Ker83]

Auguste Kerckhoffs. La cryptographie militaire, ou les chiffres usités en temps de
guerre, avec un nouveau procédé de déchiffrement applicable aux systèmes à double
clef. Paris: Librairie militaire de L. Baudoin, 1883. 64 pp. See also Journal des
sciences militaires, Paris. N.S. Tome 9. 59., 1883.
Cited on page 2.

[KMH+ 19] Yutaka Kawai, Takahiro Matsuda, Takato Hirano, Yoshihiro Koseki, and Goichiro
Hanaoka. Proxy re-encryption that supports homomorphic operations for reencrypted ciphertexts. IEICE Transactions on Fundamentals of Electronics, Communications and Computer Sciences, E102.A:81–98, 01 2019.
Cited on
page 25.
[LPJY13]

Benoît Libert, Thomas Peters, Marc Joye, and Moti Yung. Linearly homomorphic
structure-preserving signatures and their applications. In Ran Canetti and Juan A.
Garay, editors, CRYPTO 2013, Part II, volume 8043 of LNCS, pages 289–307,
Santa Barbara, CA, USA, August 18–22, 2013. Springer, Heidelberg, Germany.
Cited on pages 19, 47, 48, 49, 50, and 51.

[LW11]

Allison B. Lewko and Brent Waters. Decentralizing attribute-based encryption. In
Kenneth G. Paterson, editor, EUROCRYPT 2011, volume 6632 of LNCS, pages
568–588, Tallinn, Estonia, May 15–19, 2011. Springer, Heidelberg, Germany. Cited
on page 4.

[LYJP14]

Benoît Libert, Moti Yung, Marc Joye, and Thomas Peters. Traceable group encryption. In Hugo Krawczyk, editor, PKC 2014, volume 8383 of LNCS, pages 592–610,
Buenos Aires, Argentina, March 26–28, 2014. Springer, Heidelberg, Germany. Cited
on page 5.



118

BIBLIOGRAPHY

[Nef01]

C. Andrew Neff. A verifiable secret shuffle and its application to e-voting. In
Michael K. Reiter and Pierangela Samarati, editors, ACM CCS 2001, pages 116–
125, Philadelphia, PA, USA, November 5–8, 2001. ACM Press.
Cited on
page 61.

[NNL01]

Dalit Naor, Moni Naor, and Jeffery Lotspiech. Revocation and tracing schemes for
stateless receivers. In Joe Kilian, editor, CRYPTO 2001, volume 2139 of LNCS,
pages 41–62, Santa Barbara, CA, USA, August 19–23, 2001. Springer, Heidelberg,
Germany.
Cited on page 4.

[Pai99]

Pascal Paillier. Public-key cryptosystems based on composite degree residuosity
classes. In Jacques Stern, editor, EUROCRYPT’99, volume 1592 of LNCS, pages
223–238, Prague, Czech Republic, May 2–6, 1999. Springer, Heidelberg, Germany.
Cited on page 6.

[PPS12]

Duong Hieu Phan, David Pointcheval, and Mario Strefler. Decentralized dynamic
broadcast encryption. In Ivan Visconti and Roberto De Prisco, editors, SCN 12,
volume 7485 of LNCS, pages 166–183, Amalfi, Italy, September 5–7, 2012. Springer,
Heidelberg, Germany.
Cited on page 4.

[Riv00]

Ron Rivest. Two signature schemes, 2000.

[RSA78]

Ronald L. Rivest, Adi Shamir, and Leonard M. Adleman. A method for obtaining
digital signatures and public-key cryptosystems. Communications of the Association
for Computing Machinery, 21(2):120–126, 1978.
Cited on page 2.

[San20]

Olivier Sanders. Efficient redactable signature and application to anonymous credentials. In Aggelos Kiayias, Markulf Kohlweiss, Petros Wallden, and Vassilis Zikas,
editors, PKC 2020, Part II, volume 12111 of LNCS, pages 628–656, Edinburgh, UK,
May 4–7, 2020. Springer, Heidelberg, Germany.
Cited on pages 81, 82, 92, 94,
and 101.

[Sch90]

Claus-Peter Schnorr. Efficient identification and signatures for smart cards. In
Gilles Brassard, editor, CRYPTO’89, volume 435 of LNCS, pages 239–252, Santa
Barbara, CA, USA, August 20–24, 1990. Springer, Heidelberg, Germany. Cited on
page 18.

[Sch14]

Rob Schapire. Computer science 511 – theoretical machine learning, 2014.
on page 45.

[Sha49]

Claude E. Shannon. Communication theory of secrecy systems. Bell Systems Technical Journal, 28(4):656–715, 1949.
Cited on
page 3.

[Sha79]

Adi Shamir. How to share a secret. Communications of the Association for Computing Machinery, 22(11):612–613, November 1979.
Cited on pages 6
and 37.

[Sho97]

Victor Shoup. Lower bounds for discrete logarithms and related problems. In Walter
Fumy, editor, EUROCRYPT’97, volume 1233 of LNCS, pages 256–266, Konstanz,
Germany, May 11–15, 1997. Springer, Heidelberg, Germany.
Cited on pages 14,
49, and 89.

[SW05]

Amit Sahai and Brent R. Waters. Fuzzy identity-based encryption. In Ronald
Cramer, editor, EUROCRYPT 2005, volume 3494 of LNCS, pages 457–473, Aarhus,
Denmark, May 22–26, 2005. Springer, Heidelberg, Germany.
Cited on page 4.

Cited on page 6.

Cited



BIBLIOGRAPHY

119

[TW87]

Martin Tompa and Heather Woll. Random self-reducibility and zero knowledge
interactive proofs of possession of information. In 28th FOCS, pages 472–482, Los
Angeles, CA, USA, October 12–14, 1987. IEEE Computer Society Press. Cited on
page 83.

[Ver17]

Damien Vergnaud. Comment on ’Attribute-Based Signatures for Supporting
Anonymous Certification’ by N. Kaaniche and M. Laurent (ESORICS 2016). The
Computer Journal, 60(12):1801–1808, 2017.
Cited on page 9.







RÉSUMÉ
Avec l’utilisation massive du stockage dématérialisé, l’homomorphisme est devenu l’une des propriétés les plus largement
employées en cryptologie. Dans cette thèse, nous allons étudier comment l’utiliser dans des protocoles multi-utilisateurs
concrets qui nécessitent non seulement de la confidentialité, mais aussi de l’anonymat, de l’authentification ou encore
de la vérifiabilité. Pour cela, nous utilisons des schémas homomorphes de chiffrement, de signature numérique et de
preuves à divulgation nulle de connaissances, mais, à chaque fois, nous devrons limiter leurs capacités de malléabilité
pour atteindre le niveau de sécurité préalablement défini.
Tout d’abord, l’aspect confidentiel est abordé au travers de l’étude de calculs sur des bases de données externalisées.
Être capable d’appliquer des fonctions sur des données chiffrées sans avoir à les télécharger pour les déchiffrer entièrement est permet de profiter de la puissance de calcul du serveur qui est généralement supérieure à celle du client.
Cela peut être également indispensable lorsqu’une société sans droit d’accès à une base de données de clients souhaite
obtenir le résultat d’un calcul. La quantité d’information apprise ne doit pas être supérieure à celle contenue dans le
résultat du calcul. Nous proposons pour cela un schéma de chiffrement décentralisé qui permet d’évaluer des fonctions
quadratiques sur les données externalisées tout en ayant un contrôle des opérations grâce à un groupe d’inspecteurs.
Cependant, la confidentialité des données n’est pas toujours la propriété la plus recherchée pour un système car elle ne
protège pas l’identité de l’expéditeur. Pour le vote électronique, chaque bulletin chiffré doit être associé à un électeur afin
de vérifier que celui-ci était autorisé à voter, mais après la phase de vote, l’anonymat doit être assuré. Pour cela une solution est de mélanger plusieurs fois l’urne de sorte que, au moment du dépouillement, qui correspond au déchiffrement,
aucun lien entre le vote et l’électeur ne puisse être fait. C’est le fonctionnement d’un réseau de serveurs-mélangeurs
dont nous proposons une nouvelle construction basée sur des signatures linéairement homomorphes avec un coût de
vérification de l’urne finale indépendant du nombre de mélanges. Ce protocole est donc d’autant plus efficace que le
nombre de mélanges augmente et représente un progrès par rapport aux constructions déjà connues.
Dans certains cas, avoir un anonymat parfait permettrait l’utilisation malveillante d’un système et la cryptologie doit aussi
tenir compte de ces abus potentiels. La troisième contribution de cette thèse consiste en la proposition du premier protocole d’accréditation anonyme multi-autorités traçable : un utilisateur demande une accréditation auprès d’une autorité
émettrice et peut l’utiliser pour accéder à un système tout en restant anonyme. En cas d’abus, une autorité juge peut lever
l’anonymat et retrouver un utilisateur malveillant grâce au traçage. De plus, ce protocole, tout en étant aussi efficace que
les précédents pour une seule autorité émettrice, permet d’agréger des accréditations d’autorités émettrices distinctes
pour avoir une accréditation de taille optimale .

MOTS CLÉS
Cryptographie à Clé Publique
tipartites

? Protocoles Homomorphes ? Anonymat ? Vote Electronique ? Calculs Mul-

ABSTRACT
With the massive use of dematerialized storage, homomorphism has become one of the most widely used properties in
cryptology. In this thesis we will study how to use it in concrete multi-users protocols requiring not only confidentiality
but also anonymity, authentication or verifiability. Homomorphic encryption schemes, homomorphic digital signatures
and homomorphic zero-knowledge proofs will be used together, but each time restricted to achieve the desired level of
security.
First, the confidential aspect is studied for computations on large outsourced databases. Being able to apply functions on
encrypted data without having to download and decrypt it entirely may be essential and allows to take advantage of the
computational power of the server. This can also be interesting when a third-party company without right-access to the
database wants to obtain the result of a computation. However, some guarantees on the learned information need to be
taken. To this end, we present a decentralized encryption scheme that allows controlled evaluation of quadratic functions
on outsourced data thanks to a group of controllers.
However, sometimes confidentiality of the data is not the most desired property for a system as it does not protect the
sender. For electronic voting, each encrypted ballot must be associated with its voter to verify that he is allowed to
vote. After the voting phase, anonymity is achieved by shuffling so that, during the count, which corresponds to the
decryption, no link between votes and voters can be made. We propose a new construction of mix-network based on
linearly homomorphic signatures which allows for the first time a verification which is cost-independent of the number of
mix-servers. This scalable mix-net improves the efficiency compared to already known constructions, especially with an
increasing number of shuffles.
Nevertheless, with perfect anonymity comes the threat of malicious use of the system. Cryptology must consider these
possible abuses and we propose the first multi-authority anonymous credential protocol with traceability property: a user
asks a credential issuer for a credential and uses it to access a system while remaining anonymous. In case of abuse, an
authority can revoke anonymity and trace a malicious user. The scheme is as efficient as the previously known credential
schemes while achieving the multi-credential issuer functionality.

KEYWORDS
Public-Key Cryptography ? Homomorphic Protocols ? Anonymity ? E-voting ? Multi-party Computation

